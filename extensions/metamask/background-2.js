LavaPack.loadBundle(
  [
    [
      205,
      {
        '../../development/build/constants': 389,
        '../../shared/constants/app': 5789,
        '../../shared/constants/bridge': 5790,
        '../../shared/constants/hardware-wallets': 5796,
        '../../shared/constants/keyring': 5797,
        '../../shared/constants/logs': 5799,
        '../../shared/constants/metametrics': 5800,
        '../../shared/constants/methods-tags': 5801,
        '../../shared/constants/multichain/networks': 5803,
        '../../shared/constants/network': 5804,
        '../../shared/constants/permissions': 5808,
        '../../shared/constants/smartTransactions': 5813,
        '../../shared/constants/swaps': 5815,
        '../../shared/constants/time': 5817,
        '../../shared/constants/tokens': 5818,
        '../../shared/constants/transaction': 5819,
        '../../shared/constants/urls': 5820,
        '../../shared/lib/accounts': 5824,
        '../../shared/lib/accounts/solana-wallet-snap': 5827,
        '../../shared/lib/fetch-with-cache': 5834,
        '../../shared/lib/metamask-controller-utils': 5838,
        '../../shared/lib/storage-helpers': 5845,
        '../../shared/lib/token-util': 5848,
        '../../shared/lib/trace': 5849,
        '../../shared/lib/transactions-controller-utils': 5851,
        '../../shared/modules/caip-stream': 5856,
        '../../shared/modules/mv3.utils': 5867,
        '../../shared/modules/network.utils': 5868,
        '../../shared/modules/selectors': 5874,
        '../../shared/modules/selectors/networks': 5875,
        '../../shared/modules/string-utils': 5878,
        '../../shared/modules/transaction.utils': 5880,
        '../../shared/notifications': 5882,
        '../../shared/types/bridge-status': 5883,
        './constants/stream': 9,
        './controller-init/assets': 11,
        './controller-init/confirmations/ppom-controller-init': 15,
        './controller-init/confirmations/transaction-controller-init': 16,
        './controller-init/identity/authentication-controller-init': 17,
        './controller-init/identity/user-storage-controller-init': 18,
        './controller-init/institutional-snap/institutional-snap-controller-init': 19,
        './controller-init/multichain': 49,
        './controller-init/notifications/notification-services-controller-init': 55,
        './controller-init/notifications/notification-services-push-controller-init': 56,
        './controller-init/snaps': 59,
        './controller-init/utils': 66,
        './controllers/account-order': 67,
        './controllers/account-tracker-controller': 68,
        './controllers/alert-controller': 69,
        './controllers/app-metadata': 70,
        './controllers/app-state-controller': 71,
        './controllers/bridge-status/bridge-status-controller': 72,
        './controllers/bridge-status/constants': 73,
        './controllers/decrypt-message': 76,
        './controllers/encryption-public-key': 77,
        './controllers/metametrics-controller': 79,
        './controllers/metametrics-data-deletion/metametrics-data-deletion': 80,
        './controllers/network-order': 81,
        './controllers/onboarding': 82,
        './controllers/permissions': 86,
        './controllers/preferences-controller': 89,
        './controllers/swaps': 93,
        './detect-multiple-instances': 96,
        './lib/AccountIdentitiesPetnamesBridge': 107,
        './lib/AddressBookPetnamesBridge': 108,
        './lib/ComposableObservableStore': 109,
        './lib/PatchStore': 110,
        './lib/SnapsNameProvider': 111,
        './lib/WeakRefObjectMap': 112,
        './lib/approval/utils': 113,
        './lib/backup': 114,
        './lib/bridge-status/metrics': 116,
        './lib/createDupeReqFilterStream': 117,
        './lib/createEvmMethodsToNonEvmAccountReqFilterMiddleware': 118,
        './lib/createLoggerMiddleware': 119,
        './lib/createMainFrameOriginMiddleware': 120,
        './lib/createMetaRPCHandler': 121,
        './lib/createMetamaskMiddleware': 122,
        './lib/createOnboardingMiddleware': 123,
        './lib/createOriginMiddleware': 124,
        './lib/createOriginThrottlingMiddleware': 125,
        './lib/createRPCMethodTrackingMiddleware': 126,
        './lib/createTabIdMiddleware': 128,
        './lib/createTracingMiddleware': 129,
        './lib/encryptor-factory': 130,
        './lib/hardware-keyring-builder-factory': 138,
        './lib/multichain/address': 142,
        './lib/offscreen-bridge/lattice-offscreen-keyring': 144,
        './lib/offscreen-bridge/ledger-offscreen-bridge': 145,
        './lib/offscreen-bridge/trezor-offscreen-bridge': 146,
        './lib/ppom/ppom-middleware': 148,
        './lib/ppom/ppom-util': 149,
        './lib/rpc-method-middleware': 169,
        './lib/rpc-method-middleware/handlers/wallet-createSession': 164,
        './lib/segment': 171,
        './lib/signature/util': 175,
        './lib/snap-keyring': 177,
        './lib/snap-keyring/keyring-snaps-permissions': 178,
        './lib/state-utils': 184,
        './lib/stream-utils': 189,
        './lib/transaction/decode/util': 195,
        './lib/transaction/eip5792': 197,
        './lib/transaction/metrics': 199,
        './lib/transaction/util': 202,
        './lib/tx-verification/tx-verification-middleware': 203,
        './lib/util': 204,
        './services/data-deletion-service': 384,
        './translate': 386,
        '@ethersproject/abi': 504,
        '@keystonehq/metamask-airgapped-keyring': 710,
        '@metamask/accounts-controller': 1315,
        '@metamask/address-book-controller': 1318,
        '@metamask/announcement-controller': 1320,
        '@metamask/approval-controller': 1323,
        '@metamask/assets-controllers': 1353,
        '@metamask/base-controller': 1407,
        '@metamask/bridge-controller': 1414,
        '@metamask/chain-agnostic-permission': 1498,
        '@metamask/controller-utils': 1515,
        '@metamask/ens-controller': 1544,
        '@metamask/eth-json-rpc-filters': 1600,
        '@metamask/eth-json-rpc-filters/subscriptionManager': 1602,
        '@metamask/eth-json-rpc-middleware': 1614,
        '@metamask/eth-ledger-bridge-keyring': 1675,
        '@metamask/eth-sig-util': 1727,
        '@metamask/eth-trezor-keyring': 1888,
        '@metamask/gas-fee-controller': 1954,
        '@metamask/json-rpc-engine': 1964,
        '@metamask/json-rpc-middleware-stream': 1968,
        '@metamask/keyring-api': 2014,
        '@metamask/keyring-controller': 2021,
        '@metamask/logging-controller': 2094,
        '@metamask/metamask-eth-abis': 2113,
        '@metamask/multichain-api-middleware': 2118,
        '@metamask/name-controller': 2190,
        '@metamask/network-controller': 2202,
        '@metamask/notification-services-controller/notification-services': 2372,
        '@metamask/obs-store': 2414,
        '@metamask/obs-store/dist/asStream': 2413,
        '@metamask/permission-controller': 2421,
        '@metamask/permission-log-controller': 2430,
        '@metamask/phishing-controller': 2434,
        '@metamask/queued-request-controller': 2547,
        '@metamask/remote-feature-flag-controller': 2578,
        '@metamask/rpc-errors': 2585,
        '@metamask/scure-bip39/dist/wordlists/english': 2589,
        '@metamask/selected-network-controller': 2602,
        '@metamask/signature-controller': 2609,
        '@metamask/smart-transactions-controller': 2660,
        '@metamask/smart-transactions-controller/dist/types': 2661,
        '@metamask/snaps-controllers': 2668,
        '@metamask/snaps-rpc-methods': 2733,
        '@metamask/snaps-utils': 2890,
        '@metamask/transaction-controller': 2946,
        '@metamask/user-operation-controller': 2973,
        '@metamask/utils': 2995,
        '@sentry/browser': 3136,
        'await-semaphore': 3969,
        buffer: 4139,
        'eth-chainlist': 4341,
        'eth-lattice-keyring': 4346,
        events: 4465,
        lodash: 4921,
        loglevel: 4929,
        nanoid: 5027,
        'readable-stream': 5343,
      },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                (function (t) {
                  (function () {
                    Object.defineProperty(n, '__esModule', { value: !0 }),
                      (n.default = n.METAMASK_CONTROLLER_EVENTS = void 0);
                    var r = on(e('events')),
                      s = e('readable-stream'),
                      a = e('@metamask/assets-controllers'),
                      o = e('@metamask/json-rpc-engine'),
                      i = e('@metamask/json-rpc-middleware-stream'),
                      c = e('@metamask/obs-store'),
                      l = e('@metamask/obs-store/dist/asStream'),
                      d = e('@metamask/eth-json-rpc-middleware'),
                      u = e('lodash'),
                      h = e('@metamask/keyring-controller'),
                      p = on(e('@metamask/eth-json-rpc-filters')),
                      m = on(e('@metamask/eth-json-rpc-filters/subscriptionManager')),
                      f = e('@metamask/rpc-errors'),
                      g = e('await-semaphore'),
                      b = on(e('loglevel')),
                      y = e('@metamask/eth-trezor-keyring'),
                      w = e('@metamask/eth-ledger-bridge-keyring'),
                      v = on(e('eth-lattice-keyring')),
                      C = e('eth-chainlist'),
                      k = e('@keystonehq/metamask-airgapped-keyring'),
                      S = e('nanoid'),
                      _ = e('@sentry/browser'),
                      E = e('@metamask/address-book-controller'),
                      T = e('@metamask/approval-controller'),
                      M = e('@metamask/base-controller'),
                      P = e('@metamask/ens-controller'),
                      A = e('@metamask/phishing-controller'),
                      N = e('@metamask/announcement-controller'),
                      I = e('@metamask/network-controller'),
                      x = e('@metamask/gas-fee-controller'),
                      R = e('@metamask/permission-controller'),
                      O = on(e('@metamask/smart-transactions-controller')),
                      j = e('@metamask/smart-transactions-controller/dist/types'),
                      B = e('@metamask/selected-network-controller'),
                      $ = e('@metamask/logging-controller'),
                      D = e('@metamask/permission-log-controller'),
                      L = e('@metamask/snaps-controllers'),
                      F = e('@metamask/snaps-rpc-methods'),
                      q = e('@metamask/controller-utils'),
                      U = e('@metamask/accounts-controller'),
                      H = e('@metamask/remote-feature-flag-controller'),
                      V = e('@metamask/signature-controller'),
                      K = e('@metamask/scure-bip39/dist/wordlists/english'),
                      G = e('@metamask/name-controller'),
                      W = e('@metamask/queued-request-controller'),
                      z = e('@metamask/user-operation-controller'),
                      Z = e('@metamask/bridge-controller'),
                      J = e('@metamask/transaction-controller'),
                      Q = e('@metamask/snaps-utils'),
                      Y = e('@ethersproject/abi'),
                      X = e('@metamask/metamask-eth-abis'),
                      ee = e('@metamask/keyring-api'),
                      te = e('@metamask/utils'),
                      ne = e('@metamask/eth-sig-util'),
                      re = e('@metamask/notification-services-controller/notification-services'),
                      se = e('@metamask/multichain-api-middleware'),
                      ae = e('@metamask/chain-agnostic-permission'),
                      oe = e('../../shared/constants/methods-tags'),
                      ie = e('../../shared/constants/transaction'),
                      ce = e('../../shared/constants/swaps'),
                      le = e('../../shared/constants/network'),
                      de = e('../../shared/constants/smartTransactions'),
                      ue = e('../../shared/constants/hardware-wallets'),
                      he = e('../../shared/constants/keyring'),
                      pe = e('../../shared/constants/permissions'),
                      me = e('../../shared/notifications'),
                      fe = e('../../shared/constants/time'),
                      ge = e('../../shared/constants/app'),
                      be = e('../../shared/constants/metametrics'),
                      ye = e('../../shared/constants/logs'),
                      we = e('../../shared/lib/storage-helpers'),
                      ve = e('../../shared/lib/token-util'),
                      Ce = e('../../shared/modules/string-utils'),
                      ke = e('../../shared/modules/transaction.utils'),
                      Se = e('../../shared/constants/tokens'),
                      _e = e('../../shared/lib/metamask-controller-utils'),
                      Ee = e('../../shared/modules/mv3.utils'),
                      Te = e('../../shared/modules/network.utils'),
                      Me = e('../../shared/modules/selectors'),
                      Pe = e('../../shared/modules/caip-stream'),
                      Ae = e('../../shared/constants/urls'),
                      Ne = e('../../shared/lib/transactions-controller-utils'),
                      Ie = e('../../shared/modules/selectors/networks'),
                      xe = e('../../shared/lib/trace'),
                      Re = e('../../development/build/constants'),
                      Oe = on(e('../../shared/lib/fetch-with-cache')),
                      je = e('../../shared/constants/multichain/networks'),
                      Be = e('../../shared/constants/bridge'),
                      $e = e('../../shared/types/bridge-status'),
                      De = e('../../shared/lib/accounts'),
                      Le = e('../../shared/lib/accounts/solana-wallet-snap'),
                      Fe = e('./lib/transaction/metrics'),
                      qe = e('./lib/snap-keyring/keyring-snaps-permissions'),
                      Ue = e('./lib/SnapsNameProvider'),
                      He = e('./lib/AddressBookPetnamesBridge'),
                      Ve = e('./lib/AccountIdentitiesPetnamesBridge'),
                      Ke = e('./lib/ppom/ppom-middleware'),
                      Ge = e('./detect-multiple-instances'),
                      We = on(e('./lib/ComposableObservableStore')),
                      ze = on(e('./controllers/account-tracker-controller')),
                      Ze = on(e('./lib/createDupeReqFilterStream')),
                      Je = on(e('./lib/createLoggerMiddleware')),
                      Qe = e('./lib/rpc-method-middleware'),
                      Ye = on(e('./lib/createOriginMiddleware')),
                      Xe = on(e('./lib/createMainFrameOriginMiddleware')),
                      et = on(e('./lib/createTabIdMiddleware')),
                      tt = e('./controllers/network-order'),
                      nt = e('./controllers/account-order'),
                      rt = on(e('./lib/createOnboardingMiddleware')),
                      st = e('./lib/stream-utils'),
                      at = e('./controllers/preferences-controller'),
                      ot = e('./controllers/app-state-controller'),
                      it = e('./controllers/alert-controller'),
                      ct = on(e('./controllers/onboarding')),
                      lt = on(e('./lib/backup')),
                      dt = on(e('./controllers/decrypt-message')),
                      ut = on(e('./controllers/swaps')),
                      ht = on(e('./controllers/metametrics-controller')),
                      pt = e('./lib/segment'),
                      mt = on(e('./lib/createMetaRPCHandler')),
                      ft = e('./lib/util'),
                      gt = on(e('./lib/createMetamaskMiddleware')),
                      bt = e('./lib/hardware-keyring-builder-factory'),
                      yt = on(e('./controllers/encryption-public-key')),
                      wt = on(e('./controllers/app-metadata')),
                      vt = e('./controllers/permissions'),
                      Ct = e('./controllers/metametrics-data-deletion/metametrics-data-deletion'),
                      kt = e('./services/data-deletion-service'),
                      St = on(e('./lib/createRPCMethodTrackingMiddleware')),
                      _t = e('./translate'),
                      Et = e('./lib/offscreen-bridge/trezor-offscreen-bridge'),
                      Tt = e('./lib/offscreen-bridge/ledger-offscreen-bridge'),
                      Mt = e('./lib/snap-keyring'),
                      Pt = e('./lib/encryptor-factory'),
                      At = e('./lib/transaction/util'),
                      Nt = e('./lib/signature/util'),
                      It = e('./lib/offscreen-bridge/lattice-offscreen-keyring'),
                      xt = e('./lib/WeakRefObjectMap'),
                      Rt = e('./constants/stream'),
                      Ot = e('./lib/tx-verification/tx-verification-middleware'),
                      jt = e('./lib/ppom/ppom-util'),
                      Bt = on(e('./lib/createEvmMethodsToNonEvmAccountReqFilterMiddleware')),
                      $t = e('./lib/multichain/address'),
                      Dt = e('./lib/transaction/decode/util'),
                      Lt = on(e('./lib/createTracingMiddleware')),
                      Ft = on(e('./lib/createOriginThrottlingMiddleware')),
                      qt = e('./lib/PatchStore'),
                      Ut = e('./lib/state-utils'),
                      Ht = e('./lib/rpc-method-middleware/handlers/wallet-createSession'),
                      Vt = on(e('./controllers/bridge-status/bridge-status-controller')),
                      Kt = e('./controllers/bridge-status/constants'),
                      Gt = e('./lib/approval/utils'),
                      Wt = e('./lib/bridge-status/metrics'),
                      zt = e(
                        './controller-init/institutional-snap/institutional-snap-controller-init'
                      ),
                      Zt = e('./controller-init/multichain'),
                      Jt = e('./controller-init/assets'),
                      Qt = e('./controller-init/confirmations/transaction-controller-init'),
                      Yt = e('./controller-init/confirmations/ppom-controller-init'),
                      Xt = e('./controller-init/utils'),
                      en = e('./controller-init/snaps'),
                      tn = e('./controller-init/identity/authentication-controller-init'),
                      nn = e('./controller-init/identity/user-storage-controller-init'),
                      rn = e('./lib/transaction/eip5792'),
                      sn = e(
                        './controller-init/notifications/notification-services-controller-init'
                      ),
                      an = e(
                        './controller-init/notifications/notification-services-push-controller-init'
                      );
                    function on(e) {
                      return e && e.__esModule ? e : { default: e };
                    }
                    function cn(e, t) {
                      (function (e, t) {
                        if (t.has(e))
                          throw new TypeError(
                            'Cannot initialize the same private elements twice on an object'
                          );
                      })(e, t),
                        t.add(e);
                    }
                    function ln(e, t, n) {
                      return (
                        (t = (function (e) {
                          var t = (function (e, t) {
                            if ('object' != typeof e || !e) return e;
                            var n = e[Symbol.toPrimitive];
                            if (void 0 !== n) {
                              var r = n.call(e, t || 'default');
                              if ('object' != typeof r) return r;
                              throw new TypeError('@@toPrimitive must return a primitive value.');
                            }
                            return ('string' === t ? String : Number)(e);
                          })(e, 'string');
                          return 'symbol' == typeof t ? t : t + '';
                        })(t)) in e
                          ? Object.defineProperty(e, t, {
                              value: n,
                              enumerable: !0,
                              configurable: !0,
                              writable: !0,
                            })
                          : (e[t] = n),
                        e
                      );
                    }
                    function dn(e, t, n) {
                      if ('function' == typeof e ? e === t : e.has(t))
                        return arguments.length < 3 ? t : n;
                      throw new TypeError('Private element is not present on this object');
                    }
                    n.METAMASK_CONTROLLER_EVENTS = {
                      UPDATE_BADGE: 'updateBadge',
                      DECRYPT_MESSAGE_MANAGER_UPDATE_BADGE: 'DecryptMessageManager:updateBadge',
                      ENCRYPTION_PUBLIC_KEY_MANAGER_UPDATE_BADGE:
                        'EncryptionPublicKeyManager:updateBadge',
                      APPROVAL_STATE_CHANGE: 'ApprovalController:stateChange',
                      APP_STATE_UNLOCK_CHANGE: 'AppStateController:unlockChange',
                      QUEUED_REQUEST_STATE_CHANGE: 'QueuedRequestController:stateChange',
                      METAMASK_NOTIFICATIONS_LIST_UPDATED:
                        'NotificationServicesController:notificationsListUpdated',
                      METAMASK_NOTIFICATIONS_MARK_AS_READ:
                        'NotificationServicesController:markNotificationsAsRead',
                    };
                    const un = 'eip-1193',
                      hn = 'caip-multichain',
                      pn = {
                        [Re.ENVIRONMENT.DEVELOPMENT]: H.EnvironmentType.Development,
                        [Re.ENVIRONMENT.RELEASE_CANDIDATE]: H.EnvironmentType.ReleaseCandidate,
                        [Re.ENVIRONMENT.PRODUCTION]: H.EnvironmentType.Production,
                      },
                      mn = {
                        flask: H.DistributionType.Flask,
                        main: H.DistributionType.Main,
                        beta: H.DistributionType.Beta,
                      };
                    var fn = new WeakSet();
                    class gn extends r.default {
                      constructor(e) {
                        var t;
                        super(),
                          cn(this, fn),
                          ln(
                            this,
                            '_trackSnapExportUsage',
                            (0, u.wrap)(
                              (0, u.memoize)(
                                () =>
                                  (0, u.throttle)((e, t, n, r) => {
                                    var s;
                                    return this.metaMetricsController.trackEvent({
                                      event: be.MetaMetricsEventName.SnapExportUsed,
                                      category: be.MetaMetricsEventCategory.Snaps,
                                      properties: {
                                        snap_id: e,
                                        export: t,
                                        snap_category:
                                          null === (s = this._getSnapMetadata(e)) || void 0 === s
                                            ? void 0
                                            : s.category,
                                        success: n,
                                        origin: r,
                                      },
                                    });
                                  }, 60 * fe.SECOND),
                                (e, t, n, r) => `${e}${t}${r}`
                              ),
                              (e, ...t) => e(...t)(...t)
                            )
                          ),
                          ln(
                            this,
                            'handleWatchAssetRequest',
                            ({ asset: e, type: t, origin: n, networkClientId: r }) => {
                              switch (t) {
                                case q.ERC20:
                                  return this.tokensController.watchAsset({
                                    asset: e,
                                    type: t,
                                    networkClientId: r,
                                  });
                                case q.ERC721:
                                case q.ERC1155:
                                  return this.nftController.watchNft(e, t, n);
                                default:
                                  throw new Error(`Asset type ${t} not supported`);
                              }
                            }
                          ),
                          ln(this, 'removePermissionsFor', e => {
                            try {
                              this.permissionController.revokePermissions(e);
                            } catch (e) {
                              if (!(e instanceof R.PermissionsRequestNotFoundError)) throw e;
                            }
                          }),
                          ln(this, 'updateCaveat', (e, t, n, r) => {
                            try {
                              this.controllerMessenger.call(
                                'PermissionController:updateCaveat',
                                e,
                                t,
                                n,
                                r
                              );
                            } catch (e) {
                              if (!(e instanceof R.PermissionsRequestNotFoundError)) throw e;
                            }
                          }),
                          ln(this, 'updateNetworksList', e => {
                            try {
                              this.networkOrderController.updateNetworksList(e);
                            } catch (e) {
                              throw (b.default.error(e.message), e);
                            }
                          }),
                          ln(this, 'updateAccountsList', e => {
                            try {
                              this.accountOrderController.updateAccountsList(e);
                            } catch (e) {
                              throw (b.default.error(e.message), e);
                            }
                          }),
                          ln(this, 'updateHiddenAccountsList', e => {
                            try {
                              this.accountOrderController.updateHiddenAccountsList(e);
                            } catch (e) {
                              throw (b.default.error(e.message), e);
                            }
                          }),
                          ln(this, 'rejectPermissionsRequest', e => {
                            try {
                              this.permissionController.rejectPermissionsRequest(e);
                            } catch (e) {
                              if (!(e instanceof R.PermissionsRequestNotFoundError)) throw e;
                            }
                          }),
                          ln(this, 'acceptPermissionsRequest', e => {
                            try {
                              this.permissionController.acceptPermissionsRequest(e);
                            } catch (e) {
                              if (!(e instanceof R.PermissionsRequestNotFoundError)) throw e;
                            }
                          }),
                          ln(this, 'resolvePendingApproval', async (e, t, n) => {
                            try {
                              await this.approvalController.accept(e, t, n);
                            } catch (e) {
                              if (!(e instanceof T.ApprovalRequestNotFoundError)) throw e;
                            }
                          }),
                          ln(this, 'rejectPendingApproval', (e, t) => {
                            try {
                              this.approvalController.reject(
                                e,
                                new f.JsonRpcError(t.code, t.message, t.data)
                              );
                            } catch (e) {
                              if (!(e instanceof T.ApprovalRequestNotFoundError)) throw e;
                            }
                          });
                        const { isFirstMetaMaskControllerSetup: n } = e;
                        (this.defaultMaxListeners = 20),
                          (this.sendUpdate = (0, u.debounce)(
                            this.privateSendUpdate.bind(this),
                            200 * fe.MILLISECOND
                          )),
                          (this.opts = e),
                          (this.extension = e.browser),
                          (this.platform = e.platform),
                          (this.notificationManager = e.notificationManager);
                        const r = e.initState || {},
                          s = '12.17.2-flask.0';
                        this.recordFirstTimeInfo(r),
                          (this.featureFlags = e.featureFlags),
                          (this.activeControllerConnections = 0),
                          (this.offscreenPromise = e.offscreenPromise ?? Promise.resolve()),
                          (this.getRequestAccountTabIds = e.getRequestAccountTabIds),
                          (this.getOpenMetamaskTabsIds = e.getOpenMetamaskTabsIds),
                          this.initializeChainlist(),
                          (this.controllerMessenger = new M.Messenger()),
                          (this.loggingController = new $.LoggingController({
                            messenger: this.controllerMessenger.getRestricted({
                              name: 'LoggingController',
                              allowedActions: [],
                              allowedEvents: [],
                            }),
                            state: r.LoggingController,
                          })),
                          (this.localStoreApiWrapper = e.persistanceManager),
                          (this.currentMigrationVersion = e.currentMigrationVersion),
                          (this.store = new We.default({
                            state: r,
                            controllerMessenger: this.controllerMessenger,
                            persist: !0,
                          })),
                          (this.connections = {}),
                          (this.createVaultMutex = new g.Mutex()),
                          this.extension.runtime.onInstalled.addListener(e => {
                            'update' === e.reason &&
                              this.loggingController.add({
                                type: $.LogType.GenericLog,
                                data: {
                                  event: ye.LOG_EVENT.VERSION_UPDATE,
                                  previousVersion: e.previousVersion,
                                  version: s,
                                },
                              });
                          }),
                          (this.appMetadataController = new wt.default({
                            state: r.AppMetadataController,
                            messenger: this.controllerMessenger.getRestricted({
                              name: 'AppMetadataController',
                              allowedActions: [],
                              allowedEvents: [],
                            }),
                            currentMigrationVersion: this.currentMigrationVersion,
                            currentAppVersion: s,
                          }));
                        const o = () => {
                          this.encryptionPublicKeyController.clearUnapproved(),
                            this.decryptMessageController.clearUnapproved(),
                            this.signatureController.clearUnapproved(),
                            this.approvalController.clear(f.providerErrors.userRejectedRequest());
                        };
                        (this.approvalController = new T.ApprovalController({
                          messenger: this.controllerMessenger.getRestricted({
                            name: 'ApprovalController',
                          }),
                          showApprovalRequest: e.showUserConfirmation,
                          typesExcludedFromRateLimiting: [
                            q.ApprovalType.PersonalSign,
                            q.ApprovalType.EthSignTypedData,
                            q.ApprovalType.Transaction,
                            q.ApprovalType.WatchAsset,
                            q.ApprovalType.EthGetEncryptionPublicKey,
                            q.ApprovalType.EthDecrypt,
                            ge.SMART_TRANSACTION_CONFIRMATION_TYPES.showSmartTransactionStatusPage,
                          ],
                        })),
                          (this.queuedRequestController = new W.QueuedRequestController({
                            messenger: this.controllerMessenger.getRestricted({
                              name: 'QueuedRequestController',
                              allowedActions: [
                                'NetworkController:getState',
                                'NetworkController:setActiveNetwork',
                                'SelectedNetworkController:getNetworkClientIdForDomain',
                              ],
                              allowedEvents: ['SelectedNetworkController:stateChange'],
                            }),
                            shouldRequestSwitchNetwork: ({ method: e }) =>
                              oe.methodsRequiringNetworkSwitch.includes(e),
                            canRequestSwitchNetworkWithoutApproval: ({ method: e }) =>
                              oe.methodsThatCanSwitchNetworkWithoutApproval.includes(e),
                            clearPendingConfirmations: o,
                            showApprovalRequest: () => {
                              this.approvalController.getTotalApprovalCount() > 0 &&
                                e.showUserConfirmation();
                            },
                          }));
                        const i = this.controllerMessenger.getRestricted({
                          name: 'NetworkController',
                        });
                        let c = r.NetworkController;
                        if (!c) {
                          c = (0, I.getDefaultNetworkControllerState)();
                          const e = c.networkConfigurationsByChainId;
                          let t;
                          (e[le.CHAIN_IDS.MAINNET].name = le.MAINNET_DISPLAY_NAME),
                            delete e[le.CHAIN_IDS.GOERLI],
                            delete e[le.CHAIN_IDS.LINEA_GOERLI],
                            (e[le.CHAIN_IDS.MEGAETH_TESTNET] = (0, u.cloneDeep)(
                              le.DEFAULT_CUSTOM_TESTNET_MAP[le.CHAIN_IDS.MEGAETH_TESTNET]
                            )),
                            Object.values(e).forEach(e => {
                              const t = e.rpcEndpoints[0].networkClientId;
                              (0, te.hasProperty)(q.BlockExplorerUrl, t) &&
                                (e.blockExplorerUrls = [q.BlockExplorerUrl[t]]),
                                (e.defaultBlockExplorerUrlIndex = 0);
                            }),
                            (t = e[le.CHAIN_IDS.MAINNET]),
                            (c.selectedNetworkClientId =
                              t.rpcEndpoints[t.defaultRpcEndpointIndex].networkClientId);
                        }
                        (this.networkController = new I.NetworkController({
                          messenger: i,
                          state: c,
                          infuraProjectId: e.infuraProjectId,
                        })),
                          this.networkController.initializeProvider(),
                          (this.multichainSubscriptionManager =
                            new se.MultichainSubscriptionManager({
                              getNetworkClientById:
                                this.networkController.getNetworkClientById.bind(
                                  this.networkController
                                ),
                              findNetworkClientIdByChainId:
                                this.networkController.findNetworkClientIdByChainId.bind(
                                  this.networkController
                                ),
                            })),
                          (this.multichainMiddlewareManager = new se.MultichainMiddlewareManager()),
                          (this.provider =
                            this.networkController.getProviderAndBlockTracker().provider),
                          (this.blockTracker =
                            this.networkController.getProviderAndBlockTracker().blockTracker),
                          (this.deprecatedNetworkVersions = {});
                        const l = this.controllerMessenger.getRestricted({
                          name: 'AccountsController',
                          allowedEvents: [
                            'SnapController:stateChange',
                            'KeyringController:accountRemoved',
                            'KeyringController:stateChange',
                            'SnapKeyring:accountAssetListUpdated',
                            'SnapKeyring:accountBalancesUpdated',
                            'SnapKeyring:accountTransactionsUpdated',
                            'MultichainNetworkController:networkDidChange',
                          ],
                          allowedActions: [
                            'KeyringController:getAccounts',
                            'KeyringController:getKeyringsByType',
                            'KeyringController:getKeyringForAccount',
                          ],
                        });
                        this.accountsController = new U.AccountsController({
                          messenger: l,
                          state: r.AccountsController,
                        });
                        const d = this.controllerMessenger.getRestricted({
                          name: 'PreferencesController',
                          allowedActions: [
                            'AccountsController:setSelectedAccount',
                            'AccountsController:getSelectedAccount',
                            'AccountsController:getAccountByAddress',
                            'AccountsController:setAccountName',
                            'NetworkController:getState',
                          ],
                          allowedEvents: ['AccountsController:stateChange'],
                        });
                        this.preferencesController = new at.PreferencesController({
                          state: {
                            currentLocale: e.initLangCode ?? '',
                            ...r.PreferencesController,
                          },
                          messenger: d,
                        });
                        const p = this.controllerMessenger.getRestricted({
                          name: 'TokenListController',
                          allowedActions: ['NetworkController:getNetworkClientById'],
                          allowedEvents: ['NetworkController:stateChange'],
                        });
                        this.tokenListController = new a.TokenListController({
                          chainId: dn(fn, this, vn).call(this, {
                            metamask: this.networkController.state,
                          }),
                          preventPollingOnNetworkRestart: !dn(fn, this, wn).call(
                            this,
                            this.preferencesController.state
                          ),
                          messenger: p,
                          state: r.TokenListController,
                        });
                        const m = this.controllerMessenger.getRestricted({
                          name: 'TokensController',
                          allowedActions: [
                            'ApprovalController:addRequest',
                            'NetworkController:getNetworkClientById',
                            'AccountsController:getSelectedAccount',
                            'AccountsController:getAccount',
                          ],
                          allowedEvents: [
                            'NetworkController:networkDidChange',
                            'AccountsController:selectedEvmAccountChange',
                            'PreferencesController:stateChange',
                            'TokenListController:stateChange',
                            'NetworkController:stateChange',
                          ],
                        });
                        this.tokensController = new a.TokensController({
                          state: r.TokensController,
                          provider: this.provider,
                          messenger: m,
                          chainId: dn(fn, this, vn).call(this),
                        });
                        const C = this.controllerMessenger.getRestricted({
                          name: 'MetaMetricsController',
                          allowedActions: [
                            'PreferencesController:getState',
                            'NetworkController:getState',
                            'NetworkController:getNetworkClientById',
                          ],
                          allowedEvents: [
                            'PreferencesController:stateChange',
                            'NetworkController:networkDidChange',
                          ],
                        });
                        (this.metaMetricsController = new ht.default({
                          state: r.MetaMetricsController,
                          messenger: C,
                          segment: pt.segment,
                          version: '12.17.2-flask.0',
                          environment: 'production',
                          extension: this.extension,
                          captureException: _.captureException,
                        })),
                          this.on('update', e => {
                            this.metaMetricsController.handleMetaMaskStateUpdate(e);
                          });
                        const S = new kt.DataDeletionService(),
                          F = this.controllerMessenger.getRestricted({
                            name: 'MetaMetricsDataDeletionController',
                            allowedActions: ['MetaMetricsController:getState'],
                            allowedEvents: [],
                          });
                        this.metaMetricsDataDeletionController =
                          new Ct.MetaMetricsDataDeletionController({
                            dataDeletionService: S,
                            messenger: F,
                            state: r.metaMetricsDataDeletionController,
                          });
                        const K = this.controllerMessenger.getRestricted({
                            name: 'GasFeeController',
                            allowedActions: [
                              'NetworkController:getEIP1559Compatibility',
                              'NetworkController:getNetworkClientById',
                              'NetworkController:getState',
                            ],
                            allowedEvents: ['NetworkController:stateChange'],
                          }),
                          Q = ce.GAS_API_BASE_URL;
                        (this.gasFeeController = new x.GasFeeController({
                          state: r.GasFeeController,
                          interval: 1e4,
                          messenger: K,
                          clientId: ce.SWAPS_CLIENT_ID,
                          getProvider: () =>
                            this.networkController.getProviderAndBlockTracker().provider,
                          onNetworkDidChange: e => {
                            i.subscribe('NetworkController:networkDidChange', () =>
                              e(this.networkController.state)
                            );
                          },
                          getCurrentNetworkEIP1559Compatibility:
                            this.networkController.getEIP1559Compatibility.bind(
                              this.networkController
                            ),
                          getCurrentAccountEIP1559Compatibility:
                            this.getCurrentAccountEIP1559Compatibility.bind(this),
                          legacyAPIEndpoint: `${Q}/networks/<chain_id>/gasPrices`,
                          EIP1559APIEndpoint: `${Q}/networks/<chain_id>/suggestedGasFees`,
                          getCurrentNetworkLegacyGasAPICompatibility: () =>
                            dn(fn, this, vn).call(this) === le.CHAIN_IDS.BSC,
                          getChainId: () => dn(fn, this, vn).call(this),
                        })),
                          (this.appStateController = new ot.AppStateController({
                            addUnlockListener: this.on.bind(this, 'unlock'),
                            isUnlocked: this.isUnlocked.bind(this),
                            state: r.AppStateController,
                            onInactiveTimeout: () => this.setLocked(),
                            messenger: this.controllerMessenger.getRestricted({
                              name: 'AppStateController',
                              allowedActions: [
                                `${this.approvalController.name}:addRequest`,
                                `${this.approvalController.name}:acceptRequest`,
                                'PreferencesController:getState',
                              ],
                              allowedEvents: [
                                'KeyringController:qrKeyringStateChange',
                                'PreferencesController:stateChange',
                              ],
                            }),
                            extension: this.extension,
                          }));
                        const Y = this.controllerMessenger.getRestricted({
                          name: 'CurrencyRateController',
                          allowedActions: [`${this.networkController.name}:getNetworkClientById`],
                        });
                        this.currencyRateController = new a.CurrencyRateController({
                          includeUsdRate: !0,
                          messenger: Y,
                          state: r.CurrencyController,
                        });
                        const X = this.currencyRateController.fetchMultiExchangeRate.bind(
                          this.currencyRateController
                        );
                        this.currencyRateController.fetchMultiExchangeRate = (...e) =>
                          this.preferencesController.state.useCurrencyRateCheck
                            ? X(...e)
                            : { conversionRate: null, usdConversionRate: null };
                        const ee = this.controllerMessenger.getRestricted({
                          name: 'TokenBalancesController',
                          allowedActions: [
                            'NetworkController:getState',
                            'NetworkController:getNetworkClientById',
                            'TokensController:getState',
                            'PreferencesController:getState',
                            'AccountsController:getSelectedAccount',
                          ],
                          allowedEvents: [
                            'PreferencesController:stateChange',
                            'TokensController:stateChange',
                            'NetworkController:stateChange',
                          ],
                        });
                        this.tokenBalancesController = new a.TokenBalancesController({
                          messenger: ee,
                          state: r.TokenBalancesController,
                          interval: 3e4,
                        });
                        const ne = this.controllerMessenger.getRestricted({
                          name: 'PhishingController',
                        });
                        this.phishingController = new A.PhishingController({
                          messenger: ne,
                          state: r.PhishingController,
                          hotlistRefreshInterval: undefined,
                          stalelistRefreshInterval: undefined,
                        });
                        const re = this.controllerMessenger.getRestricted({
                          name: 'AnnouncementController',
                        });
                        this.announcementController = new N.AnnouncementController({
                          messenger: re,
                          allAnnouncements: me.UI_NOTIFICATIONS,
                          state: r.AnnouncementController,
                        });
                        const ae = this.controllerMessenger.getRestricted({
                          name: 'NetworkOrderController',
                          allowedEvents: ['NetworkController:stateChange'],
                        });
                        this.networkOrderController = new tt.NetworkOrderController({
                          messenger: ae,
                          state: r.NetworkOrderController,
                        });
                        const ie = this.controllerMessenger.getRestricted({
                          name: 'AccountOrderController',
                        });
                        this.accountOrderController = new nt.AccountOrderController({
                          messenger: ie,
                          state: r.AccountOrderController,
                        });
                        const ue = this.controllerMessenger.getRestricted({
                          name: 'RatesController',
                        });
                        (this.multichainRatesController = new a.RatesController({
                          state: r.MultichainRatesController,
                          messenger: ue,
                          includeUsdRate: !0,
                          fetchMultiExchangeRate: a.fetchMultiExchangeRate,
                        })),
                          this.controllerMessenger.subscribe(
                            'PreferencesController:stateChange',
                            (0, ft.previousValueComparator)((e, t) => {
                              const { useCurrencyRateCheck: n } = e,
                                { useCurrencyRateCheck: r } = t;
                              r && !n
                                ? this.tokenRatesController.enable()
                                : !r && n && this.tokenRatesController.disable();
                            }, this.preferencesController.state)
                          ),
                          (this.ensController = new P.EnsController({
                            messenger: this.controllerMessenger.getRestricted({
                              name: 'EnsController',
                              allowedActions: [
                                'NetworkController:getNetworkClientById',
                                'NetworkController:getState',
                              ],
                              allowedEvents: [],
                            }),
                            onNetworkDidChange: i.subscribe.bind(
                              i,
                              'NetworkController:networkDidChange'
                            ),
                          }));
                        const he = this.controllerMessenger.getRestricted({
                          name: 'OnboardingController',
                          allowedActions: [],
                          allowedEvents: [],
                        });
                        this.onboardingController = new ct.default({
                          messenger: he,
                          state: r.OnboardingController,
                        });
                        let we = [(0, h.keyringBuilderFactory)(k.MetaMaskKeyring)];
                        const ve =
                          null === (t = this.opts.overrides) || void 0 === t ? void 0 : t.keyrings;
                        if (!1 === Ee.isManifestV3) {
                          const e = [
                              (null == ve ? void 0 : ve.lattice) || v.default,
                              k.MetaMaskKeyring,
                            ],
                            t = [
                              {
                                keyring: (null == ve ? void 0 : ve.trezor) || y.TrezorKeyring,
                                bridge:
                                  (null == ve ? void 0 : ve.trezorBridge) || y.TrezorConnectBridge,
                              },
                              {
                                keyring: (null == ve ? void 0 : ve.oneKey) || y.OneKeyKeyring,
                                bridge:
                                  (null == ve ? void 0 : ve.oneKeyBridge) || y.TrezorConnectBridge,
                              },
                              {
                                keyring: (null == ve ? void 0 : ve.ledger) || w.LedgerKeyring,
                                bridge:
                                  (null == ve ? void 0 : ve.ledgerBridge) || w.LedgerIframeBridge,
                              },
                            ];
                          (we = e.map(e => (0, h.keyringBuilderFactory)(e))),
                            t.forEach(e =>
                              we.push((0, bt.hardwareKeyringBuilderFactory)(e.keyring, e.bridge))
                            );
                        } else
                          we.push(
                            (0, bt.hardwareKeyringBuilderFactory)(
                              y.TrezorKeyring,
                              (null == ve ? void 0 : ve.trezorBridge) || Et.TrezorOffscreenBridge
                            ),
                            (0, bt.hardwareKeyringBuilderFactory)(
                              y.OneKeyKeyring,
                              (null == ve ? void 0 : ve.oneKey) || Et.TrezorOffscreenBridge
                            ),
                            (0, bt.hardwareKeyringBuilderFactory)(
                              w.LedgerKeyring,
                              (null == ve ? void 0 : ve.ledgerBridge) || Tt.LedgerOffscreenBridge
                            ),
                            (0, h.keyringBuilderFactory)(It.LatticeKeyringOffscreen)
                          );
                        const Ce = this.controllerMessenger.getRestricted({
                            name: 'SnapKeyring',
                            allowedActions: [
                              'ApprovalController:addRequest',
                              'ApprovalController:acceptRequest',
                              'ApprovalController:rejectRequest',
                              'ApprovalController:startFlow',
                              'ApprovalController:endFlow',
                              'ApprovalController:showSuccess',
                              'ApprovalController:showError',
                              'PhishingController:test',
                              'PhishingController:maybeUpdateState',
                              'KeyringController:getAccounts',
                              'AccountsController:setSelectedAccount',
                              'AccountsController:getAccountByAddress',
                              'AccountsController:setAccountName',
                              'AccountsController:listMultichainAccounts',
                              'SnapController:handleRequest',
                              'SnapController:get',
                              'PreferencesController:getState',
                            ],
                          }),
                          ke = async () => {
                            await this.keyringController.persistAllKeyrings(),
                              await this.accountsController.updateAccounts();
                          };
                        we.push(
                          (0, Mt.snapKeyringBuilder)(Ce, {
                            persistKeyringHelper: () => ke(),
                            removeAccountHelper: e => this.removeAccount(e),
                            trackEvent: (...e) => this.metaMetricsController.trackEvent(...e),
                          })
                        );
                        const Se = this.controllerMessenger.getRestricted({
                          name: 'KeyringController',
                        });
                        (this.keyringController = new h.KeyringController({
                          cacheEncryptionKey: !0,
                          keyringBuilders: we,
                          state: r.KeyringController,
                          encryptor: e.encryptor || (0, Pt.encryptorFactory)(6e5),
                          messenger: Se,
                        })),
                          this.controllerMessenger.subscribe('KeyringController:unlock', () =>
                            this._onUnlock()
                          ),
                          this.controllerMessenger.subscribe('KeyringController:lock', () =>
                            this._onLock()
                          ),
                          this.controllerMessenger.subscribe('KeyringController:stateChange', e => {
                            this._onKeyringControllerUpdate(e);
                          }),
                          (this.permissionController = new R.PermissionController({
                            messenger: this.controllerMessenger.getRestricted({
                              name: 'PermissionController',
                              allowedActions: [
                                `${this.approvalController.name}:addRequest`,
                                `${this.approvalController.name}:hasRequest`,
                                `${this.approvalController.name}:acceptRequest`,
                                `${this.approvalController.name}:rejectRequest`,
                                'SnapController:getPermitted',
                                'SnapController:install',
                                'SubjectMetadataController:getSubjectMetadata',
                              ],
                            }),
                            state: r.PermissionController,
                            caveatSpecifications: (0, vt.getCaveatSpecifications)({
                              listAccounts: this.accountsController.listAccounts.bind(
                                this.accountsController
                              ),
                              findNetworkClientIdByChainId:
                                this.networkController.findNetworkClientIdByChainId.bind(
                                  this.networkController
                                ),
                              isNonEvmScopeSupported: this.controllerMessenger.call.bind(
                                this.controllerMessenger,
                                'MultichainRouter:isSupportedScope'
                              ),
                              getNonEvmAccountAddresses: this.controllerMessenger.call.bind(
                                this.controllerMessenger,
                                'MultichainRouter:getSupportedAccounts'
                              ),
                            }),
                            permissionSpecifications: {
                              ...(0, vt.getPermissionSpecifications)(),
                              ...this.getSnapPermissionSpecifications(),
                            },
                            unrestrictedMethods: vt.unrestrictedMethods,
                          })),
                          (this.selectedNetworkController = new B.SelectedNetworkController({
                            messenger: this.controllerMessenger.getRestricted({
                              name: 'SelectedNetworkController',
                              allowedActions: [
                                'NetworkController:getNetworkClientById',
                                'NetworkController:getState',
                                'NetworkController:getSelectedNetworkClient',
                                'PermissionController:hasPermissions',
                                'PermissionController:getSubjectNames',
                              ],
                              allowedEvents: [
                                'NetworkController:stateChange',
                                'PermissionController:stateChange',
                              ],
                            }),
                            state: r.SelectedNetworkController,
                            useRequestQueuePreference: !0,
                            onPreferencesStateChange: () => {},
                            domainProxyMap: new xt.WeakRefObjectMap(),
                          })),
                          (this.permissionLogController = new D.PermissionLogController({
                            messenger: this.controllerMessenger.getRestricted({
                              name: 'PermissionLogController',
                            }),
                            restrictedMethods: new Set(Object.keys(pe.RestrictedMethods)),
                            state: r.PermissionLogController,
                          })),
                          (this.subjectMetadataController = new R.SubjectMetadataController({
                            messenger: this.controllerMessenger.getRestricted({
                              name: 'SubjectMetadataController',
                              allowedActions: [`${this.permissionController.name}:hasPermissions`],
                            }),
                            state: r.SubjectMetadataController,
                            subjectCacheLimit: 100,
                          }));
                        const _e = this.controllerMessenger.getRestricted({
                          name: 'MultichainRouter',
                          allowedActions: [
                            'SnapController:getAll',
                            'SnapController:handleRequest',
                            `${this.permissionController.name}:getPermissions`,
                            'AccountsController:listMultichainAccounts',
                          ],
                          allowedEvents: [],
                        });
                        (this.multichainRouter = new L.MultichainRouter({
                          messenger: _e,
                          withSnapKeyring: async e => e({ keyring: await this.getSnapKeyring() }),
                        })),
                          (this.accountTrackerController = new ze.default({
                            state: { accounts: {} },
                            messenger: this.controllerMessenger.getRestricted({
                              name: 'AccountTrackerController',
                              allowedActions: [
                                'AccountsController:getSelectedAccount',
                                'NetworkController:getState',
                                'NetworkController:getNetworkClientById',
                                'OnboardingController:getState',
                                'PreferencesController:getState',
                              ],
                              allowedEvents: [
                                'AccountsController:selectedEvmAccountChange',
                                'OnboardingController:stateChange',
                                'KeyringController:accountRemoved',
                              ],
                            }),
                            provider: this.provider,
                            blockTracker: this.blockTracker,
                            getNetworkIdentifier: e => {
                              const { type: t, rpcUrl: n } =
                                e ??
                                (0, Ie.getProviderConfig)({
                                  metamask: this.networkController.state,
                                });
                              return t === le.NETWORK_TYPES.RPC ? n : t;
                            },
                          })),
                          this.on('controllerConnectionChanged', e => {
                            const { completedOnboarding: t } = this.onboardingController.state;
                            e > 0 && t ? this.triggerNetworkrequests() : this.stopNetworkRequests();
                          }),
                          this.controllerMessenger.subscribe(
                            `${this.onboardingController.name}:stateChange`,
                            (0, ft.previousValueComparator)(async (e, t) => {
                              const { completedOnboarding: n } = e,
                                { completedOnboarding: r } = t;
                              if (!n && r) {
                                const { address: e } = this.accountsController.getSelectedAccount();
                                await this._addSolanaAccount(),
                                  await this._addAccountsWithBalance(),
                                  this.postOnboardingInitialization(),
                                  this.triggerNetworkrequests(),
                                  await this.tokenDetectionController.detectTokens({
                                    selectedAddress: e,
                                  });
                              }
                            }, this.onboardingController.state)
                          );
                        const Te = this.controllerMessenger.getRestricted({
                          name: 'TokenDetectionController',
                          allowedActions: [
                            'AccountsController:getAccount',
                            'AccountsController:getSelectedAccount',
                            'KeyringController:getState',
                            'NetworkController:getNetworkClientById',
                            'NetworkController:getNetworkConfigurationByNetworkClientId',
                            'NetworkController:getState',
                            'PreferencesController:getState',
                            'TokenListController:getState',
                            'TokensController:getState',
                            'TokensController:addDetectedTokens',
                          ],
                          allowedEvents: [
                            'AccountsController:selectedEvmAccountChange',
                            'KeyringController:lock',
                            'KeyringController:unlock',
                            'NetworkController:networkDidChange',
                            'PreferencesController:stateChange',
                            'TokenListController:stateChange',
                          ],
                        });
                        this.tokenDetectionController = new a.TokenDetectionController({
                          messenger: Te,
                          getBalancesInSingleCall: (...e) =>
                            this.assetsContractController.getBalancesInSingleCall(...e),
                          trackMetaMetricsEvent: this.metaMetricsController.trackEvent.bind(
                            this.metaMetricsController
                          ),
                          useAccountsAPI: !0,
                          platform: 'extension',
                        });
                        const Pe = this.controllerMessenger.getRestricted({
                          name: 'AddressBookController',
                          allowedActions: [],
                          allowedEvents: [],
                        });
                        (this.addressBookController = new E.AddressBookController({
                          messenger: Pe,
                          state: r.AddressBookController,
                        })),
                          (this.alertController = new it.AlertController({
                            state: r.AlertController,
                            messenger: this.controllerMessenger.getRestricted({
                              name: 'AlertController',
                              allowedEvents: ['AccountsController:selectedAccountChange'],
                              allowedActions: ['AccountsController:getSelectedAccount'],
                            }),
                          })),
                          (this.backup = new lt.default({
                            preferencesController: this.preferencesController,
                            addressBookController: this.addressBookController,
                            accountsController: this.accountsController,
                            networkController: this.networkController,
                            trackMetaMetricsEvent: this.metaMetricsController.trackEvent.bind(
                              this.metaMetricsController
                            ),
                          })),
                          (this.snapAndHardwareMetricsParams = {
                            getSelectedAccount: this.accountsController.getSelectedAccount.bind(
                              this.accountsController
                            ),
                            getAccountType: this.getAccountType.bind(this),
                            getDeviceModel: this.getDeviceModel.bind(this),
                            getHardwareTypeForMetric: this.getHardwareTypeForMetric.bind(this),
                            snapAndHardwareMessenger: this.controllerMessenger.getRestricted({
                              name: 'SnapAndHardwareMessenger',
                              allowedActions: [
                                'KeyringController:getKeyringForAccount',
                                'SnapController:get',
                                'AccountsController:getSelectedAccount',
                              ],
                            }),
                          }),
                          this._addBridgeStatusControllerListeners(),
                          (this.decryptMessageController = new dt.default({
                            getState: this.getState.bind(this),
                            messenger: this.controllerMessenger.getRestricted({
                              name: 'DecryptMessageController',
                              allowedActions: [
                                `${this.approvalController.name}:addRequest`,
                                `${this.approvalController.name}:acceptRequest`,
                                `${this.approvalController.name}:rejectRequest`,
                                `${this.keyringController.name}:decryptMessage`,
                              ],
                              allowedEvents: [
                                'DecryptMessageManager:stateChange',
                                'DecryptMessageManager:unapprovedMessage',
                              ],
                            }),
                            managerMessenger: this.controllerMessenger.getRestricted({
                              name: 'DecryptMessageManager',
                            }),
                            metricsEvent: this.metaMetricsController.trackEvent.bind(
                              this.metaMetricsController
                            ),
                          })),
                          (this.encryptionPublicKeyController = new yt.default({
                            messenger: this.controllerMessenger.getRestricted({
                              name: 'EncryptionPublicKeyController',
                              allowedActions: [
                                `${this.approvalController.name}:addRequest`,
                                `${this.approvalController.name}:acceptRequest`,
                                `${this.approvalController.name}:rejectRequest`,
                              ],
                              allowedEvents: [
                                'EncryptionPublicKeyManager:stateChange',
                                'EncryptionPublicKeyManager:unapprovedMessage',
                              ],
                            }),
                            managerMessenger: this.controllerMessenger.getRestricted({
                              name: 'EncryptionPublicKeyManager',
                            }),
                            getEncryptionPublicKey:
                              this.keyringController.getEncryptionPublicKey.bind(
                                this.keyringController
                              ),
                            getAccountKeyringType:
                              this.keyringController.getAccountKeyringType.bind(
                                this.keyringController
                              ),
                            getState: this.getState.bind(this),
                            metricsEvent: this.metaMetricsController.trackEvent.bind(
                              this.metaMetricsController
                            ),
                          })),
                          (this.signatureController = new V.SignatureController({
                            messenger: this.controllerMessenger.getRestricted({
                              name: 'SignatureController',
                              allowedActions: [
                                `${this.accountsController.name}:getState`,
                                `${this.approvalController.name}:addRequest`,
                                `${this.keyringController.name}:signMessage`,
                                `${this.keyringController.name}:signPersonalMessage`,
                                `${this.keyringController.name}:signTypedMessage`,
                                `${this.loggingController.name}:add`,
                                `${this.networkController.name}:getNetworkClientById`,
                              ],
                            }),
                            trace: xe.trace,
                            decodingApiUrl: 'https://signature-insights.api.cx.metamask.io/v1',
                            isDecodeSignatureRequestEnabled: () =>
                              this.preferencesController.state.useTransactionSimulations,
                          })),
                          this.signatureController.hub.on(
                            'cancelWithReason',
                            ({ metadata: e, reason: t }) => {
                              this.metaMetricsController.trackEvent({
                                event: t,
                                category: be.MetaMetricsEventCategory.Transactions,
                                properties: { action: 'Sign Request', type: e.type },
                              });
                            }
                          );
                        const Ae = this.controllerMessenger.getRestricted({
                          name: 'SwapsController',
                          allowedActions: [
                            'NetworkController:getState',
                            'NetworkController:getNetworkClientById',
                            'TokenRatesController:getState',
                          ],
                          allowedEvents: [],
                        });
                        this.swapsController = new ut.default(
                          {
                            messenger: Ae,
                            getBufferedGasLimit: async (e, t) => {
                              const { gas: n, simulationFails: r } =
                                await this.txController.estimateGasBuffered(
                                  e.txParams,
                                  t,
                                  dn(fn, this, kn).call(this)
                                );
                              return { gasLimit: n, simulationFails: r };
                            },
                            getEIP1559GasFeeEstimates:
                              this.gasFeeController.fetchGasFeeEstimates.bind(
                                this.gasFeeController
                              ),
                            getLayer1GasFee: (...e) => this.txController.getLayer1GasFee(...e),
                            trackMetaMetricsEvent: this.metaMetricsController.trackEvent.bind(
                              this.metaMetricsController
                            ),
                          },
                          r.SwapsController
                        );
                        const Ne = this.controllerMessenger.getRestricted({
                          name: Z.BRIDGE_CONTROLLER_NAME,
                          allowedActions: [
                            'AccountsController:getSelectedMultichainAccount',
                            'SnapController:handleRequest',
                            'NetworkController:getState',
                            'NetworkController:getNetworkClientById',
                            'NetworkController:findNetworkClientIdByChainId',
                          ],
                          allowedEvents: [],
                        });
                        this.bridgeController = new Z.BridgeController({
                          messenger: Ne,
                          clientId: Z.BridgeClientId.EXTENSION,
                          getLayer1GasFee: (...e) => this.txController.getLayer1GasFee(...e),
                          fetchFn: async (e, { headers: t, signal: n, ...r }) =>
                            await (0, Oe.default)({
                              url: e,
                              fetchOptions: { method: 'GET', headers: t, signal: n },
                              ...r,
                            }),
                          config: { customBridgeApiBaseUrl: Be.BRIDGE_API_BASE_URL },
                        });
                        const Re = this.controllerMessenger.getRestricted({
                          name: Kt.BRIDGE_STATUS_CONTROLLER_NAME,
                          allowedActions: [
                            'AccountsController:getSelectedMultichainAccount',
                            'NetworkController:getNetworkClientById',
                            'NetworkController:findNetworkClientIdByChainId',
                            'NetworkController:getState',
                            'TransactionController:getState',
                          ],
                          allowedEvents: [],
                        });
                        this.bridgeStatusController = new Vt.default({
                          messenger: Re,
                          state: r.BridgeStatusController,
                        });
                        const je = this.controllerMessenger.getRestricted({
                          name: 'SmartTransactionsController',
                          allowedActions: [
                            'NetworkController:getNetworkClientById',
                            'NetworkController:getState',
                          ],
                          allowedEvents: ['NetworkController:stateChange'],
                        });
                        this.smartTransactionsController = new O.default({
                          supportedChainIds: (0, de.getAllowedSmartTransactionsChainIds)(),
                          clientId: j.ClientId.Extension,
                          getNonceLock: e =>
                            this.txController.getNonceLock(e, dn(fn, this, kn).call(this)),
                          confirmExternalTransaction: (...e) =>
                            this.txController.confirmExternalTransaction(...e),
                          trackMetaMetricsEvent: this.metaMetricsController.trackEvent.bind(
                            this.metaMetricsController
                          ),
                          state: r.SmartTransactionsController,
                          messenger: je,
                          getTransactions: (...e) => this.txController.getTransactions(...e),
                          updateTransaction: (...e) => this.txController.updateTransaction(...e),
                          getFeatureFlags: () => {
                            const e = this._getMetaMaskState();
                            return (0, Me.getFeatureFlagsByChainId)(e);
                          },
                          getMetaMetricsProps: async () => {
                            const e = this.accountsController.getSelectedAccount().address;
                            return {
                              accountHardwareType: await this.getHardwareTypeForMetric(e),
                              accountType: await this.getAccountType(e),
                              deviceModel: await this.getDeviceModel(e),
                            };
                          },
                        });
                        const $e = () => this.preferencesController.state.useExternalNameSources;
                        this.nameController = new G.NameController({
                          messenger: this.controllerMessenger.getRestricted({
                            name: 'NameController',
                            allowedActions: [],
                          }),
                          providers: [
                            new G.ENSNameProvider({
                              reverseLookup: this.ensController.reverseResolveAddress.bind(
                                this.ensController
                              ),
                            }),
                            new G.EtherscanNameProvider({ isEnabled: $e }),
                            new G.TokenNameProvider({ isEnabled: $e }),
                            new G.LensNameProvider({ isEnabled: $e }),
                            new Ue.SnapsNameProvider({
                              messenger: this.controllerMessenger.getRestricted({
                                name: 'SnapsNameProvider',
                                allowedActions: [
                                  'SnapController:getAll',
                                  'SnapController:get',
                                  'SnapController:handleRequest',
                                  'PermissionController:getState',
                                ],
                              }),
                            }),
                          ],
                          state: r.NameController,
                        });
                        const De = this.controllerMessenger.getRestricted({
                          name: 'PetnamesBridge',
                          allowedEvents: [
                            'NameController:stateChange',
                            'AccountsController:stateChange',
                            'AddressBookController:stateChange',
                          ],
                          allowedActions: ['AccountsController:listAccounts'],
                        });
                        new He.AddressBookPetnamesBridge({
                          addressBookController: this.addressBookController,
                          nameController: this.nameController,
                          messenger: De,
                        }).init(),
                          new Ve.AccountIdentitiesPetnamesBridge({
                            nameController: this.nameController,
                            messenger: De,
                          }).init(),
                          (this.userOperationController = new z.UserOperationController({
                            entrypoint: '0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789',
                            getGasFeeEstimates: this.gasFeeController.fetchGasFeeEstimates.bind(
                              this.gasFeeController
                            ),
                            messenger: this.controllerMessenger.getRestricted({
                              name: 'UserOperationController',
                              allowedActions: [
                                'ApprovalController:addRequest',
                                'NetworkController:getNetworkClientById',
                                'KeyringController:prepareUserOperation',
                                'KeyringController:patchUserOperation',
                                'KeyringController:signUserOperation',
                              ],
                            }),
                            state: r.UserOperationController,
                          })),
                          this.userOperationController.hub.on(
                            'user-operation-added',
                            this._onUserOperationAdded.bind(this)
                          ),
                          this.userOperationController.hub.on(
                            'transaction-updated',
                            this._onUserOperationTransactionUpdated.bind(this)
                          ),
                          i.subscribe('NetworkController:networkDidChange', () => {
                            this.accountTrackerController.updateAccounts();
                          }),
                          i.subscribe('NetworkController:networkWillChange', o.bind(this)),
                          this.controllerMessenger.subscribe(
                            'PreferencesController:stateChange',
                            (0, ft.previousValueComparator)((e, t) => {
                              const { useExternalServices: n } = e,
                                { useExternalServices: r } = t;
                              r && !n
                                ? (this.remoteFeatureFlagController.enable(),
                                  this.remoteFeatureFlagController.updateRemoteFeatureFlags())
                                : !r && n && this.remoteFeatureFlagController.disable();
                            }, this.preferencesController.state)
                          ),
                          (this.remoteFeatureFlagController = new H.RemoteFeatureFlagController({
                            messenger: this.controllerMessenger.getRestricted({
                              name: 'RemoteFeatureFlagController',
                              allowedActions: [],
                              allowedEvents: [],
                            }),
                            fetchInterval: 9e5,
                            disabled: !this.preferencesController.state.useExternalServices,
                            getMetaMetricsId: () => this.metaMetricsController.getMetaMetricsId(),
                            clientConfigApiService: new H.ClientConfigApiService({
                              fetch: globalThis.fetch.bind(globalThis),
                              config: {
                                client: H.ClientType.Extension,
                                distribution:
                                  this._getConfigForRemoteFeatureFlagRequest().distribution,
                                environment:
                                  this._getConfigForRemoteFeatureFlagRequest().environment,
                              },
                            }),
                          }));
                        const Le = [
                            this.networkController,
                            this.preferencesController,
                            this.gasFeeController,
                            this.onboardingController,
                            this.keyringController,
                            this.smartTransactionsController,
                          ],
                          Fe = {
                            ExecutionService: en.ExecutionServiceInit,
                            InstitutionalSnapController: zt.InstitutionalSnapControllerInit,
                            RateLimitController: en.RateLimitControllerInit,
                            SnapsRegistry: en.SnapsRegistryInit,
                            SnapController: en.SnapControllerInit,
                            SnapInsightsController: en.SnapInsightsControllerInit,
                            SnapInterfaceController: en.SnapInterfaceControllerInit,
                            CronjobController: en.CronjobControllerInit,
                            PPOMController: Yt.PPOMControllerInit,
                            TransactionController: Qt.TransactionControllerInit,
                            NftController: Jt.NftControllerInit,
                            AssetsContractController: Jt.AssetsContractControllerInit,
                            NftDetectionController: Jt.NftDetectionControllerInit,
                            TokenRatesController: Jt.TokenRatesControllerInit,
                            MultichainAssetsController: Zt.MultichainAssetsControllerInit,
                            MultichainAssetsRatesController: Zt.MultichainAssetsRatesControllerInit,
                            MultichainBalancesController: Zt.MultichainBalancesControllerInit,
                            MultichainTransactionsController:
                              Zt.MultichainTransactionsControllerInit,
                            MultichainNetworkController: Zt.MultichainNetworkControllerInit,
                            AuthenticationController: tn.AuthenticationControllerInit,
                            UserStorageController: nn.UserStorageControllerInit,
                            NotificationServicesController: sn.NotificationServicesControllerInit,
                            NotificationServicesPushController:
                              an.NotificationServicesPushControllerInit,
                          },
                          {
                            controllerApi: qe,
                            controllerMemState: Ke,
                            controllerPersistedState: Ze,
                            controllersByName: Je,
                          } = dn(fn, this, Sn).call(this, {
                            existingControllers: Le,
                            initFunctions: Fe,
                            initState: r,
                          });
                        (this.controllerApi = qe),
                          (this.controllerMemState = Ke),
                          (this.controllerPersistedState = Ze),
                          (this.controllersByName = Je),
                          (this.cronjobController = Je.CronjobController),
                          (this.rateLimitController = Je.RateLimitController),
                          (this.snapController = Je.SnapController),
                          (this.snapInsightsController = Je.SnapInsightsController),
                          (this.snapInterfaceController = Je.SnapInterfaceController),
                          (this.snapsRegistry = Je.SnapsRegistry),
                          (this.ppomController = Je.PPOMController),
                          (this.txController = Je.TransactionController),
                          (this.nftController = Je.NftController),
                          (this.nftDetectionController = Je.NftDetectionController),
                          (this.assetsContractController = Je.AssetsContractController),
                          (this.multichainAssetsController = Je.MultichainAssetsController),
                          (this.multichainBalancesController = Je.MultichainBalancesController),
                          (this.multichainTransactionsController =
                            Je.MultichainTransactionsController),
                          (this.multichainAssetsRatesController =
                            Je.MultichainAssetsRatesController),
                          (this.tokenRatesController = Je.TokenRatesController),
                          (this.multichainNetworkController = Je.MultichainNetworkController),
                          (this.authenticationController = Je.AuthenticationController),
                          (this.userStorageController = Je.UserStorageController),
                          (this.notificationServicesController = Je.NotificationServicesController),
                          (this.notificationServicesPushController =
                            Je.NotificationServicesPushController),
                          this.notificationServicesController.init(),
                          this.controllerMessenger.subscribe(
                            'TransactionController:transactionStatusUpdated',
                            ({ transactionMeta: e }) => {
                              this._onFinishedTransaction(e);
                            }
                          ),
                          this.controllerMessenger.subscribe(
                            'NotificationServicesPushController:onNewNotifications',
                            e => {
                              this.metaMetricsController.trackEvent({
                                category: be.MetaMetricsEventCategory.PushNotifications,
                                event: be.MetaMetricsEventName.PushNotificationReceived,
                                properties: {
                                  notification_id: e.id,
                                  notification_type: e.type,
                                  chain_id: null == e ? void 0 : e.chain_id,
                                },
                              });
                            }
                          ),
                          this.controllerMessenger.subscribe(
                            'NotificationServicesPushController:pushNotificationClicked',
                            e => {
                              this.metaMetricsController.trackEvent({
                                category: be.MetaMetricsEventCategory.PushNotifications,
                                event: be.MetaMetricsEventName.PushNotificationClicked,
                                properties: {
                                  notification_id: e.id,
                                  notification_type: e.type,
                                  chain_id: null == e ? void 0 : e.chain_id,
                                },
                              });
                            }
                          ),
                          (this.metamaskMiddleware = (0, gt.default)({
                            static: { eth_syncing: !1, web3_clientVersion: `MetaMask/v${s}` },
                            version: s,
                            getAccounts: ({ origin: e }) => {
                              if (e === ge.ORIGIN_METAMASK) {
                                const e = this.accountsController.getSelectedAccount().address;
                                return e ? [e] : [];
                              }
                              return this.isUnlocked() ? this.getPermittedAccounts(e) : [];
                            },
                            processTransaction: (e, t) =>
                              (0, At.addDappTransaction)(
                                this.getAddTransactionRequest({
                                  transactionParams: e,
                                  dappRequest: t,
                                })
                              ),
                            processTypedMessage: (...e) =>
                              (0, Nt.addTypedMessage)({
                                signatureController: this.signatureController,
                                signatureParams: e,
                              }),
                            processTypedMessageV3: (...e) =>
                              (0, Nt.addTypedMessage)({
                                signatureController: this.signatureController,
                                signatureParams: e,
                              }),
                            processTypedMessageV4: (...e) =>
                              (0, Nt.addTypedMessage)({
                                signatureController: this.signatureController,
                                signatureParams: e,
                              }),
                            processPersonalMessage: (...e) =>
                              (0, Nt.addPersonalMessage)({
                                signatureController: this.signatureController,
                                signatureParams: e,
                              }),
                            processEncryptionPublicKey:
                              this.encryptionPublicKeyController.newRequestEncryptionPublicKey.bind(
                                this.encryptionPublicKeyController
                              ),
                            processDecryptMessage:
                              this.decryptMessageController.newRequestDecryptMessage.bind(
                                this.decryptMessageController
                              ),
                            getPendingNonce: this.getPendingNonce.bind(this),
                            getPendingTransactionByHash: e =>
                              this.txController.state.transactions.find(
                                t => t.hash === e && t.status === J.TransactionStatus.submitted
                              ),
                            processSendCalls: rn.processSendCalls.bind(
                              null,
                              {
                                addTransactionBatch: this.txController.addTransactionBatch.bind(
                                  this.txController
                                ),
                                getDisabledAccountUpgradeChains:
                                  this.preferencesController.getDisabledAccountUpgradeChains.bind(
                                    this.preferencesController
                                  ),
                                getDismissSmartAccountSuggestionEnabled: () =>
                                  this.preferencesController.state.preferences
                                    .dismissSmartAccountSuggestionEnabled,
                                isAtomicBatchSupported:
                                  this.txController.isAtomicBatchSupported.bind(this.txController),
                                validateSecurity: (e, t, n) =>
                                  (0, jt.validateRequestWithPPOM)({
                                    chainId: n,
                                    ppomController: this.ppomController,
                                    request: t,
                                    securityAlertId: e,
                                    updateSecurityAlertResponse:
                                      this.updateSecurityAlertResponse.bind(this),
                                  }),
                              },
                              this.controllerMessenger
                            ),
                            getCallsStatus: rn.getCallsStatus.bind(null, this.controllerMessenger),
                            getCapabilities: rn.getCapabilities.bind(null, {
                              getDisabledAccountUpgradeChains:
                                this.preferencesController.getDisabledAccountUpgradeChains.bind(
                                  this.preferencesController
                                ),
                              getDismissSmartAccountSuggestionEnabled: () =>
                                this.preferencesController.state.preferences
                                  .dismissSmartAccountSuggestionEnabled,
                              isAtomicBatchSupported: this.txController.isAtomicBatchSupported.bind(
                                this.txController
                              ),
                            }),
                          })),
                          this.on('update', e => this._onStateUpdate(e));
                        const Qe = {
                          AccountTracker: this.accountTrackerController,
                          TokenRatesController: this.tokenRatesController,
                          DecryptMessageController: this.decryptMessageController,
                          EncryptionPublicKeyController: this.encryptionPublicKeyController,
                          SignatureController: this.signatureController,
                          SwapsController: this.swapsController,
                          BridgeController: this.bridgeController,
                          BridgeStatusController: this.bridgeStatusController,
                          EnsController: this.ensController,
                          ApprovalController: this.approvalController,
                        };
                        this.store.updateStructure({
                          AccountsController: this.accountsController,
                          AppStateController: this.appStateController,
                          AppMetadataController: this.appMetadataController,
                          KeyringController: this.keyringController,
                          PreferencesController: this.preferencesController,
                          MetaMetricsController: this.metaMetricsController,
                          MetaMetricsDataDeletionController: this.metaMetricsDataDeletionController,
                          AddressBookController: this.addressBookController,
                          CurrencyController: this.currencyRateController,
                          MultichainNetworkController: this.multichainNetworkController,
                          NetworkController: this.networkController,
                          AlertController: this.alertController,
                          OnboardingController: this.onboardingController,
                          PermissionController: this.permissionController,
                          PermissionLogController: this.permissionLogController,
                          SubjectMetadataController: this.subjectMetadataController,
                          AnnouncementController: this.announcementController,
                          NetworkOrderController: this.networkOrderController,
                          AccountOrderController: this.accountOrderController,
                          GasFeeController: this.gasFeeController,
                          TokenListController: this.tokenListController,
                          TokensController: this.tokensController,
                          TokenBalancesController: this.tokenBalancesController,
                          SmartTransactionsController: this.smartTransactionsController,
                          NftController: this.nftController,
                          PhishingController: this.phishingController,
                          SelectedNetworkController: this.selectedNetworkController,
                          LoggingController: this.loggingController,
                          MultichainRatesController: this.multichainRatesController,
                          NameController: this.nameController,
                          UserOperationController: this.userOperationController,
                          AuthenticationController: this.authenticationController,
                          UserStorageController: this.userStorageController,
                          NotificationServicesController: this.notificationServicesController,
                          NotificationServicesPushController:
                            this.notificationServicesPushController,
                          RemoteFeatureFlagController: this.remoteFeatureFlagController,
                          ...Qe,
                          ...Ze,
                        }),
                          (this.memStore = new We.default({
                            config: {
                              AccountsController: this.accountsController,
                              AppStateController: this.appStateController,
                              AppMetadataController: this.appMetadataController,
                              MultichainAssetsController: this.multichainAssetsController,
                              MultichainBalancesController: this.multichainBalancesController,
                              MultichainTransactionsController:
                                this.multichainTransactionsController,
                              MultichainAssetsRatesController: this.multichainAssetsRatesController,
                              TokenRatesController: this.tokenRatesController,
                              MultichainNetworkController: this.multichainNetworkController,
                              NetworkController: this.networkController,
                              KeyringController: this.keyringController,
                              PreferencesController: this.preferencesController,
                              MetaMetricsController: this.metaMetricsController,
                              MetaMetricsDataDeletionController:
                                this.metaMetricsDataDeletionController,
                              AddressBookController: this.addressBookController,
                              CurrencyController: this.currencyRateController,
                              AlertController: this.alertController,
                              OnboardingController: this.onboardingController,
                              PermissionController: this.permissionController,
                              PermissionLogController: this.permissionLogController,
                              SubjectMetadataController: this.subjectMetadataController,
                              AnnouncementController: this.announcementController,
                              NetworkOrderController: this.networkOrderController,
                              AccountOrderController: this.accountOrderController,
                              GasFeeController: this.gasFeeController,
                              TokenListController: this.tokenListController,
                              TokensController: this.tokensController,
                              TokenBalancesController: this.tokenBalancesController,
                              SmartTransactionsController: this.smartTransactionsController,
                              NftController: this.nftController,
                              SelectedNetworkController: this.selectedNetworkController,
                              LoggingController: this.loggingController,
                              MultichainRatesController: this.multichainRatesController,
                              SnapController: this.snapController,
                              CronjobController: this.cronjobController,
                              SnapsRegistry: this.snapsRegistry,
                              SnapInterfaceController: this.snapInterfaceController,
                              SnapInsightsController: this.snapInsightsController,
                              NameController: this.nameController,
                              UserOperationController: this.userOperationController,
                              AuthenticationController: this.authenticationController,
                              UserStorageController: this.userStorageController,
                              NotificationServicesController: this.notificationServicesController,
                              QueuedRequestController: this.queuedRequestController,
                              NotificationServicesPushController:
                                this.notificationServicesPushController,
                              RemoteFeatureFlagController: this.remoteFeatureFlagController,
                              ...Qe,
                              ...Ke,
                            },
                            controllerMessenger: this.controllerMessenger,
                          }));
                        const Ye = [
                          this.accountTrackerController.resetState.bind(
                            this.accountTrackerController
                          ),
                          this.decryptMessageController.resetState.bind(
                            this.decryptMessageController
                          ),
                          this.encryptionPublicKeyController.resetState.bind(
                            this.encryptionPublicKeyController
                          ),
                          this.signatureController.resetState.bind(this.signatureController),
                          this.swapsController.resetState.bind(this.swapsController),
                          this.bridgeController.resetState.bind(this.bridgeController),
                          this.ensController.resetState.bind(this.ensController),
                          this.approvalController.clear.bind(this.approvalController),
                        ];
                        Ee.isManifestV3
                          ? !0 === n &&
                            (this.resetStates(Ye),
                            this.extension.storage.session.set({
                              isFirstMetaMaskControllerSetup: !1,
                            }))
                          : this.resetStates(Ye);
                        !this.isUnlocked() && this.onboardingController.state.completedOnboarding,
                          this._startUISync(),
                          this.extension.runtime.getPlatformInfo().then(({ os: e }) => {
                            this.appStateController.setBrowserEnvironment(
                              e,
                              this.extension.runtime.getBrowserInfo === undefined
                                ? 'chrome'
                                : 'firefox'
                            );
                          }),
                          this.setupControllerEventSubscriptions(),
                          this.setupMultichainDataAndSubscriptions(),
                          (this.publicConfigStore = this.createPublicConfigStore()),
                          this.extension.runtime.onMessageExternal.addListener(
                            Ge.onMessageReceived
                          ),
                          (0, Ge.checkForMultipleVersionsRunning)(),
                          this.onboardingController.state.completedOnboarding &&
                            this.postOnboardingInitialization();
                      }
                      getInfuraFeatureFlags() {
                        (0, Oe.default)({
                          url: 'https://swap.api.cx.metamask.io/featureFlags',
                          cacheRefreshTime: 20 * fe.MINUTE,
                        })
                          .then(this.onFeatureFlagResponseReceived)
                          .catch(e => {
                            b.default.warn('Feature flag endpoint is unreachable', e);
                          });
                      }
                      onFeatureFlagResponseReceived(e) {
                        const { multiChainAssets: t = {} } = e,
                          { pollInterval: n } = t;
                        n > 0 && this.tokenBalancesController.setIntervalLength(n * fe.SECOND);
                      }
                      postOnboardingInitialization() {
                        const { usePhishDetect: e } = this.preferencesController.state;
                        this.networkController.lookupNetwork(),
                          e && this.phishingController.maybeUpdateState();
                      }
                      triggerNetworkrequests() {
                        dn(fn, this, Cn).call(this),
                          this.tokenDetectionController.enable(),
                          this.getInfuraFeatureFlags();
                      }
                      stopNetworkRequests() {
                        this.txController.stopIncomingTransactionPolling(),
                          this.tokenDetectionController.disable();
                      }
                      resetStates(e) {
                        e.forEach(e => {
                          try {
                            e();
                          } catch (e) {
                            console.error(e);
                          }
                        });
                      }
                      async getSnapKeyring() {
                        let [e] = this.keyringController.getKeyringsByType(he.KeyringType.snap);
                        return (
                          e ||
                            (await this.keyringController.addNewKeyring(he.KeyringType.snap),
                            ([e] = this.keyringController.getKeyringsByType(he.KeyringType.snap))),
                          e
                        );
                      }
                      trackInsightSnapView(e) {
                        this.metaMetricsController.trackEvent({
                          event: be.MetaMetricsEventName.InsightSnapViewed,
                          category: be.MetaMetricsEventCategory.Snaps,
                          properties: { snap_id: e },
                        });
                      }
                      _getSnapMetadata(e) {
                        var t;
                        return null === (t = this.snapsRegistry.state.database) ||
                          void 0 === t ||
                          null === (t = t.verifiedSnaps) ||
                          void 0 === t ||
                          null === (t = t[e]) ||
                          void 0 === t
                          ? void 0
                          : t.metadata;
                      }
                      async handleSnapRequest(e) {
                        try {
                          const t = await this.controllerMessenger.call(
                            'SnapController:handleRequest',
                            e
                          );
                          return this._trackSnapExportUsage(e.snapId, e.handler, !0, e.origin), t;
                        } catch (t) {
                          throw (this._trackSnapExportUsage(e.snapId, e.handler, !1, e.origin), t);
                        }
                      }
                      getLocale() {
                        const { currentLocale: e } = this.preferencesController.state;
                        return e;
                      }
                      getPreferences() {
                        const {
                          preferences: e,
                          securityAlertsEnabled: t,
                          useCurrencyRateCheck: n,
                          useTransactionSimulations: r,
                          useTokenDetection: s,
                          useMultiAccountBalanceChecker: a,
                          openSeaEnabled: o,
                          useNftDetection: i,
                        } = this.preferencesController.state;
                        return {
                          privacyMode: e.privacyMode,
                          securityAlertsEnabled: t,
                          useCurrencyRateCheck: n,
                          useTransactionSimulations: r,
                          useTokenDetection: s,
                          useMultiAccountBalanceChecker: a,
                          openSeaEnabled: o,
                          useNftDetection: i,
                        };
                      }
                      getSnapPermissionSpecifications() {
                        return {
                          ...(0, F.buildSnapEndowmentSpecifications)(
                            Object.keys(pe.ExcludedSnapEndowments)
                          ),
                          ...(0, F.buildSnapRestrictedMethodSpecifications)(
                            Object.keys(pe.ExcludedSnapPermissions),
                            {
                              getPreferences: () => {
                                const e = this.getLocale(),
                                  t = this.currencyRateController.state.currentCurrency,
                                  {
                                    privacyMode: n,
                                    securityAlertsEnabled: r,
                                    useCurrencyRateCheck: s,
                                    useTransactionSimulations: a,
                                    useTokenDetection: o,
                                    useMultiAccountBalanceChecker: i,
                                    openSeaEnabled: c,
                                    useNftDetection: l,
                                  } = this.getPreferences();
                                return {
                                  locale: e,
                                  currency: t,
                                  hideBalances: n,
                                  useSecurityAlerts: r,
                                  useExternalPricingData: s,
                                  simulateOnChainActions: a,
                                  useTokenDetection: o,
                                  batchCheckBalances: i,
                                  displayNftMedia: c,
                                  useNftDetection: l,
                                };
                              },
                              clearSnapState: this.controllerMessenger.call.bind(
                                this.controllerMessenger,
                                'SnapController:clearSnapState'
                              ),
                              getMnemonic: async e => {
                                if (!e) return this.getPrimaryKeyringMnemonic();
                                try {
                                  const { type: t, mnemonic: n } =
                                    await this.controllerMessenger.call(
                                      'KeyringController:withKeyring',
                                      { id: e },
                                      async ({ keyring: e }) => ({
                                        type: e.type,
                                        mnemonic: e.mnemonic,
                                      })
                                    );
                                  if (t !== h.KeyringTypes.hd || !n)
                                    throw new Error(`Entropy source with ID "${e}" not found.`);
                                  return n;
                                } catch {
                                  throw new Error(`Entropy source with ID "${e}" not found.`);
                                }
                              },
                              getMnemonicSeed: async e => {
                                if (!e) return this.getPrimaryKeyringMnemonicSeed();
                                try {
                                  const { type: t, seed: n } = await this.controllerMessenger.call(
                                    'KeyringController:withKeyring',
                                    { id: e },
                                    async ({ keyring: e }) => ({ type: e.type, seed: e.seed })
                                  );
                                  if (t !== h.KeyringTypes.hd || !n)
                                    throw new Error(`Entropy source with ID "${e}" not found.`);
                                  return n;
                                } catch {
                                  throw new Error(`Entropy source with ID "${e}" not found.`);
                                }
                              },
                              getUnlockPromise: this.appStateController.getUnlockPromise.bind(
                                this.appStateController
                              ),
                              getSnap: this.controllerMessenger.call.bind(
                                this.controllerMessenger,
                                'SnapController:get'
                              ),
                              handleSnapRpcRequest: this.handleSnapRequest.bind(this),
                              getSnapState: this.controllerMessenger.call.bind(
                                this.controllerMessenger,
                                'SnapController:getSnapState'
                              ),
                              requestUserApproval:
                                this.approvalController.addAndShowApprovalRequest.bind(
                                  this.approvalController
                                ),
                              showNativeNotification: (e, t) =>
                                this.controllerMessenger.call(
                                  'RateLimitController:call',
                                  e,
                                  'showNativeNotification',
                                  e,
                                  t.message
                                ),
                              showInAppNotification: (e, t) => {
                                const { message: n, title: r, footerLink: s } = t,
                                  a = {
                                    interfaceId: t.content,
                                    message: n,
                                    title: r,
                                    footerLink: s,
                                  };
                                return this.controllerMessenger.call(
                                  'RateLimitController:call',
                                  e,
                                  'showInAppNotification',
                                  e,
                                  a
                                );
                              },
                              updateSnapState: this.controllerMessenger.call.bind(
                                this.controllerMessenger,
                                'SnapController:updateSnapState'
                              ),
                              maybeUpdatePhishingList: () => {
                                const { usePhishDetect: e } = this.preferencesController.state;
                                e &&
                                  this.controllerMessenger.call(
                                    'PhishingController:maybeUpdateState'
                                  );
                              },
                              isOnPhishingList: e => {
                                const { usePhishDetect: t } = this.preferencesController.state;
                                return (
                                  !!t &&
                                  this.controllerMessenger.call('PhishingController:testOrigin', e)
                                    .result
                                );
                              },
                              createInterface: this.controllerMessenger.call.bind(
                                this.controllerMessenger,
                                'SnapInterfaceController:createInterface'
                              ),
                              getInterface: this.controllerMessenger.call.bind(
                                this.controllerMessenger,
                                'SnapInterfaceController:getInterface'
                              ),
                              getClientCryptography: () => ({}),
                              getSnapKeyring: this.getSnapKeyring.bind(this),
                            }
                          ),
                        };
                      }
                      setupControllerEventSubscriptions() {
                        let e, t;
                        try {
                          var n;
                          t =
                            null ===
                              (n = this.accountsController.getSelectedMultichainAccount(
                                je.MultichainNetworks.SOLANA
                              )) || void 0 === n
                              ? void 0
                              : n.address;
                        } catch {}
                        this.controllerMessenger.subscribe(
                          'PreferencesController:stateChange',
                          (0, ft.previousValueComparator)(async (e, t) => {
                            const { currentLocale: n } = t;
                            dn(fn, this, Cn).call(this),
                              await (0, _t.updateCurrentLocale)(n),
                              dn(fn, this, yn).call(this, t, e);
                          }, this.preferencesController.state)
                        ),
                          this.controllerMessenger.subscribe(
                            `${this.accountsController.name}:selectedAccountChange`,
                            async t => {
                              t.address &&
                                t.address !== e &&
                                ((e = t.address), await this._onAccountChange(t.address));
                            }
                          ),
                          this.controllerMessenger.subscribe(
                            `${this.permissionController.name}:stateChange`,
                            async (e, t) => {
                              const n = (0, vt.diffMap)(e, t);
                              for (const [e, t] of n.entries()) this._notifyAccountsChange(e, t);
                            },
                            vt.getPermittedAccountsByOrigin
                          ),
                          this.controllerMessenger.subscribe(
                            `${this.permissionController.name}:stateChange`,
                            async (e, t) => {
                              const n = (0, vt.getChangedAuthorizations)(e, t),
                                r = (0, vt.getRemovedAuthorizations)(e, t);
                              for (const [e, t] of r.entries()) {
                                const n = (0, ae.getSessionScopes)(t, {
                                  getNonEvmSupportedMethods:
                                    this.getNonEvmSupportedMethods.bind(this),
                                });
                                Object.entries(n).forEach(([t, n]) => {
                                  n.notifications.includes('eth_subscription') &&
                                    n.methods.includes('eth_subscribe') &&
                                    this.removeMultichainApiEthSubscriptionMiddleware({
                                      scope: t,
                                      origin: e,
                                    });
                                });
                              }
                              for (const [e, t] of n.entries()) {
                                const n = (0, ae.getSessionScopes)(t, {
                                  getNonEvmSupportedMethods:
                                    this.getNonEvmSupportedMethods.bind(this),
                                });
                                Object.entries(n).forEach(([t, n]) => {
                                  n.notifications.includes('eth_subscription') &&
                                  n.methods.includes('eth_subscribe')
                                    ? Object.values(this.connections[e]).forEach(({ tabId: n }) => {
                                        this.addMultichainApiEthSubscriptionMiddleware({
                                          scope: t,
                                          origin: e,
                                          tabId: n,
                                        });
                                      })
                                    : this.removeMultichainApiEthSubscriptionMiddleware({
                                        scope: t,
                                        origin: e,
                                      });
                                }),
                                  this._notifyAuthorizationChange(e, t);
                              }
                            },
                            vt.getAuthorizedScopesByOrigin
                          ),
                          this.controllerMessenger.subscribe(
                            `${this.permissionController.name}:stateChange`,
                            async (e, t) => {
                              (0, u.uniq)([...t.keys(), ...e.keys()]).forEach(n => {
                                var r, s;
                                const a = t.get(n),
                                  o = e.get(n),
                                  i = Boolean(
                                    null == a || null === (r = a.sessionProperties) || void 0 === r
                                      ? void 0
                                      : r[
                                          ae.KnownSessionProperties
                                            .SolanaAccountChangedNotifications
                                        ]
                                  ),
                                  c = Boolean(
                                    null == o || null === (s = o.sessionProperties) || void 0 === s
                                      ? void 0
                                      : s[
                                          ae.KnownSessionProperties
                                            .SolanaAccountChangedNotifications
                                        ]
                                  );
                                if (!i && !c) return;
                                const l = (
                                    a
                                      ? (0, ae.getPermittedAccountsForScopes)(a, [
                                          je.MultichainNetworks.SOLANA,
                                          je.MultichainNetworks.SOLANA_DEVNET,
                                          je.MultichainNetworks.SOLANA_TESTNET,
                                        ])
                                      : []
                                  ).map(e => {
                                    const { address: t } = (0, te.parseCaipAccountId)(e);
                                    return t;
                                  }),
                                  d = (0, u.uniq)(l),
                                  [h] = this.sortMultichainAccountsByLastSelected(d),
                                  p = (
                                    o
                                      ? (0, ae.getPermittedAccountsForScopes)(o, [
                                          je.MultichainNetworks.SOLANA,
                                          je.MultichainNetworks.SOLANA_DEVNET,
                                          je.MultichainNetworks.SOLANA_TESTNET,
                                        ])
                                      : []
                                  ).map(e => {
                                    const { address: t } = (0, te.parseCaipAccountId)(e);
                                    return t;
                                  }),
                                  m = (0, u.uniq)(p),
                                  [f] = this.sortMultichainAccountsByLastSelected(m);
                                h !== f && this._notifySolanaAccountChange(n, f ? [f] : []);
                              });
                            },
                            vt.getAuthorizedScopesByOrigin
                          ),
                          this.controllerMessenger.subscribe(
                            `${this.accountsController.name}:selectedAccountChange`,
                            async e => {
                              if (e.type === ee.SolAccountType.DataAccount && e.address !== t) {
                                t = e.address;
                                const n = (0, vt.getOriginsWithSessionProperty)(
                                    this.permissionController.state,
                                    ae.KnownSessionProperties.SolanaAccountChangedNotifications
                                  ),
                                  r = (0, vt.getPermittedAccountsForScopesByOrigin)(
                                    this.permissionController.state,
                                    [
                                      je.MultichainNetworks.SOLANA,
                                      je.MultichainNetworks.SOLANA_DEVNET,
                                      je.MultichainNetworks.SOLANA_TESTNET,
                                    ]
                                  );
                                if (r.size > 0)
                                  for (const [t, s] of r.entries()) {
                                    s
                                      .map(e => {
                                        const { address: t } = (0, te.parseCaipAccountId)(e);
                                        return t;
                                      })
                                      .includes(e.address) &&
                                      n[t] &&
                                      this._notifySolanaAccountChange(t, [e.address]);
                                  }
                              }
                            }
                          ),
                          this.controllerMessenger.subscribe(
                            `${this.permissionController.name}:stateChange`,
                            async (e, t) => {
                              const n = (0, vt.diffMap)(e, t);
                              for (const [e, t] of n.entries()) {
                                const n =
                                    this.selectedNetworkController.getNetworkClientIdForDomain(e),
                                  { chainId: r } =
                                    this.networkController.getNetworkConfigurationByNetworkClientId(
                                      n
                                    );
                                if (t.length > 0 && !t.includes(r)) {
                                  const n = this.networkController.findNetworkClientIdByChainId(
                                    t[0]
                                  );
                                  this.networkController.setActiveNetwork(n),
                                    this.selectedNetworkController.setNetworkClientIdForDomain(
                                      e,
                                      n
                                    );
                                }
                              }
                            },
                            vt.getPermittedChainsByOrigin
                          ),
                          this.controllerMessenger.subscribe(
                            'NetworkController:networkRemoved',
                            ({ chainId: e }) => {
                              const t = (0, te.toCaipChainId)(
                                'eip155',
                                (0, te.hexToBigInt)(e).toString(10)
                              );
                              this.removeAllScopePermissions(t);
                            }
                          ),
                          this.controllerMessenger.subscribe(
                            'NetworkController:networkDidChange',
                            async () => {
                              !0 === this.preferencesController.state.useExternalServices &&
                                (this.txController.stopIncomingTransactionPolling(),
                                await this.txController.updateIncomingTransactions(),
                                this.txController.startIncomingTransactionPolling());
                            }
                          ),
                          this.controllerMessenger.subscribe(
                            `${this.snapController.name}:snapInstallStarted`,
                            (e, t, n) => {
                              var r;
                              const s =
                                null === (r = this._getSnapMetadata(e)) || void 0 === r
                                  ? void 0
                                  : r.category;
                              this.metaMetricsController.trackEvent({
                                event: n
                                  ? be.MetaMetricsEventName.SnapUpdateStarted
                                  : be.MetaMetricsEventName.SnapInstallStarted,
                                category: be.MetaMetricsEventCategory.Snaps,
                                properties: { snap_id: e, origin: t, snap_category: s },
                              });
                            }
                          ),
                          this.controllerMessenger.subscribe(
                            `${this.snapController.name}:snapInstallFailed`,
                            (e, t, n, r) => {
                              var s;
                              const a = r.includes('User rejected the request.'),
                                o = n
                                  ? be.MetaMetricsEventName.SnapUpdateFailed
                                  : be.MetaMetricsEventName.SnapInstallFailed,
                                i = n
                                  ? be.MetaMetricsEventName.SnapUpdateRejected
                                  : be.MetaMetricsEventName.SnapInstallRejected,
                                c =
                                  null === (s = this._getSnapMetadata(e)) || void 0 === s
                                    ? void 0
                                    : s.category;
                              this.metaMetricsController.trackEvent({
                                event: a ? i : o,
                                category: be.MetaMetricsEventCategory.Snaps,
                                properties: { snap_id: e, origin: t, snap_category: c },
                              });
                            }
                          ),
                          this.controllerMessenger.subscribe(
                            `${this.snapController.name}:snapInstalled`,
                            (e, t, n) => {
                              var r;
                              if (n) return;
                              const s = e.id,
                                a =
                                  null === (r = this._getSnapMetadata(s)) || void 0 === r
                                    ? void 0
                                    : r.category;
                              this.metaMetricsController.trackEvent({
                                event: be.MetaMetricsEventName.SnapInstalled,
                                category: be.MetaMetricsEventCategory.Snaps,
                                properties: {
                                  snap_id: s,
                                  version: e.version,
                                  origin: t,
                                  snap_category: a,
                                },
                              });
                            }
                          ),
                          this.controllerMessenger.subscribe(
                            `${this.snapController.name}:snapUpdated`,
                            (e, t, n, r) => {
                              var s;
                              if (r) return;
                              const a = e.id,
                                o =
                                  null === (s = this._getSnapMetadata(a)) || void 0 === s
                                    ? void 0
                                    : s.category;
                              this.metaMetricsController.trackEvent({
                                event: be.MetaMetricsEventName.SnapUpdated,
                                category: be.MetaMetricsEventCategory.Snaps,
                                properties: {
                                  snap_id: a,
                                  old_version: t,
                                  new_version: e.version,
                                  origin: n,
                                  snap_category: o,
                                },
                              });
                            }
                          ),
                          this.controllerMessenger.subscribe(
                            `${this.snapController.name}:snapTerminated`,
                            e => {
                              const t = Object.values(
                                this.approvalController.state.pendingApprovals
                              ).filter(
                                t =>
                                  t.origin === e.id &&
                                  t.type.startsWith(pe.RestrictedMethods.snap_dialog)
                              );
                              for (const e of t)
                                this.approvalController.reject(
                                  e.id,
                                  new Error('Snap was terminated.')
                                );
                            }
                          ),
                          this.controllerMessenger.subscribe(
                            `${this.snapController.name}:snapUninstalled`,
                            e => {
                              var t;
                              const n = this.notificationServicesController
                                .getNotificationsByType(re.TRIGGER_TYPES.SNAP)
                                .filter(t => t.data.origin === e.id)
                                .map(e => e.id);
                              this.notificationServicesController.deleteNotificationsById(n);
                              const r = e.id,
                                s =
                                  null === (t = this._getSnapMetadata(r)) || void 0 === t
                                    ? void 0
                                    : t.category;
                              this.metaMetricsController.trackEvent({
                                event: be.MetaMetricsEventName.SnapUninstalled,
                                category: be.MetaMetricsEventCategory.Snaps,
                                properties: { snap_id: r, version: e.version, snap_category: s },
                              });
                            }
                          );
                      }
                      setupMultichainDataAndSubscriptions() {
                        (0, ee.isEvmAccountType)(
                          this.accountsController.getSelectedMultichainAccount().type
                        ) || this.multichainRatesController.start(),
                          this.controllerMessenger.subscribe(
                            'AccountsController:selectedAccountChange',
                            e => {
                              (0, ee.isEvmAccountType)(e.type)
                                ? this.multichainRatesController.stop()
                                : this.multichainRatesController.start();
                            }
                          ),
                          this.controllerMessenger.subscribe(
                            'CurrencyRateController:stateChange',
                            ({ currentCurrency: e }) => {
                              e !== this.multichainRatesController.state.fiatCurrency &&
                                this.multichainRatesController.setFiatCurrency(e);
                            }
                          );
                      }
                      addMultichainApiEthSubscriptionMiddleware({ scope: e, origin: t, tabId: n }) {
                        const r = this.multichainSubscriptionManager.subscribe({
                          scope: e,
                          origin: t,
                          tabId: n,
                        });
                        this.multichainMiddlewareManager.addMiddleware({
                          scope: e,
                          origin: t,
                          tabId: n,
                          middleware: r.middleware,
                        });
                      }
                      removeMultichainApiEthSubscriptionMiddleware({ scope: e, origin: t }) {
                        this.multichainMiddlewareManager.removeMiddlewareByScopeAndOrigin(e, t),
                          this.multichainSubscriptionManager.unsubscribeByScopeAndOrigin(e, t);
                      }
                      createPublicConfigStore() {
                        const e = new c.ObservableStore(),
                          t = async ({ isUnlocked: e }) => {
                            const {
                              chainId: t,
                              networkVersion: n,
                              isConnected: r,
                            } = await this.getProviderNetworkState();
                            return { isUnlocked: e, chainId: t, networkVersion: r ? n : 'loading' };
                          },
                          n = async n => {
                            var r;
                            (null === (r = n.networksMetadata[n.selectedNetworkClientId]) ||
                            void 0 === r
                              ? void 0
                              : r.status) === le.NetworkStatus.Available && e.putState(await t(n));
                          };
                        return this.on('update', n), n(this.getState()), e;
                      }
                      async getProviderState(e) {
                        const t = await this.getProviderNetworkState(e),
                          n = {};
                        if (Ee.isManifestV3) {
                          var r;
                          const { chrome: e } = globalThis;
                          n.extensionId =
                            null == e || null === (r = e.runtime) || void 0 === r ? void 0 : r.id;
                        }
                        return {
                          isUnlocked: !0,
                          accounts: this.getPermittedAccounts(e),
                          ...n,
                          ...t,
                        };
                      }
                      async getProviderNetworkState(e = B.METAMASK_DOMAIN) {
                        const t = this.controllerMessenger.call(
                            'SelectedNetworkController:getNetworkClientIdForDomain',
                            e
                          ),
                          n = this.controllerMessenger.call(
                            'NetworkController:getNetworkClientById',
                            t
                          ),
                          { chainId: r } = n.configuration,
                          { completedOnboarding: s } = this.onboardingController.state;
                        let a = this.deprecatedNetworkVersions[t];
                        if (a === undefined && s) {
                          try {
                            const e = await n.provider.request({ method: 'net_version' });
                            a = (0, Te.convertNetworkId)(e);
                          } catch (e) {
                            console.error(e), (a = null);
                          }
                          this.deprecatedNetworkVersions[t] = a;
                        }
                        const o = this.networkController.state.networksMetadata[t];
                        return {
                          chainId: r,
                          networkVersion: a ?? 'loading',
                          isConnected:
                            (null == o ? void 0 : o.status) === le.NetworkStatus.Available,
                        };
                      }
                      getState() {
                        const { vault: e } = this.keyringController.state,
                          t = Boolean(e),
                          n = this.memStore.getFlatState();
                        return { isInitialized: t, ...(0, Ut.sanitizeUIState)(n) };
                      }
                      getApi() {
                        const {
                          accountsController: e,
                          addressBookController: t,
                          alertController: n,
                          appStateController: r,
                          keyringController: s,
                          nftController: a,
                          nftDetectionController: o,
                          currencyRateController: i,
                          tokenBalancesController: c,
                          tokenDetectionController: l,
                          ensController: d,
                          tokenListController: u,
                          gasFeeController: h,
                          metaMetricsController: p,
                          networkController: m,
                          multichainNetworkController: f,
                          announcementController: g,
                          onboardingController: b,
                          permissionController: y,
                          preferencesController: w,
                          tokensController: v,
                          smartTransactionsController: C,
                          txController: k,
                          backup: S,
                          approvalController: _,
                          phishingController: E,
                          tokenRatesController: T,
                          accountTrackerController: M,
                          authenticationController: P,
                          userStorageController: A,
                          notificationServicesController: N,
                          notificationServicesPushController: I,
                        } = this;
                        return {
                          getState: this.getState.bind(this),
                          setCurrentCurrency: i.setCurrentCurrency.bind(i),
                          setUseBlockie: w.setUseBlockie.bind(w),
                          setUsePhishDetect: w.setUsePhishDetect.bind(w),
                          setUseMultiAccountBalanceChecker:
                            w.setUseMultiAccountBalanceChecker.bind(w),
                          setUseSafeChainsListValidation: w.setUseSafeChainsListValidation.bind(w),
                          setUseTokenDetection: w.setUseTokenDetection.bind(w),
                          setUseNftDetection: w.setUseNftDetection.bind(w),
                          setUse4ByteResolution: w.setUse4ByteResolution.bind(w),
                          setUseCurrencyRateCheck: w.setUseCurrencyRateCheck.bind(w),
                          setOpenSeaEnabled: w.setOpenSeaEnabled.bind(w),
                          getProviderConfig: () =>
                            (0, Ie.getProviderConfig)({ metamask: this.networkController.state }),
                          grantPermissionsIncremental:
                            this.permissionController.grantPermissionsIncremental.bind(
                              this.permissionController
                            ),
                          grantPermissions: this.permissionController.grantPermissions.bind(
                            this.permissionController
                          ),
                          setSecurityAlertsEnabled: w.setSecurityAlertsEnabled.bind(w),
                          setAddSnapAccountEnabled: w.setAddSnapAccountEnabled.bind(w),
                          setWatchEthereumAccountEnabled: w.setWatchEthereumAccountEnabled.bind(w),
                          setUseExternalNameSources: w.setUseExternalNameSources.bind(w),
                          setUseTransactionSimulations: w.setUseTransactionSimulations.bind(w),
                          setIpfsGateway: w.setIpfsGateway.bind(w),
                          setIsIpfsGatewayEnabled: w.setIsIpfsGatewayEnabled.bind(w),
                          setUseAddressBarEnsResolution: w.setUseAddressBarEnsResolution.bind(w),
                          setParticipateInMetaMetrics: p.setParticipateInMetaMetrics.bind(p),
                          setDataCollectionForMarketing: p.setDataCollectionForMarketing.bind(p),
                          setMarketingCampaignCookieId: p.setMarketingCampaignCookieId.bind(p),
                          setCurrentLocale: w.setCurrentLocale.bind(w),
                          setServiceWorkerKeepAlivePreference:
                            w.setServiceWorkerKeepAlivePreference.bind(w),
                          markPasswordForgotten: this.markPasswordForgotten.bind(this),
                          unMarkPasswordForgotten: this.unMarkPasswordForgotten.bind(this),
                          getRequestAccountTabIds: this.getRequestAccountTabIds,
                          getOpenMetamaskTabsIds: this.getOpenMetamaskTabsIds,
                          markNotificationPopupAsAutomaticallyClosed: () =>
                            this.notificationManager.markAsAutomaticallyClosed(),
                          getCode: this.getCode.bind(this),
                          addNewAccount: this.addNewAccount.bind(this),
                          getSeedPhrase: this.getSeedPhrase.bind(this),
                          resetAccount: this.resetAccount.bind(this),
                          removeAccount: this.removeAccount.bind(this),
                          importAccountWithStrategy: this.importAccountWithStrategy.bind(this),
                          getNextAvailableAccountName: e.getNextAvailableAccountName.bind(e),
                          getAccountsBySnapId: e =>
                            (0, Mt.getAccountsBySnapId)(this.getSnapKeyring.bind(this), e),
                          connectHardware: this.connectHardware.bind(this),
                          forgetDevice: this.forgetDevice.bind(this),
                          checkHardwareStatus: this.checkHardwareStatus.bind(this),
                          unlockHardwareWalletAccount: this.unlockHardwareWalletAccount.bind(this),
                          attemptLedgerTransportCreation:
                            this.attemptLedgerTransportCreation.bind(this),
                          submitQRHardwareCryptoHDKey: s.submitQRCryptoHDKey.bind(s),
                          submitQRHardwareCryptoAccount: s.submitQRCryptoAccount.bind(s),
                          cancelSyncQRHardware: s.cancelQRSynchronization.bind(s),
                          submitQRHardwareSignature: s.submitQRSignature.bind(s),
                          cancelQRHardwareSignRequest: s.cancelQRSignRequest.bind(s),
                          submitPassword: this.submitPassword.bind(this),
                          verifyPassword: this.verifyPassword.bind(this),
                          setActiveNetwork: async e =>
                            await this.multichainNetworkController.setActiveNetwork(e),
                          setActiveNetworkConfigurationId: e => {
                            this.networkController.setActiveNetwork(e);
                          },
                          setNetworkClientIdForDomain: (e, t) =>
                            this.selectedNetworkController.setNetworkClientIdForDomain(e, t),
                          rollbackToPreviousProvider: m.rollbackToPreviousProvider.bind(m),
                          addNetwork: this.networkController.addNetwork.bind(
                            this.networkController
                          ),
                          updateNetwork: this.networkController.updateNetwork.bind(
                            this.networkController
                          ),
                          removeNetwork: this.networkController.removeNetwork.bind(
                            this.networkController
                          ),
                          getCurrentNetworkEIP1559Compatibility:
                            this.networkController.getEIP1559Compatibility.bind(
                              this.networkController
                            ),
                          getNetworkConfigurationByNetworkClientId:
                            this.networkController.getNetworkConfigurationByNetworkClientId.bind(
                              this.networkController
                            ),
                          setSelectedAddress: e => {
                            const t = this.accountsController.getAccountByAddress(e);
                            if (!t) throw new Error(`No account found for address: ${e}`);
                            this.accountsController.setSelectedAccount(t.id);
                          },
                          toggleExternalServices: this.toggleExternalServices.bind(this),
                          addToken: v.addToken.bind(v),
                          updateTokenType: v.updateTokenType.bind(v),
                          setFeatureFlag: w.setFeatureFlag.bind(w),
                          setPreference: w.setPreference.bind(w),
                          addKnownMethodData: w.addKnownMethodData.bind(w),
                          setDismissSeedBackUpReminder: w.setDismissSeedBackUpReminder.bind(w),
                          setOverrideContentSecurityPolicyHeader:
                            w.setOverrideContentSecurityPolicyHeader.bind(w),
                          setAdvancedGasFee: w.setAdvancedGasFee.bind(w),
                          setTheme: w.setTheme.bind(w),
                          disableAccountUpgradeForChain: w.disableAccountUpgradeForChain.bind(w),
                          setSnapsAddSnapAccountModalDismissed:
                            w.setSnapsAddSnapAccountModalDismissed.bind(w),
                          setManageInstitutionalWallets: w.setManageInstitutionalWallets.bind(w),
                          setSelectedInternalAccount: e => {
                            this.accountsController.getAccount(e) &&
                              this.accountsController.setSelectedAccount(e);
                          },
                          setAccountName: e.setAccountName.bind(e),
                          setAccountLabel: (e, t) => {
                            const n = this.accountsController.getAccountByAddress(e);
                            if (n === undefined)
                              throw new Error(`No account found for address: ${e}`);
                            this.accountsController.setAccountName(n.id, t);
                          },
                          getTokenStandardAndDetails: this.getTokenStandardAndDetails.bind(this),
                          getTokenSymbol: this.getTokenSymbol.bind(this),
                          getTokenStandardAndDetailsByChain:
                            this.getTokenStandardAndDetailsByChain.bind(this),
                          addNft: a.addNft.bind(a),
                          addNftVerifyOwnership: a.addNftVerifyOwnership.bind(a),
                          removeAndIgnoreNft: a.removeAndIgnoreNft.bind(a),
                          removeNft: a.removeNft.bind(a),
                          checkAndUpdateAllNftsOwnershipStatus:
                            a.checkAndUpdateAllNftsOwnershipStatus.bind(a),
                          checkAndUpdateSingleNftOwnershipStatus:
                            a.checkAndUpdateSingleNftOwnershipStatus.bind(a),
                          getNFTContractInfo: a.getNFTContractInfo.bind(a),
                          isNftOwner: a.isNftOwner.bind(a),
                          setAddressBook: t.set.bind(t),
                          removeFromAddressBook: t.delete.bind(t),
                          setLastActiveTime: r.setLastActiveTime.bind(r),
                          setCurrentExtensionPopupId: r.setCurrentExtensionPopupId.bind(r),
                          setDefaultHomeActiveTabName: r.setDefaultHomeActiveTabName.bind(r),
                          setConnectedStatusPopoverHasBeenShown:
                            r.setConnectedStatusPopoverHasBeenShown.bind(r),
                          setRecoveryPhraseReminderHasBeenShown:
                            r.setRecoveryPhraseReminderHasBeenShown.bind(r),
                          setRecoveryPhraseReminderLastShown:
                            r.setRecoveryPhraseReminderLastShown.bind(r),
                          setTermsOfUseLastAgreed: r.setTermsOfUseLastAgreed.bind(r),
                          setSurveyLinkLastClickedOrClosed:
                            r.setSurveyLinkLastClickedOrClosed.bind(r),
                          setOnboardingDate: r.setOnboardingDate.bind(r),
                          setLastViewedUserSurvey: r.setLastViewedUserSurvey.bind(r),
                          setRampCardClosed: r.setRampCardClosed.bind(r),
                          setNewPrivacyPolicyToastClickedOrClosed:
                            r.setNewPrivacyPolicyToastClickedOrClosed.bind(r),
                          setNewPrivacyPolicyToastShownDate:
                            r.setNewPrivacyPolicyToastShownDate.bind(r),
                          setSnapsInstallPrivacyWarningShownStatus:
                            r.setSnapsInstallPrivacyWarningShownStatus.bind(r),
                          setOutdatedBrowserWarningLastShown:
                            r.setOutdatedBrowserWarningLastShown.bind(r),
                          setShowTestnetMessageInDropdown:
                            r.setShowTestnetMessageInDropdown.bind(r),
                          setShowBetaHeader: r.setShowBetaHeader.bind(r),
                          setShowPermissionsTour: r.setShowPermissionsTour.bind(r),
                          setShowAccountBanner: r.setShowAccountBanner.bind(r),
                          setShowNetworkBanner: r.setShowNetworkBanner.bind(r),
                          updateNftDropDownState: r.updateNftDropDownState.bind(r),
                          setSwitchedNetworkDetails: r.setSwitchedNetworkDetails.bind(r),
                          clearSwitchedNetworkDetails: r.clearSwitchedNetworkDetails.bind(r),
                          setSwitchedNetworkNeverShowMessage:
                            r.setSwitchedNetworkNeverShowMessage.bind(r),
                          getLastInteractedConfirmationInfo:
                            r.getLastInteractedConfirmationInfo.bind(r),
                          setLastInteractedConfirmationInfo:
                            r.setLastInteractedConfirmationInfo.bind(r),
                          updateSlides: r.updateSlides.bind(r),
                          removeSlide: r.removeSlide.bind(r),
                          tryReverseResolveAddress: d.reverseResolveAddress.bind(d),
                          setLocked: this.setLocked.bind(this),
                          createNewVaultAndKeychain: this.createNewVaultAndKeychain.bind(this),
                          createNewVaultAndRestore: this.createNewVaultAndRestore.bind(this),
                          generateNewMnemonicAndAddToVault:
                            this.generateNewMnemonicAndAddToVault.bind(this),
                          importMnemonicToVault: this.importMnemonicToVault.bind(this),
                          exportAccount: this.exportAccount.bind(this),
                          updateTransaction: k.updateTransaction.bind(k),
                          approveTransactionsWithSameNonce:
                            k.approveTransactionsWithSameNonce.bind(k),
                          createCancelTransaction: this.createCancelTransaction.bind(this),
                          createSpeedUpTransaction: this.createSpeedUpTransaction.bind(this),
                          estimateGas: this.estimateGas.bind(this),
                          estimateGasFee: k.estimateGasFee.bind(k),
                          getNextNonce: this.getNextNonce.bind(this),
                          addTransaction: (e, t) =>
                            (0, At.addTransaction)(
                              this.getAddTransactionRequest({
                                transactionParams: e,
                                transactionOptions: t,
                                waitForSubmit: !1,
                              })
                            ),
                          addTransactionAndWaitForPublish: (e, t) =>
                            (0, At.addTransaction)(
                              this.getAddTransactionRequest({
                                transactionParams: e,
                                transactionOptions: t,
                                waitForSubmit: !0,
                              })
                            ),
                          createTransactionEventFragment:
                            Fe.createTransactionEventFragmentWithTxId.bind(
                              null,
                              this.getTransactionMetricsRequest()
                            ),
                          setTransactionActive: k.setTransactionActive.bind(k),
                          decryptMessage: this.decryptMessageController.decryptMessage.bind(
                            this.decryptMessageController
                          ),
                          decryptMessageInline:
                            this.decryptMessageController.decryptMessageInline.bind(
                              this.decryptMessageController
                            ),
                          cancelDecryptMessage:
                            this.decryptMessageController.cancelDecryptMessage.bind(
                              this.decryptMessageController
                            ),
                          encryptionPublicKey:
                            this.encryptionPublicKeyController.encryptionPublicKey.bind(
                              this.encryptionPublicKeyController
                            ),
                          cancelEncryptionPublicKey:
                            this.encryptionPublicKeyController.cancelEncryptionPublicKey.bind(
                              this.encryptionPublicKeyController
                            ),
                          setSeedPhraseBackedUp: b.setSeedPhraseBackedUp.bind(b),
                          completeOnboarding: b.completeOnboarding.bind(b),
                          setFirstTimeFlowType: b.setFirstTimeFlowType.bind(b),
                          setAlertEnabledness: n.setAlertEnabledness.bind(n),
                          setUnconnectedAccountAlertShown:
                            n.setUnconnectedAccountAlertShown.bind(n),
                          setWeb3ShimUsageAlertDismissed: n.setWeb3ShimUsageAlertDismissed.bind(n),
                          removePermissionsFor: this.removePermissionsFor,
                          approvePermissionsRequest: this.acceptPermissionsRequest,
                          rejectPermissionsRequest: this.rejectPermissionsRequest,
                          ...(0, vt.getPermissionBackgroundApiMethods)({
                            permissionController: y,
                            approvalController: _,
                            accountsController: e,
                            networkController: m,
                            multichainNetworkController: f,
                          }),
                          disableSnap: this.controllerMessenger.call.bind(
                            this.controllerMessenger,
                            'SnapController:disable'
                          ),
                          enableSnap: this.controllerMessenger.call.bind(
                            this.controllerMessenger,
                            'SnapController:enable'
                          ),
                          updateSnap: (e, t) => (
                            this.controllerMessenger.call('SnapController:install', e, t), null
                          ),
                          removeSnap: this.controllerMessenger.call.bind(
                            this.controllerMessenger,
                            'SnapController:remove'
                          ),
                          handleSnapRequest: this.handleSnapRequest.bind(this),
                          revokeDynamicSnapPermissions: this.controllerMessenger.call.bind(
                            this.controllerMessenger,
                            'SnapController:revokeDynamicPermissions'
                          ),
                          disconnectOriginFromSnap: this.controllerMessenger.call.bind(
                            this.controllerMessenger,
                            'SnapController:disconnectOrigin'
                          ),
                          updateNetworksList: this.updateNetworksList.bind(this),
                          updateAccountsList: this.updateAccountsList.bind(this),
                          updateHiddenAccountsList: this.updateHiddenAccountsList.bind(this),
                          getPhishingResult: async e => (await E.maybeUpdateState(), E.test(e)),
                          deleteInterface: this.controllerMessenger.call.bind(
                            this.controllerMessenger,
                            'SnapInterfaceController:deleteInterface'
                          ),
                          updateInterfaceState: this.controllerMessenger.call.bind(
                            this.controllerMessenger,
                            'SnapInterfaceController:updateInterfaceState'
                          ),
                          fetchAndSetQuotes: this.controllerMessenger.call.bind(
                            this.controllerMessenger,
                            'SwapsController:fetchAndSetQuotes'
                          ),
                          setSelectedQuoteAggId: this.controllerMessenger.call.bind(
                            this.controllerMessenger,
                            'SwapsController:setSelectedQuoteAggId'
                          ),
                          resetSwapsState: this.controllerMessenger.call.bind(
                            this.controllerMessenger,
                            'SwapsController:resetSwapsState'
                          ),
                          setSwapsTokens: this.controllerMessenger.call.bind(
                            this.controllerMessenger,
                            'SwapsController:setSwapsTokens'
                          ),
                          clearSwapsQuotes: this.controllerMessenger.call.bind(
                            this.controllerMessenger,
                            'SwapsController:clearSwapsQuotes'
                          ),
                          setApproveTxId: this.controllerMessenger.call.bind(
                            this.controllerMessenger,
                            'SwapsController:setApproveTxId'
                          ),
                          setTradeTxId: this.controllerMessenger.call.bind(
                            this.controllerMessenger,
                            'SwapsController:setTradeTxId'
                          ),
                          setSwapsTxGasPrice: this.controllerMessenger.call.bind(
                            this.controllerMessenger,
                            'SwapsController:setSwapsTxGasPrice'
                          ),
                          setSwapsTxGasLimit: this.controllerMessenger.call.bind(
                            this.controllerMessenger,
                            'SwapsController:setSwapsTxGasLimit'
                          ),
                          setSwapsTxMaxFeePerGas: this.controllerMessenger.call.bind(
                            this.controllerMessenger,
                            'SwapsController:setSwapsTxMaxFeePerGas'
                          ),
                          setSwapsTxMaxFeePriorityPerGas: this.controllerMessenger.call.bind(
                            this.controllerMessenger,
                            'SwapsController:setSwapsTxMaxFeePriorityPerGas'
                          ),
                          safeRefetchQuotes: this.controllerMessenger.call.bind(
                            this.controllerMessenger,
                            'SwapsController:safeRefetchQuotes'
                          ),
                          stopPollingForQuotes: this.controllerMessenger.call.bind(
                            this.controllerMessenger,
                            'SwapsController:stopPollingForQuotes'
                          ),
                          setBackgroundSwapRouteState: this.controllerMessenger.call.bind(
                            this.controllerMessenger,
                            'SwapsController:setBackgroundSwapRouteState'
                          ),
                          resetPostFetchState: this.controllerMessenger.call.bind(
                            this.controllerMessenger,
                            'SwapsController:resetPostFetchState'
                          ),
                          setSwapsErrorKey: this.controllerMessenger.call.bind(
                            this.controllerMessenger,
                            'SwapsController:setSwapsErrorKey'
                          ),
                          setInitialGasEstimate: this.controllerMessenger.call.bind(
                            this.controllerMessenger,
                            'SwapsController:setInitialGasEstimate'
                          ),
                          setCustomApproveTxData: this.controllerMessenger.call.bind(
                            this.controllerMessenger,
                            'SwapsController:setCustomApproveTxData'
                          ),
                          setSwapsLiveness: this.controllerMessenger.call.bind(
                            this.controllerMessenger,
                            'SwapsController:setSwapsLiveness'
                          ),
                          setSwapsFeatureFlags: this.controllerMessenger.call.bind(
                            this.controllerMessenger,
                            'SwapsController:setSwapsFeatureFlags'
                          ),
                          setSwapsUserFeeLevel: this.controllerMessenger.call.bind(
                            this.controllerMessenger,
                            'SwapsController:setSwapsUserFeeLevel'
                          ),
                          setSwapsQuotesPollingLimitEnabled: this.controllerMessenger.call.bind(
                            this.controllerMessenger,
                            'SwapsController:setSwapsQuotesPollingLimitEnabled'
                          ),
                          [Z.BridgeBackgroundAction.SET_FEATURE_FLAGS]:
                            this.controllerMessenger.call.bind(
                              this.controllerMessenger,
                              `${Z.BRIDGE_CONTROLLER_NAME}:${Z.BridgeBackgroundAction.SET_FEATURE_FLAGS}`
                            ),
                          [Z.BridgeBackgroundAction.RESET_STATE]:
                            this.controllerMessenger.call.bind(
                              this.controllerMessenger,
                              `${Z.BRIDGE_CONTROLLER_NAME}:${Z.BridgeBackgroundAction.RESET_STATE}`
                            ),
                          [Z.BridgeBackgroundAction.GET_BRIDGE_ERC20_ALLOWANCE]:
                            this.controllerMessenger.call.bind(
                              this.controllerMessenger,
                              `${Z.BRIDGE_CONTROLLER_NAME}:${Z.BridgeBackgroundAction.GET_BRIDGE_ERC20_ALLOWANCE}`
                            ),
                          [Z.BridgeUserAction.UPDATE_QUOTE_PARAMS]:
                            this.controllerMessenger.call.bind(
                              this.controllerMessenger,
                              `${Z.BRIDGE_CONTROLLER_NAME}:${Z.BridgeUserAction.UPDATE_QUOTE_PARAMS}`
                            ),
                          [$e.BridgeStatusAction.START_POLLING_FOR_BRIDGE_TX_STATUS]:
                            this.controllerMessenger.call.bind(
                              this.controllerMessenger,
                              `${Kt.BRIDGE_STATUS_CONTROLLER_NAME}:${$e.BridgeStatusAction.START_POLLING_FOR_BRIDGE_TX_STATUS}`
                            ),
                          fetchSmartTransactionFees: C.getFees.bind(C),
                          clearSmartTransactionFees: C.clearFees.bind(C),
                          submitSignedTransactions: C.submitSignedTransactions.bind(C),
                          cancelSmartTransaction: C.cancelSmartTransaction.bind(C),
                          fetchSmartTransactionsLiveness: C.fetchLiveness.bind(C),
                          updateSmartTransaction: C.updateSmartTransaction.bind(C),
                          setStatusRefreshInterval: C.setStatusRefreshInterval.bind(C),
                          trackMetaMetricsEvent: p.trackEvent.bind(p),
                          trackMetaMetricsPage: p.trackPage.bind(p),
                          createEventFragment: p.createEventFragment.bind(p),
                          updateEventFragment: p.updateEventFragment.bind(p),
                          finalizeEventFragment: p.finalizeEventFragment.bind(p),
                          trackInsightSnapView: this.trackInsightSnapView.bind(this),
                          rejectAllPendingApprovals: this.rejectAllPendingApprovals.bind(this),
                          rejectPendingApproval: this.rejectPendingApproval,
                          requestUserApproval: _.addAndShowApprovalRequest.bind(_),
                          resolvePendingApproval: this.resolvePendingApproval,
                          resetViewedNotifications: g.resetViewed.bind(g),
                          updateViewedNotifications: g.updateViewed.bind(g),
                          currencyRateStartPolling: i.startPolling.bind(i),
                          currencyRateStopPollingByPollingToken:
                            i.stopPollingByPollingToken.bind(i),
                          tokenRatesStartPolling: T.startPolling.bind(T),
                          tokenRatesStopPollingByPollingToken: T.stopPollingByPollingToken.bind(T),
                          accountTrackerStartPolling: M.startPollingByNetworkClientId.bind(M),
                          accountTrackerStopPollingByPollingToken:
                            M.stopPollingByPollingToken.bind(M),
                          tokenDetectionStartPolling: l.startPolling.bind(l),
                          tokenDetectionStopPollingByPollingToken:
                            l.stopPollingByPollingToken.bind(l),
                          tokenListStartPolling: u.startPolling.bind(u),
                          tokenListStopPollingByPollingToken: u.stopPollingByPollingToken.bind(u),
                          tokenBalancesStartPolling: c.startPolling.bind(c),
                          tokenBalancesStopPollingByPollingToken:
                            c.stopPollingByPollingToken.bind(c),
                          gasFeeStartPolling: h.startPolling.bind(h),
                          gasFeeStopPollingByPollingToken: h.stopPollingByPollingToken.bind(h),
                          getGasFeeTimeEstimate: h.getTimeEstimate.bind(h),
                          addPollingTokenToAppState: r.addPollingToken.bind(r),
                          removePollingTokenFromAppState: r.removePollingToken.bind(r),
                          updateThrottledOriginState: r.updateThrottledOriginState.bind(r),
                          backupUserData: S.backupUserData.bind(S),
                          restoreUserData: S.restoreUserData.bind(S),
                          detectTokens: l.detectTokens.bind(l),
                          detectNfts: o.detectNfts.bind(o),
                          addDetectedTokens: v.addDetectedTokens.bind(v),
                          addImportedTokens: v.addTokens.bind(v),
                          ignoreTokens: v.ignoreTokens.bind(v),
                          getBalancesInSingleCall: (...e) =>
                            this.assetsContractController.getBalancesInSingleCall(...e),
                          performSignIn: P.performSignIn.bind(P),
                          performSignOut: P.performSignOut.bind(P),
                          enableProfileSyncing: A.enableProfileSyncing.bind(A),
                          disableProfileSyncing: A.disableProfileSyncing.bind(A),
                          syncInternalAccountsWithUserStorage:
                            A.syncInternalAccountsWithUserStorage.bind(A),
                          deleteAccountSyncingDataFromUserStorage:
                            A.performDeleteStorageAllFeatureEntries.bind(A),
                          checkAccountsPresence: N.checkAccountsPresence.bind(N),
                          createOnChainTriggers: N.createOnChainTriggers.bind(N),
                          deleteOnChainTriggersByAccount: N.deleteOnChainTriggersByAccount.bind(N),
                          updateOnChainTriggersByAccount: N.updateOnChainTriggersByAccount.bind(N),
                          fetchAndUpdateMetamaskNotifications:
                            N.fetchAndUpdateMetamaskNotifications.bind(N),
                          deleteNotificationsById: N.deleteNotificationsById.bind(N),
                          getNotificationsByType: N.getNotificationsByType.bind(N),
                          markMetamaskNotificationsAsRead:
                            N.markMetamaskNotificationsAsRead.bind(N),
                          setFeatureAnnouncementsEnabled: N.setFeatureAnnouncementsEnabled.bind(N),
                          enablePushNotifications: I.enablePushNotifications.bind(I),
                          disablePushNotifications: I.disablePushNotifications.bind(I),
                          updateTriggerPushNotifications: I.updateTriggerPushNotifications.bind(I),
                          enableMetamaskNotifications: N.enableMetamaskNotifications.bind(N),
                          disableMetamaskNotifications: N.disableNotificationServices.bind(N),
                          throwTestError: this.throwTestError.bind(this),
                          updateProposedNames: this.nameController.updateProposedNames.bind(
                            this.nameController
                          ),
                          setName: this.nameController.setName.bind(this.nameController),
                          createSnapAccount: async (e, t, n) => {
                            const r = await this.getSnapKeyring();
                            return await r.createAccount(e, t, n);
                          },
                          multichainUpdateBalance: e =>
                            this.multichainBalancesController.updateBalance(e),
                          multichainUpdateTransactions: e =>
                            this.multichainTransactionsController.updateTransactionsForAccount(e),
                          decodeTransactionData: e =>
                            (0, Dt.decodeTransactionData)({ ...e, provider: this.provider }),
                          createMetaMetricsDataDeletionTask:
                            this.metaMetricsDataDeletionController.createMetaMetricsDataDeletionTask.bind(
                              this.metaMetricsDataDeletionController
                            ),
                          updateDataDeletionTaskStatus:
                            this.metaMetricsDataDeletionController.updateDataDeletionTaskStatus.bind(
                              this.metaMetricsDataDeletionController
                            ),
                          endTrace: xe.endTrace,
                        };
                      }
                      rejectOriginPendingApprovals(e) {
                        (0, Gt.rejectOriginApprovals)({
                          approvalController: this.approvalController,
                          deleteInterface: e =>
                            this.controllerMessenger.call(
                              'SnapInterfaceController:deleteInterface',
                              e
                            ),
                          origin: e,
                        });
                      }
                      async exportAccount(e, t) {
                        return (
                          await this.verifyPassword(t), this.keyringController.exportAccount(t, e)
                        );
                      }
                      async getTokenStandardAndDetails(e, t, n) {
                        var r, s;
                        const { tokenList: a } = this.tokenListController.state,
                          { tokens: o } = this.tokensController.state,
                          i = {
                            ...(Se.STATIC_MAINNET_TOKEN_LIST[
                              null == e ? void 0 : e.toLowerCase()
                            ] || {}),
                            ...(a[null == e ? void 0 : e.toLowerCase()] || {}),
                            ...(o.find(({ address: t }) => (0, Ce.isEqualCaseInsensitive)(t, e)) ||
                              {}),
                          },
                          c =
                            (0, Ce.isEqualCaseInsensitive)(i.standard, ie.TokenStandard.ERC20) ||
                            !0 === i.erc20,
                          l = !(
                            n ||
                            (0, Ce.isEqualCaseInsensitive)(i.standard, ie.TokenStandard.ERC1155) ||
                            (0, Ce.isEqualCaseInsensitive)(i.standard, ie.TokenStandard.ERC721) ||
                            i.erc721
                          ),
                          d = i.decimals !== undefined && i.symbol;
                        let u;
                        if (c || (l && d))
                          try {
                            const n = t
                              ? await (0, ve.fetchTokenBalance)(e, t, this.provider)
                              : undefined;
                            u = {
                              address: e,
                              balance: n,
                              standard: ie.TokenStandard.ERC20,
                              decimals: i.decimals,
                              symbol: i.symbol,
                            };
                          } catch (e) {
                            b.default.warn(`Failed to get token balance. Error: ${e}`);
                          }
                        if (u === undefined)
                          try {
                            u = await this.assetsContractController.getTokenStandardAndDetails(
                              e,
                              t,
                              n
                            );
                          } catch (e) {
                            b.default.warn(`Failed to get token standard and details. Error: ${e}`);
                          }
                        if (u) {
                          if ((0, Ce.isEqualCaseInsensitive)(u.standard, ie.TokenStandard.ERC1155))
                            try {
                              const r = await (0, ve.fetchERC1155Balance)(e, t, n, this.provider),
                                s = null != r && r._hex ? parseInt(r._hex, 16).toString() : null;
                              u = { ...u, balance: s };
                            } catch (e) {
                              b.default.warn('Failed to get token balance. Error:', e);
                            }
                        }
                        return {
                          ...u,
                          decimals:
                            null === (r = u) ||
                            void 0 === r ||
                            null === (r = r.decimals) ||
                            void 0 === r
                              ? void 0
                              : r.toString(10),
                          balance:
                            null === (s = u) ||
                            void 0 === s ||
                            null === (s = s.balance) ||
                            void 0 === s
                              ? void 0
                              : s.toString(10),
                        };
                      }
                      async getTokenStandardAndDetailsByChain(e, t, n, r) {
                        var s, a, o;
                        const { tokensChainsCache: i } = this.tokenListController.state,
                          c =
                            (null == i || null === (s = i[r]) || void 0 === s ? void 0 : s.data) ||
                            {},
                          { tokens: l } = this.tokensController.state;
                        let d = {};
                        r === le.CHAIN_IDS.MAINNET &&
                          (d =
                            Se.STATIC_MAINNET_TOKEN_LIST[null == e ? void 0 : e.toLowerCase()] ||
                            {});
                        const u = c[null == e ? void 0 : e.toLowerCase()] || {},
                          h =
                            l.find(({ address: t }) => (0, Ce.isEqualCaseInsensitive)(t, e)) || {},
                          p = { ...d, ...u, ...h },
                          m =
                            (0, Ce.isEqualCaseInsensitive)(p.standard, ie.TokenStandard.ERC20) ||
                            !0 === p.erc20,
                          f = !(
                            n ||
                            (0, Ce.isEqualCaseInsensitive)(p.standard, ie.TokenStandard.ERC1155) ||
                            (0, Ce.isEqualCaseInsensitive)(p.standard, ie.TokenStandard.ERC721) ||
                            p.erc721
                          ),
                          g = p.decimals !== undefined && p.symbol;
                        let y;
                        if (m || (f && g))
                          try {
                            let n = 0;
                            dn(fn, this, vn).call(this) === r &&
                              (n = await (0, ve.fetchTokenBalance)(e, t, this.provider)),
                              (y = {
                                address: e,
                                balance: n,
                                standard: ie.TokenStandard.ERC20,
                                decimals: p.decimals,
                                symbol: p.symbol,
                              });
                          } catch (e) {
                            b.default.warn(`Failed to get token balance. Error: ${e}`);
                          }
                        if (y === undefined)
                          try {
                            var w, v;
                            const s =
                              null === (w = this.networkController) ||
                              void 0 === w ||
                              null === (w = w.state) ||
                              void 0 === w ||
                              null === (w = w.networkConfigurationsByChainId) ||
                              void 0 === w ||
                              null === (w = w[r]) ||
                              void 0 === w ||
                              null ===
                                (w =
                                  w.rpcEndpoints[
                                    null === (v = this.networkController) ||
                                    void 0 === v ||
                                    null === (v = v.state) ||
                                    void 0 === v ||
                                    null === (v = v.networkConfigurationsByChainId) ||
                                    void 0 === v ||
                                    null === (v = v[r]) ||
                                    void 0 === v
                                      ? void 0
                                      : v.defaultRpcEndpointIndex
                                  ]) ||
                              void 0 === w
                                ? void 0
                                : w.networkClientId;
                            y = await this.assetsContractController.getTokenStandardAndDetails(
                              e,
                              t,
                              n,
                              s
                            );
                          } catch (e) {
                            b.default.warn(`Failed to get token standard and details. Error: ${e}`);
                          }
                        if (y) {
                          if ((0, Ce.isEqualCaseInsensitive)(y.standard, ie.TokenStandard.ERC1155))
                            try {
                              const r = await (0, ve.fetchERC1155Balance)(e, t, n, this.provider),
                                s = null != r && r._hex ? parseInt(r._hex, 16).toString() : null;
                              y = { ...y, balance: s };
                            } catch (e) {
                              b.default.warn('Failed to get token balance. Error:', e);
                            }
                        }
                        return {
                          ...y,
                          decimals:
                            null === (a = y) ||
                            void 0 === a ||
                            null === (a = a.decimals) ||
                            void 0 === a
                              ? void 0
                              : a.toString(10),
                          balance:
                            null === (o = y) ||
                            void 0 === o ||
                            null === (o = o.balance) ||
                            void 0 === o
                              ? void 0
                              : o.toString(10),
                        };
                      }
                      async getTokenSymbol(e) {
                        try {
                          const t =
                            await this.assetsContractController.getTokenStandardAndDetails(e);
                          return null == t ? void 0 : t.symbol;
                        } catch (e) {
                          return null;
                        }
                      }
                      async createNewVaultAndKeychain(e) {
                        const t = await this.createVaultMutex.acquire();
                        try {
                          return await this.keyringController.createNewVaultAndKeychain(e);
                        } finally {
                          t();
                        }
                      }
                      async importMnemonicToVault(e) {
                        const n = await this.createVaultMutex.acquire();
                        try {
                          if (
                            this.keyringController
                              .getKeyringsByType(h.KeyringTypes.hd)
                              .some(
                                n =>
                                  t
                                    .from(
                                      this._convertEnglishWordlistIndicesToCodepoints(n.mnemonic)
                                    )
                                    .toString('utf8') === e
                              )
                          )
                            throw new Error(
                              'This Secret Recovery Phrase has already been imported.'
                            );
                          const { id: n } = await this.keyringController.addNewKeyring(
                              h.KeyringTypes.hd,
                              { mnemonic: e, numberOfAccounts: 1 }
                            ),
                            [r] = await this.keyringController.withKeyring(
                              { id: n },
                              async ({ keyring: e }) => e.getAccounts()
                            ),
                            s = this.accountsController.getAccountByAddress(r);
                          return (
                            this.accountsController.setSelectedAccount(s.id),
                            await this._addSolanaAccount(n),
                            await this._addAccountsWithBalance(n),
                            r
                          );
                        } finally {
                          n();
                        }
                      }
                      async generateNewMnemonicAndAddToVault() {
                        const e = await this.createVaultMutex.acquire();
                        try {
                          const { id: e } = await this.keyringController.addNewKeyring(
                              h.KeyringTypes.hd
                            ),
                            [t] = await this.keyringController.withKeyring(
                              { id: e },
                              async ({ keyring: e }) => e.getAccounts()
                            ),
                            n = this.accountsController.getAccountByAddress(t);
                          return this.accountsController.setSelectedAccount(n.id), t;
                        } finally {
                          e();
                        }
                      }
                      async createNewVaultAndRestore(e, n) {
                        const r = await this.createVaultMutex.acquire();
                        try {
                          const { completedOnboarding: r } = this.onboardingController.state,
                            s = t.from(n);
                          this.permissionController.clearState(),
                            this.snapController.clearState(),
                            this.accountTrackerController.clearAccounts(),
                            this.txController.clearUnapprovedTransactions(),
                            r && this.tokenDetectionController.enable(),
                            await this.keyringController.createNewVaultAndRestore(
                              e,
                              this._convertMnemonicToWordlistIndices(s)
                            ),
                            r &&
                              (await this._addSolanaAccount(),
                              await this._addAccountsWithBalance(),
                              dn(fn, this, bn).call(
                                this,
                                { name: ue.HardwareDeviceNames.ledger },
                                async e => this.setLedgerTransportPreference(e)
                              ));
                        } finally {
                          r();
                        }
                      }
                      async _addAccountsWithBalance(e) {
                        try {
                          const r = dn(fn, this, vn).call(this),
                            s = e ? { id: e } : { type: h.KeyringTypes.hd },
                            { accounts: a, entropySource: o } =
                              await this.keyringController.withKeyring(
                                s,
                                async ({ keyring: e, metadata: t }) => ({
                                  accounts: await e.getAccounts(),
                                  entropySource: t.id,
                                })
                              );
                          let i = a[a.length - 1];
                          for (let e = a.length; ; e++) {
                            if ('0x0' === (await this.getBalance(i, this.provider))) {
                              var t, n;
                              await this.tokenDetectionController.detectTokens({
                                chainIds: [r],
                                selectedAddress: i,
                              });
                              const s =
                                  null === (t = this.tokensController.state.allTokens) ||
                                  void 0 === t ||
                                  null === (t = t[r]) ||
                                  void 0 === t
                                    ? void 0
                                    : t[i],
                                a =
                                  null === (n = this.tokensController.state.allDetectedTokens) ||
                                  void 0 === n ||
                                  null === (n = n[r]) ||
                                  void 0 === n
                                    ? void 0
                                    : n[i];
                              if (
                                0 === ((null == s ? void 0 : s.length) ?? 0) &&
                                0 === ((null == a ? void 0 : a.length) ?? 0)
                              ) {
                                1 !== e && (await this.removeAccount(i));
                                break;
                              }
                            }
                            i = await this.keyringController.withKeyring(
                              s,
                              async ({ keyring: e }) => {
                                const [t] = await e.addAccounts(1);
                                return t;
                              }
                            );
                          }
                          const c = await this.getSnapKeyring();
                          await (0, De.addDiscoveredSolanaAccounts)(this.controllerMessenger, o, c);
                        } catch (e) {
                          b.default.warn(`Failed to add accounts with balance. Error: ${e}`);
                        } finally {
                          await this.userStorageController.setIsAccountSyncingReadyToBeDispatched(
                            !0
                          );
                        }
                      }
                      async _addSolanaAccount(e) {
                        const t = Le.SOLANA_WALLET_SNAP_ID;
                        let n = e;
                        if (!n) {
                          n = await this.keyringController.withKeyring(
                            { type: h.KeyringTypes.hd },
                            async ({ metadata: e }) => e.id
                          );
                        }
                        const r = await this.getSnapKeyring();
                        return await r.createAccount(
                          t,
                          { entropySource: n },
                          {
                            displayConfirmation: !1,
                            displayAccountNameSuggestion: !1,
                            setSelectedAccount: !1,
                          }
                        );
                      }
                      _convertMnemonicToWordlistIndices(e) {
                        const t = e
                          .toString()
                          .split(' ')
                          .map(e => K.wordlist.indexOf(e));
                        return new Uint8Array(new Uint16Array(t).buffer);
                      }
                      _convertEnglishWordlistIndicesToCodepoints(e) {
                        return t.from(
                          Array.from(new Uint16Array(e.buffer))
                            .map(e => K.wordlist[e])
                            .join(' ')
                        );
                      }
                      async getBalance(e, t) {
                        const n = this.accountTrackerController.state.accounts[e];
                        if (n && n.balance) return n.balance;
                        try {
                          return (
                            (await t.request({
                              method: 'eth_getBalance',
                              params: [e, 'latest'],
                            })) || '0x0'
                          );
                        } catch (e) {
                          throw (b.default.error(e), e);
                        }
                      }
                      async submitPassword(e) {
                        const { completedOnboarding: t } = this.onboardingController.state;
                        await this.offscreenPromise, await this.keyringController.submitPassword(e);
                        try {
                          await this.blockTracker.checkForLatestBlock();
                        } catch (e) {
                          b.default.error('Error while unlocking extension.', e);
                        }
                        await this.accountsController.updateAccounts(),
                          t &&
                            dn(fn, this, bn).call(
                              this,
                              { name: ue.HardwareDeviceNames.ledger },
                              async e => this.setLedgerTransportPreference(e)
                            );
                      }
                      async _loginUser(e) {
                        try {
                          await this.submitPassword(e),
                            await this.accountTrackerController.updateAccountsAllActiveNetworks();
                        } finally {
                          this._startUISync();
                        }
                      }
                      _startUISync() {
                        this.emit('startUISync'),
                          (this.startUISync = !0),
                          this.memStore.subscribe(this.sendUpdate.bind(this));
                      }
                      async submitEncryptionKey() {
                        try {
                          const { loginToken: e, loginSalt: t } =
                            await this.extension.storage.session.get(['loginToken', 'loginSalt']);
                          if (e && t) {
                            const { vault: n } = this.keyringController.state;
                            if (JSON.parse(n).salt !== t)
                              return (
                                console.warn(
                                  'submitEncryptionKey: Stored salt and vault salt do not match'
                                ),
                                void (await this.clearLoginArtifacts())
                              );
                            await this.keyringController.submitEncryptionKey(e, t);
                          }
                        } catch (e) {
                          throw (await this.clearLoginArtifacts(), e);
                        }
                      }
                      async clearLoginArtifacts() {
                        await this.extension.storage.session.remove(['loginToken', 'loginSalt']);
                      }
                      async verifyPassword(e) {
                        await this.keyringController.verifyPassword(e);
                      }
                      getPrimaryKeyringMnemonic() {
                        const [e] = this.keyringController.getKeyringsByType(
                          he.KeyringType.hdKeyTree
                        );
                        if (!e.mnemonic) throw new Error('Primary keyring mnemonic unavailable.');
                        return e.mnemonic;
                      }
                      getPrimaryKeyringMnemonicSeed() {
                        const [e] = this.keyringController.getKeyringsByType(
                          he.KeyringType.hdKeyTree
                        );
                        if (!e.seed) throw new Error('Primary keyring mnemonic unavailable.');
                        return e.seed;
                      }
                      async attemptLedgerTransportCreation() {
                        return await dn(fn, this, bn).call(
                          this,
                          { name: ue.HardwareDeviceNames.ledger },
                          async e => e.attemptMakeApp()
                        );
                      }
                      async connectHardware(e, t, n) {
                        return dn(fn, this, bn).call(this, { name: e, hdPath: n }, async n => {
                          e === ue.HardwareDeviceNames.ledger &&
                            (await this.setLedgerTransportPreference(n));
                          let r = [];
                          switch (t) {
                            case -1:
                              r = await n.getPreviousPage();
                              break;
                            case 1:
                              r = await n.getNextPage();
                              break;
                            default:
                              r = await n.getFirstPage();
                          }
                          const s = await this.keyringController.getAccounts(),
                            a = [...new Set(s.concat(r.map(e => e.address.toLowerCase())))];
                          return this.accountTrackerController.syncWithAddresses(a), r;
                        });
                      }
                      async checkHardwareStatus(e, t) {
                        return dn(fn, this, bn).call(this, { name: e, hdPath: t }, async e =>
                          e.isUnlocked()
                        );
                      }
                      async getHardwareTypeForMetric(e) {
                        return await this.keyringController.withKeyring(
                          { address: e },
                          ({ keyring: e }) => ue.HardwareKeyringType[e.type]
                        );
                      }
                      async forgetDevice(e) {
                        return dn(fn, this, bn).call(this, { name: e }, async e => {
                          for (const t of e.accounts) this._onAccountRemoved(t);
                          return e.forgetDevice(), !0;
                        });
                      }
                      async getAccountType(e) {
                        switch (await this.keyringController.getAccountKeyringType(e)) {
                          case he.KeyringType.trezor:
                          case he.KeyringType.oneKey:
                          case he.KeyringType.lattice:
                          case he.KeyringType.qr:
                          case he.KeyringType.ledger:
                            return 'hardware';
                          case he.KeyringType.imported:
                            return 'imported';
                          case he.KeyringType.snap:
                            return 'snap';
                          default:
                            return 'MetaMask';
                        }
                      }
                      async getDeviceModel(e) {
                        return this.keyringController.withKeyring(
                          { address: e },
                          async ({ keyring: e }) => {
                            switch (e.type) {
                              case he.KeyringType.trezor:
                              case he.KeyringType.oneKey:
                                return e.getModel();
                              case he.KeyringType.qr:
                                return e.getName();
                              case he.KeyringType.ledger:
                                return ue.HardwareDeviceNames.ledger;
                              case he.KeyringType.lattice:
                                return ue.HardwareDeviceNames.lattice;
                              default:
                                return undefined;
                            }
                          }
                        );
                      }
                      getAccountLabel(e, t, n) {
                        return `${e[0].toUpperCase()}${e.slice(1)} ${parseInt(t, 10) + 1} ${n || ''}`.trim();
                      }
                      async unlockHardwareWalletAccount(e, t, n, r) {
                        const { address: s, label: a } = await dn(fn, this, bn).call(
                          this,
                          { name: t, hdPath: n },
                          async n => {
                            n.setAccountToUnlock(e);
                            const [s] = await n.addAccounts(1);
                            return {
                              address: (0, ne.normalize)(s),
                              label: this.getAccountLabel(
                                t === ue.HardwareDeviceNames.qr ? n.getName() : t,
                                e,
                                r
                              ),
                            };
                          }
                        );
                        this.preferencesController.setAccountLabel(s, a),
                          this.preferencesController.setSelectedAddress(s);
                        const o = this.accountsController.getAccountByAddress(s);
                        this.accountsController.setAccountName(o.id, a);
                        const i = this.accountsController.listAccounts(),
                          { identities: c } = this.preferencesController.state;
                        return { unlockedAccount: s, identities: c, accounts: i };
                      }
                      async addNewAccount(e, t) {
                        const n = await this.keyringController.getAccounts(),
                          r = t ? { id: t } : { type: h.KeyringTypes.hd },
                          s = await this.keyringController.withKeyring(
                            r,
                            async ({ keyring: t }) => {
                              if (t.type !== h.KeyringTypes.hd)
                                throw new Error('Cannot add account to non-HD keyring');
                              const n = await t.getAccounts();
                              if (e && e !== n.length) {
                                if (e > n.length) throw new Error('Account out of sequence');
                                const t = n[e];
                                if (!t) throw new Error(`Can't find account at index ${e}`);
                                return t;
                              }
                              const [r] = await t.addAccounts(1);
                              return r;
                            }
                          );
                        return n.includes(s) || this.preferencesController.setSelectedAddress(s), s;
                      }
                      async getSeedPhrase(e, t) {
                        return this._convertEnglishWordlistIndicesToCodepoints(
                          await this.keyringController.exportSeedPhrase(e, t)
                        );
                      }
                      async resetAccount() {
                        const e = this.accountsController.getSelectedAccount().address,
                          t = dn(fn, this, vn).call(this);
                        return (
                          this.txController.wipeTransactions({ address: e, chainId: t }),
                          this.smartTransactionsController.wipeSmartTransactions({
                            address: e,
                            ignoreNetwork: !1,
                          }),
                          this.bridgeStatusController.wipeBridgeStatus({
                            address: e,
                            ignoreNetwork: !1,
                          }),
                          this.networkController.resetConnection(),
                          e
                        );
                      }
                      captureKeyringTypesWithMissingIdentities(e = [], t = []) {
                        const n = t
                            .filter(t => !e.some(e => e.address.toLowerCase() === t.toLowerCase()))
                            .map(e => this.keyringController.getAccountKeyringType(e)),
                          r = e.length,
                          s = Object.keys(
                            this.accountTrackerController.state.accounts || {}
                          ).length;
                        (0, _.captureException)(
                          new Error(
                            `Attempt to get permission specifications failed because their were ${t.length} accounts, but ${r} identities, and the ${n} keyrings included accounts with missing identities. Meanwhile, there are ${s} accounts in the account tracker.`
                          )
                        );
                      }
                      sortEvmAccountsByLastSelected(e) {
                        const t = this.accountsController.listAccounts();
                        return this.sortAddressesWithInternalAccounts(e, t);
                      }
                      sortMultichainAccountsByLastSelected(e) {
                        const t = this.accountsController.listMultichainAccounts();
                        return this.sortAddressesWithInternalAccounts(e, t);
                      }
                      sortAddressesWithInternalAccounts(e, t) {
                        return e.sort((n, r) => {
                          const s = t.find(e => e.address.toLowerCase() === n.toLowerCase()),
                            a = t.find(e => e.address.toLowerCase() === r.toLowerCase());
                          if (!s)
                            throw (
                              (this.captureKeyringTypesWithMissingIdentities(t, e),
                              new Error(`Missing identity for address: "${n}".`))
                            );
                          if (!a)
                            throw (
                              (this.captureKeyringTypesWithMissingIdentities(t, e),
                              new Error(`Missing identity for address: "${r}".`))
                            );
                          return s.metadata.lastSelected === a.metadata.lastSelected
                            ? 0
                            : s.metadata.lastSelected === undefined
                              ? 1
                              : a.metadata.lastSelected === undefined
                                ? -1
                                : a.metadata.lastSelected - s.metadata.lastSelected;
                        });
                      }
                      getPermittedAccounts(e, { ignoreLock: t } = {}) {
                        let n;
                        try {
                          n = this.permissionController.getCaveat(
                            e,
                            ae.Caip25EndowmentPermissionName,
                            ae.Caip25CaveatType
                          );
                        } catch (e) {
                          if (e instanceof R.PermissionDoesNotExistError) return [];
                          throw e;
                        }
                        if (!this.isUnlocked() && !t) return [];
                        const r = (0, ae.getEthAccounts)(n.value);
                        return this.sortEvmAccountsByLastSelected(r);
                      }
                      removeAllScopePermissions(e) {
                        this.permissionController.updatePermissionsByCaveat(
                          ae.Caip25CaveatType,
                          t => ae.Caip25CaveatMutators[ae.Caip25CaveatType].removeScope(t, e)
                        );
                      }
                      removeAllAccountPermissions(e) {
                        this.permissionController.updatePermissionsByCaveat(
                          ae.Caip25CaveatType,
                          t => ae.Caip25CaveatMutators[ae.Caip25CaveatType].removeAccount(t, e)
                        );
                      }
                      async removeAccount(e) {
                        return (
                          this._onAccountRemoved(e),
                          await this.keyringController.removeAccount(e),
                          e
                        );
                      }
                      async importAccountWithStrategy(e, t) {
                        const n = await this.keyringController.importAccountWithStrategy(e, t);
                        this.preferencesController.setSelectedAddress(n);
                      }
                      async requestPermissionApproval(e, t, n = {}) {
                        const r = (0, S.nanoid)();
                        return this.approvalController.addAndShowApprovalRequest({
                          id: r,
                          origin: e,
                          requestData: { metadata: { id: r, origin: e }, permissions: t, ...n },
                          type: R.MethodNames.RequestPermissions,
                        });
                      }
                      async requestApprovalPermittedChainsPermission(e, t) {
                        const n = (0, ae.setPermittedEthChainIds)(
                          {
                            requiredScopes: {},
                            optionalScopes: {},
                            sessionProperties: {},
                            isMultichainOrigin: !1,
                          },
                          [t]
                        );
                        await this.permissionController.requestPermissionsIncremental(
                          { origin: e },
                          {
                            [ae.Caip25EndowmentPermissionName]: {
                              caveats: [{ type: ae.Caip25CaveatType, value: n }],
                            },
                          }
                        );
                      }
                      async requestPermittedChainsPermissionIncremental({
                        origin: e,
                        chainId: t,
                        autoApprove: n,
                        metadata: r,
                      }) {
                        if ((0, Q.isSnapId)(e))
                          throw new Error(
                            `Cannot request permittedChains permission for Snaps with origin "${e}"`
                          );
                        const s = (0, ae.setPermittedEthChainIds)(
                          {
                            requiredScopes: {},
                            optionalScopes: {},
                            sessionProperties: {},
                            isMultichainOrigin: !1,
                          },
                          [t]
                        );
                        if (!n) {
                          let t;
                          return (
                            r && (t = { metadata: r }),
                            void (await this.permissionController.requestPermissionsIncremental(
                              { origin: e },
                              {
                                [ae.Caip25EndowmentPermissionName]: {
                                  caveats: [{ type: ae.Caip25CaveatType, value: s }],
                                },
                              },
                              t
                            ))
                          );
                        }
                        await this.permissionController.grantPermissionsIncremental({
                          subject: { origin: e },
                          approvedPermissions: {
                            [ae.Caip25EndowmentPermissionName]: {
                              caveats: [{ type: ae.Caip25CaveatType, value: s }],
                            },
                          },
                        });
                      }
                      getCaip25PermissionFromLegacyPermissions(e, t = {}) {
                        var n, r;
                        const s = (0, u.pick)(t, [
                          pe.RestrictedMethods.eth_accounts,
                          vt.PermissionNames.permittedChains,
                        ]);
                        s[pe.RestrictedMethods.eth_accounts] ||
                          (s[pe.RestrictedMethods.eth_accounts] = {}),
                          s[vt.PermissionNames.permittedChains] ||
                            (s[vt.PermissionNames.permittedChains] = {}),
                          (0, Q.isSnapId)(e) && delete s[vt.PermissionNames.permittedChains];
                        const a =
                            (null === (n = s[pe.RestrictedMethods.eth_accounts]) ||
                            void 0 === n ||
                            null === (n = n.caveats) ||
                            void 0 === n ||
                            null ===
                              (n = n.find(
                                e => e.type === pe.CaveatTypes.restrictReturnedAccounts
                              )) ||
                            void 0 === n
                              ? void 0
                              : n.value) ?? [],
                          o =
                            (null === (r = s[vt.PermissionNames.permittedChains]) ||
                            void 0 === r ||
                            null === (r = r.caveats) ||
                            void 0 === r ||
                            null ===
                              (r = r.find(
                                e => e.type === pe.CaveatTypes.restrictNetworkSwitching
                              )) ||
                            void 0 === r
                              ? void 0
                              : r.value) ?? [],
                          i = (0, ae.setPermittedEthChainIds)(
                            {
                              requiredScopes: {},
                              optionalScopes: { 'wallet:eip155': { accounts: [] } },
                              sessionProperties: {},
                              isMultichainOrigin: !1,
                            },
                            (0, Q.isSnapId)(e) ? [] : o
                          ),
                          c = (0, ae.setEthAccounts)(i, a);
                        return {
                          [ae.Caip25EndowmentPermissionName]: {
                            caveats: [{ type: ae.Caip25CaveatType, value: c }],
                          },
                        };
                      }
                      getNonEvmSupportedMethods(e) {
                        return this.controllerMessenger.call(
                          'MultichainRouter:getSupportedMethods',
                          e
                        );
                      }
                      notifySolanaAccountChangedForCurrentAccount(e) {
                        let t;
                        try {
                          t = this.permissionController.getCaveat(
                            e,
                            ae.Caip25EndowmentPermissionName,
                            ae.Caip25CaveatType
                          );
                        } catch {}
                        if (!t) return;
                        const n =
                            t.value.sessionProperties[
                              ae.KnownSessionProperties.SolanaAccountChangedNotifications
                            ],
                          r = (0, ae.getSessionScopes)(t.value, {
                            getNonEvmSupportedMethods: this.getNonEvmSupportedMethods.bind(this),
                          }),
                          s =
                            r[je.MultichainNetworks.SOLANA] ||
                            r[je.MultichainNetworks.SOLANA_DEVNET] ||
                            r[je.MultichainNetworks.SOLANA_TESTNET];
                        if (n && s) {
                          const { accounts: t } = s,
                            n = t.map(e => {
                              const { address: t } = (0, te.parseCaipAccountId)(e);
                              return t;
                            }),
                            [r] = this.sortMultichainAccountsByLastSelected(n);
                          r && this._notifySolanaAccountChange(e, [r]);
                        }
                      }
                      getAddTransactionRequest({
                        transactionParams: e,
                        transactionOptions: t,
                        dappRequest: n,
                        ...r
                      }) {
                        var s;
                        return {
                          internalAccounts: this.accountsController.listAccounts(),
                          dappRequest: n,
                          networkClientId:
                            (null == n ? void 0 : n.networkClientId) ??
                            (null == t ? void 0 : t.networkClientId),
                          selectedAccount: this.accountsController.getAccountByAddress(e.from),
                          transactionController: this.txController,
                          transactionOptions: t,
                          transactionParams: e,
                          userOperationController: this.userOperationController,
                          chainId: dn(fn, this, vn).call(this),
                          ppomController: this.ppomController,
                          securityAlertsEnabled:
                            null === (s = this.preferencesController.state) || void 0 === s
                              ? void 0
                              : s.securityAlertsEnabled,
                          updateSecurityAlertResponse: this.updateSecurityAlertResponse.bind(this),
                          ...r,
                        };
                      }
                      async getCurrentAccountEIP1559Compatibility() {
                        return !0;
                      }
                      async createCancelTransaction(e, t, n) {
                        await this.txController.stopTransaction(e, t, n);
                        return this.getState();
                      }
                      async createSpeedUpTransaction(e, t, n) {
                        await this.txController.speedUpTransaction(e, t, n);
                        return this.getState();
                      }
                      async estimateGas(e) {
                        return new Promise((t, n) => {
                          this.provider
                            .request({ method: 'eth_estimateGas', params: [e] })
                            .then(e => t(e.toString(16)))
                            .catch(e => n(e));
                        });
                      }
                      async updateSecurityAlertResponse(e, t, n) {
                        await (0, jt.updateSecurityAlertResponse)({
                          appStateController: this.appStateController,
                          method: e,
                          securityAlertId: t,
                          securityAlertResponse: n,
                          signatureController: this.signatureController,
                          transactionController: this.txController,
                        });
                      }
                      getHDEntropyIndex() {
                        const e = this.accountsController.getSelectedAccount(),
                          t = this.keyringController.state.keyrings
                            .filter(e => e.type === h.KeyringTypes.hd)
                            .findIndex(t => t.accounts.includes(e.address));
                        return -1 === t ? undefined : t;
                      }
                      markPasswordForgotten() {
                        this.preferencesController.setPasswordForgotten(!0), this.sendUpdate();
                      }
                      unMarkPasswordForgotten() {
                        this.preferencesController.setPasswordForgotten(!1), this.sendUpdate();
                      }
                      setupUntrustedCommunicationEip1193({
                        connectionStream: e,
                        sender: t,
                        subjectType: n,
                      }) {
                        if (
                          t.url &&
                          this.onboardingController.state.completedOnboarding &&
                          this.preferencesController.state.usePhishDetect
                        ) {
                          const { hostname: n } = new URL(t.url);
                          this.phishingController.maybeUpdateState();
                          const r = this.phishingController.test(t.url);
                          if (null != r && r.result)
                            return (
                              this.sendPhishingWarning(e, n),
                              void this.metaMetricsController.trackEvent({
                                event: be.MetaMetricsEventName.PhishingPageDisplayed,
                                category: be.MetaMetricsEventCategory.Phishing,
                                properties: { url: n },
                              })
                            );
                        }
                        let r;
                        r =
                          n ||
                          (t.id && t.id !== this.extension.runtime.id
                            ? R.SubjectType.Extension
                            : R.SubjectType.Website);
                        const s = (0, st.setupMultiplex)(e);
                        this.setupProviderConnectionEip1193(
                          s.createStream('metamask-provider'),
                          t,
                          r
                        ),
                          t.url && this.setupPublicConfig(s.createStream('publicConfig'));
                      }
                      setupUntrustedCommunicationCaip({
                        connectionStream: e,
                        sender: t,
                        subjectType: n,
                      }) {
                        let r;
                        r =
                          n ||
                          (t.id && t.id !== this.extension.runtime.id
                            ? R.SubjectType.Extension
                            : R.SubjectType.Website);
                        const s = (0, Pe.createCaipStream)(e);
                        this.setupProviderConnectionCaip(s, t, r);
                      }
                      setupTrustedCommunication(e, t) {
                        const n = (0, st.setupMultiplex)(e);
                        this.setupControllerConnection(n.createStream('controller')),
                          this.setupProviderConnectionEip1193(
                            n.createStream('provider'),
                            t,
                            R.SubjectType.Internal
                          );
                      }
                      setupPhishingCommunication({ connectionStream: e }) {
                        const { usePhishDetect: t } = this.preferencesController.state;
                        if (!t) return;
                        const n = (0, st.setupMultiplex)(e).createStream(
                          'metamask-phishing-safelist'
                        );
                        n.on(
                          'data',
                          (0, mt.default)(
                            {
                              safelistPhishingDomain: this.safelistPhishingDomain.bind(this),
                              backToSafetyPhishingWarning:
                                this.backToSafetyPhishingWarning.bind(this),
                            },
                            n
                          )
                        );
                      }
                      setUpCookieHandlerCommunication({ connectionStream: e }) {
                        const {
                          metaMetricsId: t,
                          dataCollectionForMarketing: n,
                          participateInMetaMetrics: r,
                        } = this.metaMetricsController.state;
                        if (t && n && r) {
                          const t = (0, st.setupMultiplex)(e).createStream(
                            Rt.METAMASK_COOKIE_HANDLER
                          );
                          t.on(
                            'data',
                            (0, mt.default)(
                              {
                                getCookieFromMarketingPage:
                                  this.getCookieFromMarketingPage.bind(this),
                              },
                              t
                            )
                          );
                        }
                      }
                      getCookieFromMarketingPage(e) {
                        const { ga_client_id: t } = e;
                        this.metaMetricsController.setMarketingCampaignCookieId(t);
                      }
                      sendPhishingWarning(e, t) {
                        (0, st.setupMultiplex)(e).createStream('phishing').write({ hostname: t });
                      }
                      setupControllerConnection(e) {
                        const t = new qt.PatchStore(this.memStore);
                        let n = !1;
                        const r = () => {
                            if (!(0, st.isStreamWritable)(e) || !n) return;
                            const r = t.flushPendingPatches();
                            e.write({ jsonrpc: '2.0', method: 'sendUpdate', params: [r] });
                          },
                          a = {
                            ...this.getApi(),
                            ...this.controllerApi,
                            startPatches: () => {
                              (n = !0), r();
                            },
                            getStatePatches: () => t.flushPendingPatches(),
                          };
                        this.on('update', r),
                          (this.activeControllerConnections += 1),
                          this.emit(
                            'controllerConnectionChanged',
                            this.activeControllerConnections
                          ),
                          e.on('data', (0, mt.default)(a, e));
                        const o = () => {
                          (0, st.isStreamWritable)(e) &&
                            e.write({ jsonrpc: '2.0', method: 'startUISync' });
                        };
                        this.startUISync ? o() : this.once('startUISync', o);
                        const i = () => {
                          e.mmFinished ||
                            ((this.activeControllerConnections -= 1),
                            this.emit(
                              'controllerConnectionChanged',
                              this.activeControllerConnections
                            ),
                            (e.mmFinished = !0),
                            this.removeListener('update', r),
                            t.destroy());
                        };
                        (e.mmFinished = !1),
                          (0, s.finished)(e, i),
                          e.once('close', i),
                          e.once('end', i);
                      }
                      setupProviderConnectionEip1193(e, t, n) {
                        let r, a;
                        (r =
                          n === R.SubjectType.Internal
                            ? ge.ORIGIN_METAMASK
                            : n === R.SubjectType.Snap
                              ? t.snapId
                              : new URL(t.url).origin),
                          t.id &&
                            t.id !== this.extension.runtime.id &&
                            this.subjectMetadataController.addSubjectMetadata({
                              origin: r,
                              extensionId: t.id,
                              subjectType: R.SubjectType.Extension,
                            }),
                          t.tab && t.tab.id && (a = t.tab.id);
                        let o = r;
                        t.tab && t.tab.url && (o = new URL(t.tab.url).origin);
                        const c = this.setupProviderEngineEip1193({
                            origin: r,
                            sender: t,
                            subjectType: n,
                            tabId: a,
                            mainFrameOrigin: o,
                          }),
                          l = (0, Ze.default)(),
                          d = (0, i.createEngineStream)({ engine: c }),
                          u = this.addConnection(r, { tabId: a, apiType: un, engine: c });
                        (0, s.pipeline)(e, l, d, e, e => {
                          var t;
                          c.destroy(),
                            u && this.removeConnection(r, u),
                            !e ||
                              (null !== (t = e.message) &&
                                void 0 !== t &&
                                t.match('Premature close')) ||
                              b.default.error(e);
                        }),
                          n !== R.SubjectType.Internal &&
                            this._notifyChainChangeForConnection({ engine: c }, r);
                      }
                      setupProviderConnectionCaip(e, t, n) {
                        let r, a;
                        (r =
                          n === R.SubjectType.Internal
                            ? ge.ORIGIN_METAMASK
                            : n === R.SubjectType.Snap
                              ? t.snapId
                              : new URL(t.url).origin),
                          t.id &&
                            t.id !== this.extension.runtime.id &&
                            this.subjectMetadataController.addSubjectMetadata({
                              origin: r,
                              extensionId: t.id,
                              subjectType: R.SubjectType.Extension,
                            }),
                          t.tab && t.tab.id && (a = t.tab.id);
                        const o = this.setupProviderEngineCaip({
                            origin: r,
                            sender: t,
                            subjectType: n,
                            tabId: a,
                          }),
                          c = (0, Ze.default)(),
                          l = (0, i.createEngineStream)({ engine: o }),
                          d = this.addConnection(r, { tabId: a, apiType: hn, engine: o });
                        setTimeout(() => this.notifySolanaAccountChangedForCurrentAccount(r), 500),
                          (0, s.pipeline)(e, c, l, e, e => {
                            var t;
                            o.destroy(),
                              d && this.removeConnection(r, d),
                              !e ||
                                (null !== (t = e.message) &&
                                  void 0 !== t &&
                                  t.match('Premature close')) ||
                                b.default.error(e);
                          });
                      }
                      setupProviderEngineEip1193({
                        origin: e,
                        subjectType: t,
                        sender: n,
                        tabId: r,
                        mainFrameOrigin: s,
                      }) {
                        const a = new o.JsonRpcEngine();
                        a.push((0, Ye.default)({ origin: e })),
                          s && a.push((0, Xe.default)({ mainFrameOrigin: s })),
                          a.push((0, B.createSelectedNetworkMiddleware)(this.controllerMessenger));
                        {
                          const e = (0, W.createQueuedRequestMiddleware)({
                            enqueueRequest: this.queuedRequestController.enqueueRequest.bind(
                              this.queuedRequestController
                            ),
                            shouldEnqueueRequest: e =>
                              oe.methodsThatShouldBeEnqueued.includes(e.method),
                            useRequestQueue: () => !0,
                          });
                          a.push(e);
                        }
                        const i = this.selectedNetworkController.getProviderAndBlockTracker(e),
                          c = (0, p.default)(i),
                          l = (0, m.default)(i);
                        return (
                          l.events.on('notification', e => a.emit('notification', e)),
                          r && a.push((0, et.default)({ tabId: r })),
                          a.push((0, Je.default)({ origin: e })),
                          a.push(this.permissionLogController.createMiddleware()),
                          e === Ae.BaseUrl.Portfolio &&
                            a.push((0, Ot.createTxVerificationMiddleware)(this.networkController)),
                          a.push((0, Lt.default)()),
                          a.push(
                            (0, Ft.default)({
                              getThrottledOriginState:
                                this.appStateController.getThrottledOriginState.bind(
                                  this.appStateController
                                ),
                              updateThrottledOriginState:
                                this.appStateController.updateThrottledOriginState.bind(
                                  this.appStateController
                                ),
                            })
                          ),
                          a.push(
                            (0, Ke.createPPOMMiddleware)(
                              this.ppomController,
                              this.preferencesController,
                              this.networkController,
                              this.appStateController,
                              this.accountsController,
                              this.updateSecurityAlertResponse.bind(this)
                            )
                          ),
                          a.push(
                            (0, St.default)({
                              getAccountType: this.getAccountType.bind(this),
                              getDeviceModel: this.getDeviceModel.bind(this),
                              getHDEntropyIndex: this.getHDEntropyIndex.bind(this),
                              getHardwareTypeForMetric: this.getHardwareTypeForMetric.bind(this),
                              snapAndHardwareMessenger: this.controllerMessenger.getRestricted({
                                name: 'SnapAndHardwareMessenger',
                                allowedActions: [
                                  'KeyringController:getKeyringForAccount',
                                  'SnapController:get',
                                  'AccountsController:getSelectedAccount',
                                ],
                              }),
                              appStateController: this.appStateController,
                              metaMetricsController: this.metaMetricsController,
                            })
                          ),
                          a.push((0, Qe.createUnsupportedMethodMiddleware)()),
                          a.push(
                            (0, Qe.createEthAccountsMethodMiddleware)({
                              getAccounts: this.getPermittedAccounts.bind(this, e),
                            })
                          ),
                          t !== R.SubjectType.Internal &&
                            a.push(
                              this.permissionController.createPermissionMiddleware({ origin: e })
                            ),
                          t === R.SubjectType.Website &&
                            a.push(
                              (0, rt.default)({
                                location: n.url,
                                registerOnboarding: this.onboardingController.registerOnboarding,
                              })
                            ),
                          a.push(
                            (0, Bt.default)({
                              messenger: this.controllerMessenger.getRestricted({
                                name: 'EvmMethodsToNonEvmAccountFilterMessenger',
                                allowedActions: ['AccountsController:getSelectedAccount'],
                              }),
                            })
                          ),
                          a.push(
                            (0, Qe.createEip1193MethodMiddleware)({
                              subjectType: t,
                              addSubjectMetadata:
                                this.subjectMetadataController.addSubjectMetadata.bind(
                                  this.subjectMetadataController
                                ),
                              metamaskState: this.getState(),
                              getProviderState: this.getProviderState.bind(this),
                              getUnlockPromise: this.appStateController.getUnlockPromise.bind(
                                this.appStateController
                              ),
                              handleWatchAssetRequest: this.handleWatchAssetRequest.bind(this),
                              requestUserApproval:
                                this.approvalController.addAndShowApprovalRequest.bind(
                                  this.approvalController
                                ),
                              sendMetrics: this.metaMetricsController.trackEvent.bind(
                                this.metaMetricsController
                              ),
                              getAccounts: this.getPermittedAccounts.bind(this, e),
                              getCaip25PermissionFromLegacyPermissionsForOrigin:
                                this.getCaip25PermissionFromLegacyPermissions.bind(this, e),
                              getPermissionsForOrigin:
                                this.permissionController.getPermissions.bind(
                                  this.permissionController,
                                  e
                                ),
                              requestPermittedChainsPermissionIncrementalForOrigin: t =>
                                this.requestPermittedChainsPermissionIncremental({
                                  ...t,
                                  origin: e,
                                }),
                              requestPermissionsForOrigin: t =>
                                this.permissionController.requestPermissions({ origin: e }, t),
                              revokePermissionsForOrigin: t => {
                                try {
                                  this.permissionController.revokePermissions({ [e]: t });
                                } catch (e) {
                                  console.log(e);
                                }
                              },
                              getCaveat: ({ target: t, caveatType: n }) => {
                                try {
                                  return this.permissionController.getCaveat(e, t, n);
                                } catch (e) {
                                  if (!(e instanceof R.PermissionDoesNotExistError)) throw e;
                                }
                                return undefined;
                              },
                              setActiveNetwork: async t => {
                                await this.networkController.setActiveNetwork(t),
                                  this.permissionController.hasPermission(
                                    e,
                                    ae.Caip25EndowmentPermissionName
                                  ) &&
                                    this.selectedNetworkController.setNetworkClientIdForDomain(
                                      e,
                                      t
                                    );
                              },
                              addNetwork: this.networkController.addNetwork.bind(
                                this.networkController
                              ),
                              updateNetwork: this.networkController.updateNetwork.bind(
                                this.networkController
                              ),
                              getNetworkConfigurationByChainId:
                                this.networkController.getNetworkConfigurationByChainId.bind(
                                  this.networkController
                                ),
                              setTokenNetworkFilter: e => {
                                const { tokenNetworkFilter: t } =
                                  this.preferencesController.getPreferences();
                                e &&
                                  1 === Object.keys(t).length &&
                                  this.preferencesController.setPreference('tokenNetworkFilter', {
                                    [e]: !0,
                                  });
                              },
                              getCurrentChainIdForDomain: e => {
                                const t =
                                    this.selectedNetworkController.getNetworkClientIdForDomain(e),
                                  { chainId: n } =
                                    this.networkController.getNetworkConfigurationByNetworkClientId(
                                      t
                                    );
                                return n;
                              },
                              getWeb3ShimUsageState:
                                this.alertController.getWeb3ShimUsageState.bind(
                                  this.alertController
                                ),
                              setWeb3ShimUsageRecorded:
                                this.alertController.setWeb3ShimUsageRecorded.bind(
                                  this.alertController
                                ),
                              updateCaveat: this.permissionController.updateCaveat.bind(
                                this.permissionController,
                                e
                              ),
                              hasApprovalRequestsForOrigin: () =>
                                this.approvalController.has({ origin: e }),
                              rejectApprovalRequestsForOrigin: () =>
                                this.rejectOriginPendingApprovals(e),
                            })
                          ),
                          a.push(
                            (0, F.createSnapsMethodMiddleware)(t === R.SubjectType.Snap, {
                              clearSnapState: this.controllerMessenger.call.bind(
                                this.controllerMessenger,
                                'SnapController:clearSnapState',
                                e
                              ),
                              getUnlockPromise: this.appStateController.getUnlockPromise.bind(
                                this.appStateController
                              ),
                              getSnaps: this.controllerMessenger.call.bind(
                                this.controllerMessenger,
                                'SnapController:getPermitted',
                                e
                              ),
                              requestPermissions: async t =>
                                await this.permissionController.requestPermissions(
                                  { origin: e },
                                  t
                                ),
                              getPermissions: this.permissionController.getPermissions.bind(
                                this.permissionController,
                                e
                              ),
                              getSnapFile: this.controllerMessenger.call.bind(
                                this.controllerMessenger,
                                'SnapController:getFile',
                                e
                              ),
                              getSnapState: this.controllerMessenger.call.bind(
                                this.controllerMessenger,
                                'SnapController:getSnapState',
                                e
                              ),
                              updateSnapState: this.controllerMessenger.call.bind(
                                this.controllerMessenger,
                                'SnapController:updateSnapState',
                                e
                              ),
                              installSnaps: this.controllerMessenger.call.bind(
                                this.controllerMessenger,
                                'SnapController:install',
                                e
                              ),
                              invokeSnap: this.permissionController.executeRestrictedMethod.bind(
                                this.permissionController,
                                e,
                                pe.RestrictedMethods.wallet_snap
                              ),
                              getIsLocked: () => !this.appStateController.isUnlocked(),
                              getInterfaceState: (...t) =>
                                this.controllerMessenger.call(
                                  'SnapInterfaceController:getInterface',
                                  e,
                                  ...t
                                ).state,
                              getInterfaceContext: (...t) =>
                                this.controllerMessenger.call(
                                  'SnapInterfaceController:getInterface',
                                  e,
                                  ...t
                                ).context,
                              createInterface: this.controllerMessenger.call.bind(
                                this.controllerMessenger,
                                'SnapInterfaceController:createInterface',
                                e
                              ),
                              updateInterface: this.controllerMessenger.call.bind(
                                this.controllerMessenger,
                                'SnapInterfaceController:updateInterface',
                                e
                              ),
                              resolveInterface: this.controllerMessenger.call.bind(
                                this.controllerMessenger,
                                'SnapInterfaceController:resolveInterface',
                                e
                              ),
                              getSnap: this.controllerMessenger.call.bind(
                                this.controllerMessenger,
                                'SnapController:get'
                              ),
                              getAllSnaps: this.controllerMessenger.call.bind(
                                this.controllerMessenger,
                                'SnapController:getAll'
                              ),
                              getCurrencyRate: e => {
                                const t = this.multichainRatesController.state.rates[e],
                                  { fiatCurrency: n } = this.multichainRatesController.state;
                                return t ? { ...t, currency: n } : undefined;
                              },
                              getEntropySources: () => {
                                const e = this.controllerMessenger.call(
                                  'KeyringController:getState'
                                );
                                return e.keyrings
                                  .map((t, n) =>
                                    t.type === h.KeyringTypes.hd
                                      ? {
                                          id: e.keyringsMetadata[n].id,
                                          name: e.keyringsMetadata[n].name,
                                          type: 'mnemonic',
                                          primary: 0 === n,
                                        }
                                      : null
                                  )
                                  .filter(Boolean);
                              },
                              hasPermission: this.permissionController.hasPermission.bind(
                                this.permissionController,
                                e
                              ),
                              scheduleBackgroundEvent: t =>
                                this.controllerMessenger.call(
                                  'CronjobController:scheduleBackgroundEvent',
                                  { ...t, snapId: e }
                                ),
                              cancelBackgroundEvent: this.controllerMessenger.call.bind(
                                this.controllerMessenger,
                                'CronjobController:cancelBackgroundEvent',
                                e
                              ),
                              getBackgroundEvents: this.controllerMessenger.call.bind(
                                this.controllerMessenger,
                                'CronjobController:getBackgroundEvents',
                                e
                              ),
                              getNetworkConfigurationByChainId: this.controllerMessenger.call.bind(
                                this.controllerMessenger,
                                'NetworkController:getNetworkConfigurationByChainId'
                              ),
                              getNetworkClientById: this.controllerMessenger.call.bind(
                                this.controllerMessenger,
                                'NetworkController:getNetworkClientById'
                              ),
                              handleSnapRpcRequest: t =>
                                this.handleSnapRequest({ ...t, origin: e }),
                              getAllowedKeyringMethods: (0, qe.keyringSnapPermissionsBuilder)(
                                this.subjectMetadataController,
                                e
                              ),
                            })
                          ),
                          a.push(c),
                          a.push(l.middleware),
                          a.push(this.metamaskMiddleware),
                          a.push((0, d.providerAsMiddleware)(i.provider)),
                          a
                        );
                      }
                      setupProviderEngineCaip({ origin: e, sender: t, subjectType: n, tabId: r }) {
                        const s = new o.JsonRpcEngine();
                        s.push((0, Ye.default)({ origin: e })),
                          r && s.push((0, et.default)({ tabId: r })),
                          s.push((0, Je.default)({ origin: e })),
                          s.push((e, t, n, r) =>
                            [
                              ge.MESSAGE_TYPE.WALLET_CREATE_SESSION,
                              ge.MESSAGE_TYPE.WALLET_INVOKE_METHOD,
                              ge.MESSAGE_TYPE.WALLET_GET_SESSION,
                              ge.MESSAGE_TYPE.WALLET_REVOKE_SESSION,
                            ].includes(e.method)
                              ? n()
                              : r(f.rpcErrors.methodNotFound({ data: { method: e.method } }))
                          ),
                          s.push(se.multichainMethodCallValidatorMiddleware);
                        const a = (0, Qe.makeMethodMiddlewareMaker)([
                          se.walletRevokeSession,
                          se.walletGetSession,
                          se.walletInvokeMethod,
                          Ht.walletCreateSession,
                        ]);
                        s.push(
                          a({
                            findNetworkClientIdByChainId:
                              this.networkController.findNetworkClientIdByChainId.bind(
                                this.networkController
                              ),
                            listAccounts: this.accountsController.listAccounts.bind(
                              this.accountsController
                            ),
                            requestPermissionsForOrigin: (t, n = {}) =>
                              this.permissionController.requestPermissions({ origin: e }, t, n),
                            sendMetrics: this.metaMetricsController.trackEvent.bind(
                              this.metaMetricsController
                            ),
                            metamaskState: this.getState(),
                            getCaveatForOrigin: this.permissionController.getCaveat.bind(
                              this.permissionController,
                              e
                            ),
                            getSelectedNetworkClientId: () =>
                              this.networkController.state.selectedNetworkClientId,
                            revokePermissionForOrigin:
                              this.permissionController.revokePermission.bind(
                                this.permissionController,
                                e
                              ),
                            getNonEvmSupportedMethods: this.getNonEvmSupportedMethods.bind(this),
                            isNonEvmScopeSupported: this.controllerMessenger.call.bind(
                              this.controllerMessenger,
                              'MultichainRouter:isSupportedScope'
                            ),
                            handleNonEvmRequestForOrigin: t =>
                              this.controllerMessenger.call('MultichainRouter:handleRequest', {
                                ...t,
                                origin: e,
                              }),
                            getNonEvmAccountAddresses: this.controllerMessenger.call.bind(
                              this.controllerMessenger,
                              'MultichainRouter:getSupportedAccounts'
                            ),
                          })
                        );
                        const i = (0, W.createQueuedRequestMiddleware)({
                          enqueueRequest: this.queuedRequestController.enqueueRequest.bind(
                            this.queuedRequestController
                          ),
                          useRequestQueue: () => !0,
                          shouldEnqueueRequest: e =>
                            oe.methodsRequiringNetworkSwitch.includes(e.method),
                        });
                        s.push(i),
                          s.push(
                            (0, Qe.createUnsupportedMethodMiddleware)(
                              new Set([
                                ...le.UNSUPPORTED_RPC_METHODS,
                                'eth_requestAccounts',
                                'eth_accounts',
                              ])
                            )
                          ),
                          n === R.SubjectType.Website &&
                            s.push(
                              (0, rt.default)({
                                location: t.url,
                                registerOnboarding: this.onboardingController.registerOnboarding,
                              })
                            ),
                          s.push(
                            (0, Qe.createMultichainMethodMiddleware)({
                              subjectType: n,
                              addSubjectMetadata:
                                this.subjectMetadataController.addSubjectMetadata.bind(
                                  this.subjectMetadataController
                                ),
                              getProviderState: this.getProviderState.bind(this),
                              handleWatchAssetRequest: this.handleWatchAssetRequest.bind(this),
                              requestUserApproval:
                                this.approvalController.addAndShowApprovalRequest.bind(
                                  this.approvalController
                                ),
                              getCaveat: ({ target: t, caveatType: n }) => {
                                try {
                                  return this.permissionController.getCaveat(e, t, n);
                                } catch (e) {
                                  if (!(e instanceof R.PermissionDoesNotExistError)) throw e;
                                }
                                return undefined;
                              },
                              addNetwork: this.networkController.addNetwork.bind(
                                this.networkController
                              ),
                              updateNetwork: this.networkController.updateNetwork.bind(
                                this.networkController
                              ),
                              setActiveNetwork: async t => {
                                await this.networkController.setActiveNetwork(t),
                                  this.permissionController.hasPermission(
                                    e,
                                    ae.Caip25EndowmentPermissionName
                                  ) &&
                                    this.selectedNetworkController.setNetworkClientIdForDomain(
                                      e,
                                      t
                                    );
                              },
                              getNetworkConfigurationByChainId:
                                this.networkController.getNetworkConfigurationByChainId.bind(
                                  this.networkController
                                ),
                              getCurrentChainIdForDomain: e => {
                                const t =
                                    this.selectedNetworkController.getNetworkClientIdForDomain(e),
                                  { chainId: n } =
                                    this.networkController.getNetworkConfigurationByNetworkClientId(
                                      t
                                    );
                                return n;
                              },
                              getWeb3ShimUsageState:
                                this.alertController.getWeb3ShimUsageState.bind(
                                  this.alertController
                                ),
                              setWeb3ShimUsageRecorded:
                                this.alertController.setWeb3ShimUsageRecorded.bind(
                                  this.alertController
                                ),
                              requestPermittedChainsPermissionIncrementalForOrigin: t =>
                                this.requestPermittedChainsPermissionIncremental({
                                  ...t,
                                  origin: e,
                                }),
                              rejectApprovalRequestsForOrigin: () =>
                                this.rejectOriginPendingApprovals(e),
                            })
                          ),
                          s.push(this.metamaskMiddleware);
                        try {
                          const t = this.permissionController.getCaveat(
                              e,
                              ae.Caip25EndowmentPermissionName,
                              ae.Caip25CaveatType
                            ),
                            n = (0, ae.getSessionScopes)(t.value, {
                              getNonEvmSupportedMethods: this.getNonEvmSupportedMethods.bind(this),
                            });
                          Object.entries(n).forEach(([t, n]) => {
                            n.notifications.includes('eth_subscription') &&
                              n.methods.includes('eth_subscribe') &&
                              this.addMultichainApiEthSubscriptionMiddleware({
                                scope: t,
                                origin: e,
                                tabId: r,
                              });
                          });
                        } catch (e) {}
                        return (
                          this.multichainSubscriptionManager.on('notification', (t, n, a) => {
                            e === t && r === n && s.emit('notification', a);
                          }),
                          s.push(
                            this.multichainMiddlewareManager.generateMultichainMiddlewareForOriginAndTabId(
                              e,
                              r
                            )
                          ),
                          s.push(async (e, t, n, r) => {
                            const { provider: s } = this.networkController.getNetworkClientById(
                              e.networkClientId
                            );
                            return (t.result = await s.request(e)), r();
                          }),
                          s
                        );
                      }
                      setupPublicConfig(e) {
                        const t = (0, l.storeAsStream)(this.publicConfigStore);
                        (0, s.pipeline)(t, e, e => {
                          var n;
                          t.destroy(),
                            !e ||
                              (null !== (n = e.message) &&
                                void 0 !== n &&
                                n.match('Premature close')) ||
                              b.default.error(e);
                        });
                      }
                      addConnection(e, { tabId: t, apiType: n, engine: r }) {
                        if (e === ge.ORIGIN_METAMASK) return null;
                        this.connections[e] || (this.connections[e] = {});
                        const s = (0, S.nanoid)();
                        return (this.connections[e][s] = { tabId: t, apiType: n, engine: r }), s;
                      }
                      removeConnection(e, t) {
                        const n = this.connections[e];
                        n &&
                          (delete n[t], 0 === Object.keys(n).length && delete this.connections[e]);
                      }
                      removeAllConnections(e) {
                        const t = this.connections[e];
                        t &&
                          Object.keys(t).forEach(t => {
                            this.removeConnection(e, t);
                          });
                      }
                      notifyConnections(e, t, n) {
                        const r = this.connections[e];
                        r &&
                          Object.values(r).forEach(e => {
                            (n && e.apiType !== n) ||
                              (e.engine && e.engine.emit('notification', t));
                          });
                      }
                      notifyAllConnections(e, t) {
                        const n = 'function' == typeof e ? t => e(t) : () => e;
                        Object.keys(this.connections).forEach(e => {
                          Object.values(this.connections[e]).forEach(async r => {
                            if (!t || r.apiType === t)
                              try {
                                this.notifyConnection(r, await n(e));
                              } catch (e) {
                                console.error(e);
                              }
                          });
                        });
                      }
                      notifyConnection(e, t) {
                        try {
                          e.engine && e.engine.emit('notification', t);
                        } catch (e) {
                          console.error(e);
                        }
                      }
                      async _onKeyringControllerUpdate(e) {
                        const { keyrings: t } = e,
                          n = t
                            .reduce((e, { accounts: t }) => e.concat(t), [])
                            .filter($t.isEthAddress);
                        n.length && this.accountTrackerController.syncWithAddresses(n);
                      }
                      _onUnlock() {
                        this.unMarkPasswordForgotten(), this.emit('unlock');
                      }
                      _onLock() {
                        this.emit('lock');
                      }
                      _onStateUpdate(e) {
                        (this.isClientOpenAndUnlocked = e.isUnlocked && this._isClientOpen),
                          this._notifyChainChange();
                      }
                      _onAccountRemoved(e) {
                        this.removeAllAccountPermissions(e);
                      }
                      privateSendUpdate() {
                        this.emit('update', this.getState());
                      }
                      isUnlocked() {
                        return this.keyringController.state.isUnlocked;
                      }
                      getExternalPendingTransactions(e) {
                        return this.smartTransactionsController.getTransactions({
                          addressFrom: e,
                          status: 'pending',
                        });
                      }
                      async initializeChainlist() {
                        const e = `cachedFetch:${le.CHAIN_SPEC_URL}`,
                          { cachedResponse: t } = (await (0, we.getStorageItem)(e)) || {};
                        t ||
                          (await (0, we.setStorageItem)(e, {
                            cachedResponse: (0, C.rawChainData)(),
                            cachedTime: 0,
                          }));
                      }
                      async getPendingNonce(e, t) {
                        const { nonceDetails: n, releaseLock: r } =
                            await this.txController.getNonceLock(e, t),
                          s = n.params.highestSuggested;
                        return r(), s;
                      }
                      async getNextNonce(e, t) {
                        const n = await this.txController.getNonceLock(e, t);
                        return n.releaseLock(), n.nextNonce;
                      }
                      throwTestError(e) {
                        setTimeout(() => {
                          const t = new Error(e);
                          throw ((t.name = 'TestError'), t);
                        });
                      }
                      _addBridgeStatusControllerListeners() {
                        this.controllerMessenger.subscribe(
                          'BridgeStatusController:bridgeTransactionComplete',
                          e =>
                            (0, Wt.handleBridgeTransactionComplete)(e, {
                              backgroundState: this.getState(),
                              trackEvent: this.metaMetricsController.trackEvent.bind(
                                this.metaMetricsController
                              ),
                            })
                        ),
                          this.controllerMessenger.subscribe(
                            'BridgeStatusController:bridgeTransactionFailed',
                            e =>
                              (0, Wt.handleBridgeTransactionFailed)(e, {
                                backgroundState: this.getState(),
                                trackEvent: this.metaMetricsController.trackEvent.bind(
                                  this.metaMetricsController
                                ),
                              })
                          ),
                          this.controllerMessenger.subscribe(
                            'TransactionController:transactionFailed',
                            ({ transactionMeta: e }) => {
                              const { type: t, status: n } = e,
                                r = t === J.TransactionType.bridge,
                                s = [
                                  J.TransactionStatus.approved,
                                  J.TransactionStatus.signed,
                                ].includes(n);
                              r &&
                                !s &&
                                (0, Wt.handleTransactionFailedTypeBridge)(
                                  { transactionMeta: e },
                                  {
                                    backgroundState: this.getState(),
                                    trackEvent: this.metaMetricsController.trackEvent.bind(
                                      this.metaMetricsController
                                    ),
                                  }
                                );
                            }
                          );
                      }
                      getTransactionMetricsRequest() {
                        return {
                          ...{
                            createEventFragment:
                              this.metaMetricsController.createEventFragment.bind(
                                this.metaMetricsController
                              ),
                            finalizeEventFragment:
                              this.metaMetricsController.finalizeEventFragment.bind(
                                this.metaMetricsController
                              ),
                            getEventFragmentById:
                              this.metaMetricsController.getEventFragmentById.bind(
                                this.metaMetricsController
                              ),
                            getParticipateInMetrics: () =>
                              this.metaMetricsController.state.participateInMetaMetrics,
                            trackEvent: this.metaMetricsController.trackEvent.bind(
                              this.metaMetricsController
                            ),
                            updateEventFragment:
                              this.metaMetricsController.updateEventFragment.bind(
                                this.metaMetricsController
                              ),
                            getAccountBalance: (e, t) => {
                              var n;
                              return null ===
                                (n = this.accountTrackerController.state.accountsByChainId) ||
                                void 0 === n ||
                                null === (n = n[t]) ||
                                void 0 === n ||
                                null === (n = n[e]) ||
                                void 0 === n
                                ? void 0
                                : n.balance;
                            },
                            getAccountType: this.getAccountType.bind(this),
                            getDeviceModel: this.getDeviceModel.bind(this),
                            getHardwareTypeForMetric: this.getHardwareTypeForMetric.bind(this),
                            getEIP1559GasFeeEstimates:
                              this.gasFeeController.fetchGasFeeEstimates.bind(
                                this.gasFeeController
                              ),
                            getSelectedAddress: () =>
                              this.accountsController.getSelectedAccount().address,
                            getTokenStandardAndDetails: this.getTokenStandardAndDetails.bind(this),
                            getTransaction: e =>
                              this.txController.state.transactions.find(t => t.id === e),
                            getIsSmartTransaction: () =>
                              (0, Me.getIsSmartTransaction)(this._getMetaMaskState()),
                            getSmartTransactionByMinedTxHash: e =>
                              this.smartTransactionsController.getSmartTransactionByMinedTxHash(e),
                            getMethodData: e => {
                              if (!e) return null;
                              const { knownMethodData: t, use4ByteResolution: n } =
                                  this.preferencesController.state,
                                r = (0, ft.addHexPrefix)(e);
                              return (0, ft.getMethodDataName)(
                                t,
                                n,
                                r,
                                this.preferencesController.addKnownMethodData.bind(
                                  this.preferencesController
                                ),
                                this.provider
                              );
                            },
                            getIsConfirmationAdvancedDetailsOpen: () =>
                              this.preferencesController.state.preferences
                                .showConfirmationAdvancedDetails,
                            getHDEntropyIndex: this.getHDEntropyIndex.bind(this),
                          },
                          snapAndHardwareMessenger: this.controllerMessenger.getRestricted({
                            name: 'SnapAndHardwareMessenger',
                            allowedActions: [
                              'KeyringController:getKeyringForAccount',
                              'SnapController:get',
                              'AccountsController:getSelectedAccount',
                            ],
                          }),
                          provider: this.provider,
                        };
                      }
                      updateAccountBalanceForTransactionNetwork(e) {
                        const {
                          networkClientId: t,
                          txParams: { from: n },
                        } = e;
                        this.accountTrackerController.updateAccountByAddress({
                          from: n,
                          networkClientId: t,
                        });
                      }
                      toggleExternalServices(e) {
                        this.preferencesController.toggleExternalServices(e),
                          this.tokenListController.updatePreventPollingOnNetworkRestart(!e),
                          e
                            ? (this.tokenDetectionController.enable(),
                              this.gasFeeController.enableNonRPCGasFeeApis())
                            : (this.tokenDetectionController.disable(),
                              this.gasFeeController.disableNonRPCGasFeeApis());
                      }
                      async setLedgerTransportPreference(e) {
                        const t = window.navigator.hid
                          ? ue.LedgerTransportTypes.webhid
                          : ue.LedgerTransportTypes.u2f;
                        return null != e && e.updateTransportMethod
                          ? e.updateTransportMethod(t).catch(e => {
                              throw e;
                            })
                          : undefined;
                      }
                      recordFirstTimeInfo(e) {
                        if (!('firstTimeInfo' in e)) {
                          const t = '12.17.2-flask.0';
                          e.firstTimeInfo = { version: t, date: Date.now() };
                        }
                      }
                      set isClientOpen(e) {
                        this._isClientOpen = e;
                      }
                      onClientClosed() {
                        try {
                          this.gasFeeController.stopAllPolling(),
                            this.currencyRateController.stopAllPolling(),
                            this.tokenRatesController.stopAllPolling(),
                            this.tokenDetectionController.stopAllPolling(),
                            this.tokenListController.stopAllPolling(),
                            this.tokenBalancesController.stopAllPolling(),
                            this.appStateController.clearPollingTokens(),
                            this.accountTrackerController.stopAllPolling();
                        } catch (e) {
                          console.error(e);
                        }
                      }
                      onEnvironmentTypeClosed(e) {
                        const t = ge.POLLING_TOKEN_ENVIRONMENT_TYPES[e];
                        this.appStateController.state[t].forEach(e => {
                          this.gasFeeController.stopPollingByPollingToken(e),
                            this.currencyRateController.stopPollingByPollingToken(e),
                            this.tokenRatesController.stopPollingByPollingToken(e),
                            this.tokenDetectionController.stopPollingByPollingToken(e),
                            this.tokenListController.stopPollingByPollingToken(e),
                            this.tokenBalancesController.stopPollingByPollingToken(e),
                            this.accountTrackerController.stopPollingByPollingToken(e),
                            this.appStateController.removePollingToken(e, t);
                        });
                      }
                      safelistPhishingDomain(e) {
                        return (
                          this.metaMetricsController.trackEvent({
                            category: be.MetaMetricsEventCategory.Phishing,
                            event: be.MetaMetricsEventName.ProceedAnywayClicked,
                            properties: { url: e, referrer: { url: e } },
                          }),
                          this.phishingController.bypass(e)
                        );
                      }
                      async backToSafetyPhishingWarning() {
                        this.metaMetricsController.trackEvent({
                          category: be.MetaMetricsEventCategory.Navigation,
                          event: be.MetaMetricsEventName.PortfolioLinkClicked,
                          properties: { location: 'phishing_page', text: 'Back to safety' },
                        }),
                          await this.platform.switchToAnotherURL(
                            undefined,
                            'https://portfolio.metamask.io/?metamaskEntry=phishing_page_portfolio_button'
                          );
                      }
                      setLocked() {
                        return this.keyringController.setLocked();
                      }
                      rejectAllPendingApprovals() {
                        (0, Gt.rejectAllApprovals)({
                          approvalController: this.approvalController,
                          deleteInterface: e =>
                            this.controllerMessenger.call(
                              'SnapInterfaceController:deleteInterface',
                              e
                            ),
                        });
                      }
                      async getCode(e, t) {
                        const { provider: n } = this.networkController.getNetworkClientById(t);
                        return await n.request({ method: 'eth_getCode', params: [e] });
                      }
                      async _onAccountChange(e) {
                        const t = (0, vt.getPermittedAccountsByOrigin)(
                          this.permissionController.state
                        );
                        for (const [n, r] of t.entries())
                          r.includes(e) && this._notifyAccountsChange(n, r);
                        await this.txController.updateIncomingTransactions();
                      }
                      _notifyAccountsChange(e, t) {
                        this.notifyConnections(
                          e,
                          {
                            method: vt.NOTIFICATION_NAMES.accountsChanged,
                            params: t.length < 2 ? t : this.getPermittedAccounts(e),
                          },
                          un
                        ),
                          this.permissionLogController.updateAccountsHistory(e, t);
                      }
                      async _notifyAuthorizationChange(e, t) {
                        this.notifyConnections(
                          e,
                          {
                            method: se.MultichainApiNotifications.sessionChanged,
                            params: {
                              sessionScopes: (0, ae.getSessionScopes)(t, {
                                getNonEvmSupportedMethods:
                                  this.getNonEvmSupportedMethods.bind(this),
                              }),
                            },
                          },
                          hn
                        );
                      }
                      async _notifySolanaAccountChange(e, t) {
                        this.notifyConnections(
                          e,
                          {
                            method: se.MultichainApiNotifications.walletNotify,
                            params: {
                              scope: je.MultichainNetworks.SOLANA,
                              notification: {
                                method: vt.NOTIFICATION_NAMES.accountsChanged,
                                params: t,
                              },
                            },
                          },
                          hn
                        );
                      }
                      async _notifyChainChange() {
                        this.notifyAllConnections(
                          async e => ({
                            method: vt.NOTIFICATION_NAMES.chainChanged,
                            params: await this.getProviderNetworkState(e),
                          }),
                          un
                        );
                      }
                      async _notifyChainChangeForConnection(e, t) {
                        this.notifyConnection(e, {
                          method: vt.NOTIFICATION_NAMES.chainChanged,
                          params: await this.getProviderNetworkState(t),
                        });
                      }
                      async _onFinishedTransaction(e) {
                        [J.TransactionStatus.confirmed, J.TransactionStatus.failed].includes(
                          e.status
                        ) &&
                          (await this._createTransactionNotifcation(e),
                          await this._updateNFTOwnership(e),
                          this._trackTransactionFailure(e),
                          await this.tokenBalancesController.updateBalancesByChainId({
                            chainId: e.chainId,
                          }));
                      }
                      async _createTransactionNotifcation(e) {
                        const { chainId: t } = e;
                        let n = {};
                        if (t) {
                          var r, s;
                          const e =
                            null ===
                              (r = this.networkController.state.networkConfigurationsByChainId) ||
                            void 0 === r
                              ? void 0
                              : r[t];
                          n = {
                            blockExplorerUrl:
                              null == e || null === (s = e.blockExplorerUrls) || void 0 === s
                                ? void 0
                                : s[null == e ? void 0 : e.defaultBlockExplorerUrlIndex],
                          };
                        }
                        try {
                          await this.platform.showTransactionNotification(e, n);
                        } catch (e) {
                          b.default.error('Failed to create transaction notification', e);
                        }
                      }
                      async _updateNFTOwnership(e) {
                        const { type: t, txParams: n, chainId: r, txReceipt: s } = e,
                          a = this.accountsController.getSelectedAccount().address,
                          { allNfts: o } = this.nftController.state,
                          i = null == s ? void 0 : s.logs,
                          c = t === J.TransactionType.contractInteraction && i,
                          l =
                            (t === J.TransactionType.tokenMethodTransferFrom ||
                              t === J.TransactionType.tokenMethodSafeTransferFrom) &&
                            n !== undefined;
                        if (c || l)
                          if (l) {
                            var d;
                            const { data: e, to: t, from: s } = n,
                              a = (0, ke.parseStandardTokenTransactionData)(e),
                              i = (0, ve.getTokenIdParam)(a) ?? (0, _e.getTokenValueParam)(a),
                              c =
                                null == o ||
                                null === (d = o[s]) ||
                                void 0 === d ||
                                null === (d = d[r]) ||
                                void 0 === d
                                  ? void 0
                                  : d.find(
                                      ({ address: e, tokenId: n }) =>
                                        (0, Ce.isEqualCaseInsensitive)(e, t) && n === i
                                    );
                            c &&
                              this.nftController.checkAndUpdateSingleNftOwnershipStatus(c, !1, {
                                userAddress: s,
                              });
                          } else {
                            const e = i.map(e => {
                              const t =
                                  e.topics && e.topics[0] === Ne.TRANSFER_SINFLE_LOG_TOPIC_HASH,
                                n = e.topics && e.topics[0] === Ne.TOKEN_TRANSFER_LOG_TOPIC_HASH;
                              let r;
                              return (
                                t &&
                                  (r =
                                    e.topics &&
                                    e.topics[3] &&
                                    e.topics[3].match(null == a ? void 0 : a.slice(2))),
                                n &&
                                  (r =
                                    e.topics &&
                                    e.topics[2] &&
                                    e.topics[2].match(null == a ? void 0 : a.slice(2))),
                                {
                                  isERC1155NftTransfer: t,
                                  isERC721NftTransfer: n,
                                  isTransferToSelectedAddress: r,
                                  ...e,
                                }
                              );
                            });
                            if (0 !== e.length) {
                              const t = [];
                              e.forEach(e => {
                                if (
                                  e.isTransferToSelectedAddress &&
                                  (e.isERC1155NftTransfer || e.isERC721NftTransfer)
                                ) {
                                  let n;
                                  n = e.isERC1155NftTransfer
                                    ? new Y.Interface(X.abiERC1155)
                                    : new Y.Interface(X.abiERC721);
                                  try {
                                    const r = n.parseLog({ data: e.data, topics: e.topics });
                                    t.push({ contract: e.address, ...r });
                                  } catch (e) {}
                                }
                              });
                              const n = [],
                                s = [];
                              t.forEach(e => {
                                var t;
                                const i = (0, ve.getTokenIdParam)(e),
                                  c =
                                    null == o ||
                                    null === (t = o[a]) ||
                                    void 0 === t ||
                                    null === (t = t[r]) ||
                                    void 0 === t
                                      ? void 0
                                      : t.find(
                                          ({ address: t, tokenId: n }) =>
                                            (0, Ce.isEqualCaseInsensitive)(t, e.contract) && n === i
                                        );
                                c ? n.push(c) : s.push({ tokenId: i, ...e });
                              });
                              const i = n.map(async e =>
                                this.nftController.checkAndUpdateSingleNftOwnershipStatus(e, !1, {
                                  selectedAddress: a,
                                })
                              );
                              await Promise.allSettled(i);
                              const c = s.map(async e =>
                                this.nftController.addNft(e.contract, e.tokenId)
                              );
                              await Promise.allSettled(c);
                            }
                          }
                      }
                      _trackTransactionFailure(e) {
                        var t;
                        const { txReceipt: n } = e,
                          r = this.getState();
                        n &&
                          '0x0' === n.status &&
                          this.metaMetricsController.trackEvent(
                            {
                              event: 'Tx Status Update: On-Chain Failure',
                              category: be.MetaMetricsEventCategory.Background,
                              properties: {
                                action: 'Transactions',
                                errorMessage:
                                  null === (t = e.simulationFails) || void 0 === t
                                    ? void 0
                                    : t.reason,
                                numberOfTokens: r.tokens.length,
                                numberOfAccounts: Object.keys(r.accounts).length,
                              },
                            },
                            { matomoEvent: !0 }
                          );
                      }
                      _onUserOperationAdded(e) {
                        const t = this.txController.state.transactions.find(t => t.id === e.id);
                        t &&
                          (t.type === J.TransactionType.swap
                            ? this.controllerMessenger.publish(
                                'TransactionController:transactionNewSwap',
                                { transactionMeta: t }
                              )
                            : t.type === J.TransactionType.swapApproval &&
                              this.controllerMessenger.publish(
                                'TransactionController:transactionNewSwapApproval',
                                { transactionMeta: t }
                              ));
                      }
                      _onUserOperationTransactionUpdated(e) {
                        const t = {
                          ...e,
                          txParams: {
                            ...e.txParams,
                            from: this.accountsController.getSelectedAccount().address,
                          },
                        };
                        this.txController.state.transactions.some(e => e.id === t.id) ||
                          this.txController.update(e => {
                            e.transactions.push(t);
                          }),
                          this.txController.updateTransaction(t, 'Generated from user operation'),
                          this.controllerMessenger.publish(
                            'TransactionController:transactionStatusUpdated',
                            { transactionMeta: t }
                          );
                      }
                      _getMetaMaskState() {
                        return { metamask: this.getState() };
                      }
                      _getConfigForRemoteFeatureFlagRequest() {
                        return {
                          distribution: mn.flask || H.DistributionType.Main,
                          environment: pn.production || H.EnvironmentType.Development,
                        };
                      }
                    }
                    async function bn(e, t) {
                      var n, r, s, a, o;
                      const i =
                        null === (n = this.opts.overrides) || void 0 === n ? void 0 : n.keyrings;
                      let c = null;
                      switch (e.name) {
                        case ue.HardwareDeviceNames.trezor:
                          c =
                            (null == i || null === (r = i.trezor) || void 0 === r
                              ? void 0
                              : r.type) || y.TrezorKeyring.type;
                          break;
                        case ue.HardwareDeviceNames.oneKey:
                          c =
                            (null == i || null === (s = i.oneKey) || void 0 === s
                              ? void 0
                              : s.type) ||
                            (null === y.OneKeyKeyring || void 0 === y.OneKeyKeyring
                              ? void 0
                              : y.OneKeyKeyring.type);
                          break;
                        case ue.HardwareDeviceNames.ledger:
                          c =
                            (null == i || null === (a = i.ledger) || void 0 === a
                              ? void 0
                              : a.type) || w.LedgerKeyring.type;
                          break;
                        case ue.HardwareDeviceNames.qr:
                          c = k.MetaMaskKeyring.type;
                          break;
                        case ue.HardwareDeviceNames.lattice:
                          c =
                            (null == i || null === (o = i.lattice) || void 0 === o
                              ? void 0
                              : o.type) || v.default.type;
                          break;
                        default:
                          throw new Error(
                            'MetamaskController:#withKeyringForDevice - Unknown device'
                          );
                      }
                      return this.keyringController.withKeyring(
                        { type: c },
                        async ({ keyring: n }) => {
                          if (
                            (e.hdPath && n.setHdPath && n.setHdPath(e.hdPath),
                            e.name === ue.HardwareDeviceNames.lattice && (n.appName = 'MetaMask'),
                            e.name === ue.HardwareDeviceNames.trezor ||
                              e.name === ue.HardwareDeviceNames.oneKey)
                          ) {
                            const e = n.getModel();
                            this.appStateController.setTrezorModel(e);
                          }
                          return (
                            (n.network = (0, Ie.getProviderConfig)({
                              metamask: this.networkController.state,
                            }).type),
                            await t(n)
                          );
                        },
                        { createIfMissing: !0 }
                      );
                    }
                    function yn(e, t) {
                      const n = dn(fn, this, wn).call(this, t),
                        r = dn(fn, this, wn).call(this, e);
                      n !== r && this.tokenListController.updatePreventPollingOnNetworkRestart(!r);
                    }
                    function wn(e) {
                      const {
                          useTokenDetection: t,
                          useTransactionSimulations: n,
                          preferences: r,
                        } = e ?? {},
                        { petnamesEnabled: s } = r ?? {};
                      return t || s || n;
                    }
                    function vn() {
                      const e = dn(fn, this, kn).call(this);
                      return this.networkController.getNetworkClientById(e).configuration.chainId;
                    }
                    function Cn() {
                      !0 === this.preferencesController.state.useExternalServices &&
                        (this.txController.stopIncomingTransactionPolling(),
                        this.txController.startIncomingTransactionPolling());
                    }
                    function kn() {
                      return this.networkController.state.selectedNetworkClientId;
                    }
                    function Sn({ existingControllers: e, initFunctions: t, initState: n }) {
                      const r = {
                        getFlatState: this.getState.bind(this),
                        getGlobalChainId: dn(fn, this, vn).bind(this),
                        getPermittedAccounts: this.getPermittedAccounts.bind(this),
                        getProvider: () => this.provider,
                        getStateUI: this._getMetaMaskState.bind(this),
                        getTransactionMetricsRequest: this.getTransactionMetricsRequest.bind(this),
                        updateAccountBalanceForTransactionNetwork:
                          this.updateAccountBalanceForTransactionNetwork.bind(this),
                        offscreenPromise: this.offscreenPromise,
                        persistedState: n,
                        removeAllConnections: this.removeAllConnections.bind(this),
                        setupUntrustedCommunicationEip1193:
                          this.setupUntrustedCommunicationEip1193.bind(this),
                        showNotification: this.platform._showNotification,
                        getMetaMetricsId: this.metaMetricsController.getMetaMetricsId.bind(
                          this.metaMetricsController
                        ),
                        trackEvent: this.metaMetricsController.trackEvent.bind(
                          this.metaMetricsController
                        ),
                      };
                      return (0, Xt.initControllers)({
                        baseControllerMessenger: this.controllerMessenger,
                        existingControllers: e,
                        initFunctions: t,
                        initRequest: r,
                      });
                    }
                    n.default = gn;
                  }).call(this);
                }).call(this, e('buffer').Buffer);
              };
            };
      },
      { package: '$root$', file: 'app/scripts/metamask-controller.js' },
    ],
    [
      206,
      { lodash: 4921 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = void 0);
                var r = e('lodash');
                n.default = {
                  version: 2,
                  migrate(e) {
                    const t = (0, r.cloneDeep)(e);
                    t.meta.version = 2;
                    try {
                      'etherscan' === t.data.config.provider.type &&
                        ((t.data.config.provider.type = 'rpc'),
                        (t.data.config.provider.rpcTarget = 'https://rpc.metamask.io/'));
                    } catch (e) {}
                    return Promise.resolve(t);
                  },
                };
              };
            };
      },
      { package: '$root$', file: 'app/scripts/migrations/002.js' },
    ],
    [
      207,
      { lodash: 4921 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = void 0);
                var r = e('lodash');
                n.default = {
                  version: 3,
                  migrate(e) {
                    const t = (0, r.cloneDeep)(e);
                    t.meta.version = 3;
                    try {
                      'https://rawtestrpc.metamask.io/' === t.data.config.provider.rpcTarget &&
                        (t.data.config.provider.rpcTarget = 'https://testrpc.metamask.io/');
                    } catch (e) {}
                    return Promise.resolve(t);
                  },
                };
              };
            };
      },
      { package: '$root$', file: 'app/scripts/migrations/003.js' },
    ],
    [
      208,
      { lodash: 4921 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = void 0);
                var r = e('lodash');
                n.default = {
                  version: 4,
                  migrate(e) {
                    const t = (0, r.cloneDeep)(e);
                    t.meta.version = 4;
                    try {
                      if ('rpc' !== t.data.config.provider.type) return Promise.resolve(t);
                      switch (t.data.config.provider.rpcTarget) {
                        case 'https://testrpc.metamask.io/':
                          t.data.config.provider = { type: 'testnet' };
                          break;
                        case 'https://rpc.metamask.io/':
                          t.data.config.provider = { type: 'mainnet' };
                      }
                    } catch (e) {}
                    return Promise.resolve(t);
                  },
                };
              };
            };
      },
      { package: '$root$', file: 'app/scripts/migrations/004.js' },
    ],
    [
      209,
      { lodash: 4921 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = void 0);
                var r = e('lodash');
                n.default = {
                  version: 5,
                  migrate(e) {
                    const t = (0, r.cloneDeep)(e);
                    t.meta.version = 5;
                    try {
                      const e = (function (e) {
                        const { config: t } = e,
                          n = {
                            ...e,
                            KeyringController: {
                              vault: e.vault,
                              selectedAccount: t.selectedAccount,
                              walletNicknames: e.walletNicknames,
                            },
                          };
                        return (
                          delete n.vault,
                          delete n.walletNicknames,
                          delete n.config.selectedAccount,
                          n
                        );
                      })(t.data);
                      t.data = e;
                    } catch (e) {
                      console.warn(`MetaMask Migration #5${e.stack}`);
                    }
                    return Promise.resolve(t);
                  },
                };
              };
            };
      },
      { package: '$root$', file: 'app/scripts/migrations/005.js' },
    ],
    [
      21,
      {},
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.getAssetsContractControllerMessenger = function (e) {
                    return e.getRestricted({
                      name: 'AssetsContractController',
                      allowedActions: [
                        'NetworkController:getNetworkClientById',
                        'NetworkController:getNetworkConfigurationByNetworkClientId',
                        'NetworkController:getSelectedNetworkClient',
                        'NetworkController:getState',
                      ],
                      allowedEvents: [
                        'PreferencesController:stateChange',
                        'NetworkController:networkDidChange',
                      ],
                    });
                  });
              };
            };
      },
      {
        package: '$root$',
        file: 'app/scripts/controller-init/messengers/assets/assets-contract-controller-messenger.ts',
      },
    ],
    [
      210,
      { lodash: 4921 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = void 0);
                var r = e('lodash');
                n.default = {
                  version: 6,
                  migrate(e) {
                    const t = (0, r.cloneDeep)(e);
                    t.meta.version = 6;
                    try {
                      const e = (function (e) {
                        const t = e.KeyringController,
                          n = {
                            ...e,
                            PreferencesController: { selectedAddress: t.selectedAccount },
                          };
                        return delete n.KeyringController.selectedAccount, n;
                      })(t.data);
                      t.data = e;
                    } catch (e) {
                      console.warn(`MetaMask Migration #6${e.stack}`);
                    }
                    return Promise.resolve(t);
                  },
                };
              };
            };
      },
      { package: '$root$', file: 'app/scripts/migrations/006.js' },
    ],
    [
      2102,
      { '@metamask/base-controller': 1407, events: 4465, uuid: 5733 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.AbstractMessageManager = void 0);
                const r = e('@metamask/base-controller'),
                  s = e('events'),
                  a = e('uuid'),
                  o = {
                    unapprovedMessages: { persist: !1, anonymous: !1 },
                    unapprovedMessagesCount: { persist: !1, anonymous: !1 },
                  };
                class i extends r.BaseController {
                  constructor({
                    additionalFinishStatuses: e,
                    messenger: t,
                    name: n,
                    securityProviderRequest: r,
                    state: a = {},
                  }) {
                    super({
                      messenger: t,
                      metadata: o,
                      name: n,
                      state: { unapprovedMessages: {}, unapprovedMessagesCount: 0, ...a },
                    }),
                      (this.internalEvents = new s.EventEmitter()),
                      (this.messages = []),
                      (this.securityProviderRequest = r),
                      (this.additionalFinishStatuses = e ?? []);
                  }
                  addRequestToMessageParams(e, t) {
                    const n = { ...e };
                    return t && ((n.requestId = t.id), (n.origin = t.origin)), n;
                  }
                  createUnapprovedMessage(e, t, n) {
                    return {
                      id: (0, a.v1)(),
                      messageParams: e,
                      securityAlertResponse: n?.securityAlertResponse,
                      status: 'unapproved',
                      time: Date.now(),
                      type: t,
                    };
                  }
                  saveMessageList(e = !0) {
                    this.update(e => {
                      (e.unapprovedMessages = this.getUnapprovedMessages()),
                        (e.unapprovedMessagesCount = this.getUnapprovedMessagesCount());
                    }),
                      e && this.messagingSystem.publish(`${this.name}:updateBadge`);
                  }
                  setMessageStatus(e, t) {
                    const n = this.getMessage(e);
                    if (!n) throw new Error(`${this.name}: Message not found for id: ${e}.`);
                    const r = { ...n, status: t };
                    this.updateMessage(r),
                      this.internalEvents.emit(`${e}:${t}`, r),
                      ('rejected' === t ||
                        'signed' === t ||
                        'errored' === t ||
                        this.additionalFinishStatuses.includes(t)) &&
                        this.internalEvents.emit(`${e}:finished`, r);
                  }
                  updateMessage(e, t = !0) {
                    const n = this.messages.findIndex(t => e.id === t.id);
                    -1 !== n && (this.messages[n] = e), this.saveMessageList(t);
                  }
                  async securityCheck(e) {
                    if (this.securityProviderRequest) {
                      const t = await this.securityProviderRequest(e, e.type);
                      return { ...e, securityProviderResponse: t };
                    }
                    return e;
                  }
                  clearUnapprovedMessages() {
                    this.update(e => {
                      (e.unapprovedMessages = {}), (e.unapprovedMessagesCount = 0);
                    });
                  }
                  getUnapprovedMessagesCount() {
                    return Object.keys(this.getUnapprovedMessages()).length;
                  }
                  getUnapprovedMessages() {
                    return this.messages
                      .filter(e => 'unapproved' === e.status)
                      .reduce((e, t) => ((e[t.id] = t), e), {});
                  }
                  async addMessage(e) {
                    const t = await this.securityCheck(e);
                    this.messages.push(t), this.saveMessageList();
                  }
                  getMessage(e) {
                    return this.messages.find(t => t.id === e);
                  }
                  getAllMessages() {
                    return this.messages;
                  }
                  approveMessage(e) {
                    return (
                      this.setMessageStatusApproved(e.metamaskId), this.prepMessageForSigning(e)
                    );
                  }
                  setMessageStatusApproved(e) {
                    this.setMessageStatus(e, 'approved');
                  }
                  setMessageStatusInProgress(e) {
                    this.setMessageStatus(e, 'inProgress');
                  }
                  setMessageStatusSigned(e, t) {
                    this.setMessageStatusAndResult(e, t, 'signed');
                  }
                  setMessageStatusAndResult(e, t, n) {
                    this.setResult(e, t), this.setMessageStatus(e, n);
                  }
                  setResult(e, t) {
                    const n = this.getMessage(e);
                    n && this.updateMessage({ ...n, rawSig: t }, !1);
                  }
                  setMetadata(e, t) {
                    const n = this.getMessage(e);
                    if (!n) throw new Error(`${this.name}: Message not found for id: ${e}.`);
                    this.updateMessage({ ...n, metadata: t }, !1);
                  }
                  rejectMessage(e) {
                    this.setMessageStatus(e, 'rejected');
                  }
                  async waitForFinishStatus(e, t) {
                    const { metamaskId: n, ...r } = e;
                    return new Promise((e, s) => {
                      this.internalEvents.once(`${n}:finished`, n => {
                        switch (n.status) {
                          case 'signed':
                            return e(n.rawSig);
                          case 'rejected':
                            return s(
                              new Error(`MetaMask ${t} Signature: User denied message signature.`)
                            );
                          case 'errored':
                            return s(new Error(`MetaMask ${t} Signature: ${n.error}`));
                          default:
                            return s(
                              new Error(
                                `MetaMask ${t} Signature: Unknown problem: ${JSON.stringify(r)}`
                              )
                            );
                        }
                      });
                    });
                  }
                }
                (n.AbstractMessageManager = i), (n.default = i);
              };
            };
      },
      {
        package: '@metamask/message-manager',
        file: 'node_modules/@metamask/message-manager/dist/AbstractMessageManager.cjs',
      },
    ],
    [
      2103,
      {
        './AbstractMessageManager.cjs': 2102,
        './utils.cjs': 2107,
        '@metamask/controller-utils': 1515,
      },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.DecryptMessageManager = void 0);
                const r = e('@metamask/controller-utils'),
                  s = e('./AbstractMessageManager.cjs'),
                  a = e('./utils.cjs'),
                  o = 'DecryptMessageManager';
                class i extends s.AbstractMessageManager {
                  constructor({
                    additionalFinishStatuses: e,
                    messenger: t,
                    securityProviderRequest: n,
                    state: r,
                  }) {
                    super({
                      additionalFinishStatuses: e,
                      messenger: t,
                      name: o,
                      securityProviderRequest: n,
                      state: r,
                    });
                  }
                  async addUnapprovedMessageAsync(e, t) {
                    (0, a.validateDecryptedMessageData)(e);
                    const n = await this.addUnapprovedMessage(e, t);
                    return new Promise((t, r) => {
                      this.internalEvents.once(`${n}:finished`, n => {
                        switch (n.status) {
                          case 'decrypted':
                            return t(n.rawSig);
                          case 'rejected':
                            return r(
                              new Error('MetaMask DecryptMessage: User denied message decryption.')
                            );
                          case 'errored':
                            return r(
                              new Error(
                                'MetaMask DecryptMessage: This message cannot be decrypted.'
                              )
                            );
                          default:
                            return r(
                              new Error(
                                `MetaMask DecryptMessage: Unknown problem: ${JSON.stringify(e)}`
                              )
                            );
                        }
                      });
                    });
                  }
                  async addUnapprovedMessage(e, t) {
                    const n = this.addRequestToMessageParams(e, t);
                    e.data = (0, a.normalizeMessageData)(e.data);
                    const s = this.createUnapprovedMessage(n, r.ApprovalType.EthDecrypt, t),
                      i = s.id;
                    return (
                      await this.addMessage(s),
                      this.messagingSystem.publish(`${o}:unapprovedMessage`, {
                        ...n,
                        metamaskId: i,
                      }),
                      i
                    );
                  }
                  prepMessageForSigning(e) {
                    return delete e.metamaskId, Promise.resolve(e);
                  }
                }
                n.DecryptMessageManager = i;
              };
            };
      },
      {
        package: '@metamask/message-manager',
        file: 'node_modules/@metamask/message-manager/dist/DecryptMessageManager.cjs',
      },
    ],
    [
      2104,
      {
        './AbstractMessageManager.cjs': 2102,
        './utils.cjs': 2107,
        '@metamask/controller-utils': 1515,
      },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.EncryptionPublicKeyManager = void 0);
                const r = e('@metamask/controller-utils'),
                  s = e('./AbstractMessageManager.cjs'),
                  a = e('./utils.cjs');
                class o extends s.AbstractMessageManager {
                  constructor({
                    additionalFinishStatuses: e,
                    messenger: t,
                    securityProviderRequest: n,
                    state: r,
                  }) {
                    super({
                      additionalFinishStatuses: e,
                      messenger: t,
                      name: 'EncryptionPublicKeyManager',
                      securityProviderRequest: n,
                      state: r,
                    });
                  }
                  async addUnapprovedMessageAsync(e, t) {
                    (0, a.validateEncryptionPublicKeyMessageData)(e);
                    const n = await this.addUnapprovedMessage(e, t);
                    return new Promise((t, r) => {
                      this.internalEvents.once(`${n}:finished`, n => {
                        switch (n.status) {
                          case 'received':
                            return t(n.rawSig);
                          case 'rejected':
                            return r(
                              new Error(
                                'MetaMask EncryptionPublicKey: User denied message EncryptionPublicKey.'
                              )
                            );
                          default:
                            return r(
                              new Error(
                                `MetaMask EncryptionPublicKey: Unknown problem: ${JSON.stringify(e)}`
                              )
                            );
                        }
                      });
                    });
                  }
                  async addUnapprovedMessage(e, t) {
                    const n = this.addRequestToMessageParams(e, t),
                      s = this.createUnapprovedMessage(
                        n,
                        r.ApprovalType.EthGetEncryptionPublicKey,
                        t
                      ),
                      a = s.id;
                    return (
                      await this.addMessage(s),
                      this.messagingSystem.publish(`${this.name}:unapprovedMessage`, {
                        ...n,
                        metamaskId: a,
                      }),
                      a
                    );
                  }
                  prepMessageForSigning(e) {
                    return delete e.metamaskId, Promise.resolve({ from: e.data });
                  }
                }
                (n.EncryptionPublicKeyManager = o), (n.default = o);
              };
            };
      },
      {
        package: '@metamask/message-manager',
        file: 'node_modules/@metamask/message-manager/dist/EncryptionPublicKeyManager.cjs',
      },
    ],
    [
      2105,
      {
        './AbstractMessageManager.cjs': 2102,
        './DecryptMessageManager.cjs': 2103,
        './EncryptionPublicKeyManager.cjs': 2104,
        './types.cjs': 2106,
      },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                var r =
                    (this && this.__createBinding) ||
                    (Object.create
                      ? function (e, t, n, r) {
                          r === undefined && (r = n);
                          var s = Object.getOwnPropertyDescriptor(t, n);
                          (s && !('get' in s ? !t.__esModule : s.writable || s.configurable)) ||
                            (s = {
                              enumerable: !0,
                              get: function () {
                                return t[n];
                              },
                            }),
                            Object.defineProperty(e, r, s);
                        }
                      : function (e, t, n, r) {
                          r === undefined && (r = n), (e[r] = t[n]);
                        }),
                  s =
                    (this && this.__exportStar) ||
                    function (e, t) {
                      for (var n in e)
                        'default' === n || Object.prototype.hasOwnProperty.call(t, n) || r(t, e, n);
                    };
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  s(e('./AbstractMessageManager.cjs'), n),
                  s(e('./EncryptionPublicKeyManager.cjs'), n),
                  s(e('./DecryptMessageManager.cjs'), n),
                  s(e('./types.cjs'), n);
              };
            };
      },
      {
        package: '@metamask/message-manager',
        file: 'node_modules/@metamask/message-manager/dist/index.cjs',
      },
    ],
    [
      2106,
      {},
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 });
              };
            };
      },
      {
        package: '@metamask/message-manager',
        file: 'node_modules/@metamask/message-manager/dist/types.cjs',
      },
    ],
    [
      2107,
      { '@metamask/controller-utils': 1515, '@metamask/utils': 2995, buffer: 4139 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                (function (t) {
                  (function () {
                    Object.defineProperty(n, '__esModule', { value: !0 }),
                      (n.validateDecryptedMessageData =
                        n.validateEncryptionPublicKeyMessageData =
                        n.normalizeMessageData =
                          void 0);
                    const r = e('@metamask/controller-utils'),
                      s = e('@metamask/utils'),
                      a = /^[0-9A-Fa-f]+$/gu;
                    function o(e, t) {
                      if (!e || 'string' != typeof e || !(0, r.isValidHexAddress)(e))
                        throw new Error(`Invalid "${t}" address: ${e} must be a valid string.`);
                    }
                    (n.normalizeMessageData = function (e) {
                      try {
                        const t = (0, s.remove0x)(e);
                        if (t.match(a)) return (0, s.add0x)(t);
                      } catch (e) {}
                      return (0, s.bytesToHex)(t.from(e, 'utf8'));
                    }),
                      (n.validateEncryptionPublicKeyMessageData = function (e) {
                        const { from: t } = e;
                        o(t, 'from');
                      }),
                      (n.validateDecryptedMessageData = function (e) {
                        const { from: t } = e;
                        o(t, 'from');
                      });
                  }).call(this);
                }).call(this, e('buffer').Buffer);
              };
            };
      },
      {
        package: '@metamask/message-manager',
        file: 'node_modules/@metamask/message-manager/dist/utils.cjs',
      },
    ],
    [
      2108,
      {},
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                t.exports = {
                  snapId: 'npm:@metamask/message-signing-snap',
                  manifest: {
                    version: '0.6.0',
                    description:
                      'Provides public key and message signing used for signing in with MetaMask',
                    proposedName: 'Sign in with MetaMask',
                    repository: {
                      type: 'git',
                      url: 'https://github.com/MetaMask/message-signing-snap.git',
                    },
                    source: {
                      shasum: 'MVxPWtAZ1Sdw63kwfZswKlYQ6dddnr7vvbj4V7j/Fc4=',
                      location: {
                        npm: {
                          filePath: 'dist/bundle.js',
                          iconPath: 'images/icon.svg',
                          packageName: '@metamask/message-signing-snap',
                          registry: 'https://registry.npmjs.org/',
                        },
                      },
                    },
                    initialConnections: {
                      'https://portfolio.metamask.io': {},
                      'https://portfolio-builds.metafi-dev.codefi.network': {},
                      'https://docs.metamask.io': {},
                      'https://developer.metamask.io': {},
                    },
                    initialPermissions: {
                      snap_getEntropy: {},
                      'endowment:rpc': { dapps: !0, snaps: !1 },
                    },
                    manifestVersion: '0.1',
                  },
                  files: [
                    {
                      path: 'images/icon.svg',
                      value:
                        '<svg width="500" height="500" viewBox="0 0 500 500" fill="none" xmlns="http://www.w3.org/2000/svg">\n<rect width="500" height="500" fill="black"/>\n<g filter="url(#filter0_f_8_91)">\n<path d="M249.444 373.519C249.444 373.519 364.118 343.192 364.118 257.188L378.333 248.251L364.118 239.314L378.333 230.378L364.118 221.441V203.568V185.695V149.948V114.202L301.639 132.596C267.566 142.628 231.323 142.628 197.25 132.596L134.771 114.202V149.948V167.821V185.695V203.568V221.441L120.556 230.378L134.771 239.314L120.556 248.251L134.771 257.188C134.771 343.192 249.444 373.519 249.444 373.519Z" fill="#F1CA77"/>\n</g>\n<path d="M249.445 406.215C249.445 406.215 364.118 348.879 364.118 262.874L378.333 253.937L364.118 245.001L378.333 236.064L364.118 227.127V209.254V191.381V155.634V119.888L249.445 162.179L134.771 119.888V155.634V173.508V191.381V209.254V227.127L120.556 236.064L134.771 245.001L120.556 253.937L134.771 262.874C134.771 348.879 249.445 406.215 249.445 406.215Z" fill="#233447"/>\n<path d="M249.445 399.107C249.445 399.107 364.118 348.879 364.118 262.874L378.333 253.937L364.118 245.001L378.333 236.064L364.118 227.127V209.254V191.381V155.634V119.888L249.445 162.179L134.771 119.888V155.634V173.508V191.381V209.254V227.127L120.556 236.064L134.771 245.001L120.556 253.937L134.771 262.874C134.771 348.879 249.445 399.107 249.445 399.107Z" fill="#123AF0"/>\n<path d="M249.445 392C249.445 392 364.118 348.879 364.118 262.874L378.333 253.937L364.118 245.001L378.333 236.064L364.118 227.127V209.254V191.381V155.634V119.888L249.445 162.179L134.771 119.888V155.634V173.508V191.381V209.254V227.127L120.556 236.064L134.771 245.001L120.556 253.937L134.771 262.874C134.771 348.879 249.445 392 249.445 392Z" fill="#CD6116"/>\n<path d="M249.445 382.049C249.445 382.049 364.118 348.879 364.118 262.874L378.333 253.937L364.118 245.001L378.333 236.064L364.118 227.127V209.254V191.381V155.634V119.888L249.445 162.179L134.771 119.888V155.634V173.508V191.381V209.254V227.127L120.556 236.064L134.771 245.001L120.556 253.937L134.771 262.874C134.771 348.879 249.445 382.049 249.445 382.049Z" fill="#E4751F"/>\n<path d="M249.445 370.676C249.445 370.676 364.118 348.879 364.118 262.874L378.333 253.937L364.118 245.001L378.333 236.064L364.118 227.127V209.254V191.381V155.634V119.888L249.445 162.179L134.771 119.888V155.634V173.508V191.381V209.254V227.127L120.556 236.064L134.771 245.001L120.556 253.937L134.771 262.874C134.771 348.879 249.445 370.676 249.445 370.676Z" fill="#F6851B"/>\n<path d="M249.445 352.196C249.445 352.196 364.118 348.879 364.118 262.874L378.333 253.937L364.118 245.001L378.333 236.064L364.118 227.127V209.254V191.381V155.634V119.888C290.105 147.184 208.784 147.184 134.771 119.888V155.634V173.508V191.381V209.254V227.127L120.556 236.064L134.771 245.001L120.556 253.937L134.771 262.874C134.771 348.879 249.445 352.196 249.445 352.196Z" fill="url(#paint0_linear_8_91)"/>\n<defs>\n<filter id="filter0_f_8_91" x="94.9674" y="88.6133" width="308.954" height="310.494" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">\n<feFlood flood-opacity="0" result="BackgroundImageFix"/>\n<feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>\n<feGaussianBlur stdDeviation="12.7941" result="effect1_foregroundBlur_8_91"/>\n</filter>\n<linearGradient id="paint0_linear_8_91" x1="144.012" y1="132.09" x2="425.482" y2="446.967" gradientUnits="userSpaceOnUse">\n<stop stop-color="#F1CA77"/>\n<stop offset="1" stop-color="#F6851B"/>\n</linearGradient>\n</defs>\n</svg>\n',
                    },
                    {
                      path: 'dist/bundle.js',
                      value:
                        '(()=>{var e={463:e=>{e.exports=a,a.default=a,a.stable=u,a.stableStringify=u;var t="[...]",n="[Circular]",r=[],s=[];function i(){return{depthLimit:Number.MAX_SAFE_INTEGER,edgesLimit:Number.MAX_SAFE_INTEGER}}function a(e,t,n,a){var o;void 0===a&&(a=i()),c(e,"",0,[],void 0,0,a);try{o=0===s.length?JSON.stringify(e,t,n):JSON.stringify(e,h(t),n)}catch(e){return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]")}finally{for(;0!==r.length;){var d=r.pop();4===d.length?Object.defineProperty(d[0],d[1],d[3]):d[0][d[1]]=d[2]}}return o}function o(e,t,n,i){var a=Object.getOwnPropertyDescriptor(i,n);void 0!==a.get?a.configurable?(Object.defineProperty(i,n,{value:e}),r.push([i,n,t,a])):s.push([t,n,e]):(i[n]=e,r.push([i,n,t]))}function c(e,r,s,i,a,d,u){var l;if(d+=1,"object"==typeof e&&null!==e){for(l=0;l<i.length;l++)if(i[l]===e)return void o(n,e,r,a);if(void 0!==u.depthLimit&&d>u.depthLimit)return void o(t,e,r,a);if(void 0!==u.edgesLimit&&s+1>u.edgesLimit)return void o(t,e,r,a);if(i.push(e),Array.isArray(e))for(l=0;l<e.length;l++)c(e[l],l,l,i,e,d,u);else{var h=Object.keys(e);for(l=0;l<h.length;l++){var f=h[l];c(e[f],f,l,i,e,d,u)}}i.pop()}}function d(e,t){return e<t?-1:e>t?1:0}function u(e,t,n,a){void 0===a&&(a=i());var o,c=l(e,"",0,[],void 0,0,a)||e;try{o=0===s.length?JSON.stringify(c,t,n):JSON.stringify(c,h(t),n)}catch(e){return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]")}finally{for(;0!==r.length;){var d=r.pop();4===d.length?Object.defineProperty(d[0],d[1],d[3]):d[0][d[1]]=d[2]}}return o}function l(e,s,i,a,c,u,h){var f;if(u+=1,"object"==typeof e&&null!==e){for(f=0;f<a.length;f++)if(a[f]===e)return void o(n,e,s,c);try{if("function"==typeof e.toJSON)return}catch(e){return}if(void 0!==h.depthLimit&&u>h.depthLimit)return void o(t,e,s,c);if(void 0!==h.edgesLimit&&i+1>h.edgesLimit)return void o(t,e,s,c);if(a.push(e),Array.isArray(e))for(f=0;f<e.length;f++)l(e[f],f,f,a,e,u,h);else{var p={},m=Object.keys(e).sort(d);for(f=0;f<m.length;f++){var g=m[f];l(e[g],g,f,a,e,u,h),p[g]=e[g]}if(void 0===c)return p;r.push([c,s,e]),c[s]=p}a.pop()}}function h(e){return e=void 0!==e?e:function(e,t){return t},function(t,n){if(s.length>0)for(var r=0;r<s.length;r++){var i=s[r];if(i[1]===t&&i[0]===n){n=i[2],s.splice(r,1);break}}return e.call(this,t,n)}}}},t={};function n(r){var s=t[r];if(void 0!==s)return s.exports;var i=t[r]={exports:{}};return e[r](i,i.exports,n),i.exports}n.d=(e,t)=>{for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var r={};(()=>{"use strict";n.r(r),n.d(r,{onRpcRequest:()=>Fs});var e={};function t(e){return Boolean(e)&&"object"==typeof e&&!Array.isArray(e)}n.r(e),n.d(e,{aK:()=>hr,e8:()=>Gn,DO:()=>Jn,dJ:()=>fr,OG:()=>pr,My:()=>Xn,Ph:()=>sr,lX:()=>ir,Id:()=>dr,fg:()=>yr,qj:()=>cr,aT:()=>rr,r4:()=>lr,aY:()=>Wn,x:()=>_r,lq:()=>ar,z:()=>or,zW:()=>Qn,Q5:()=>wr});const s=(e,t)=>Object.hasOwnProperty.call(e,t);var i;!function(e){e[e.Null=4]="Null",e[e.Comma=1]="Comma",e[e.Wrapper=1]="Wrapper",e[e.True=4]="True",e[e.False=5]="False",e[e.Quote=1]="Quote",e[e.Colon=1]="Colon",e[e.Date=24]="Date"}(i=i||(i={}));var a=n(463);class o extends TypeError{constructor(e,t){let n;const{message:r,explanation:s,...i}=e,{path:a}=e,o=0===a.length?r:`At path: ${a.join(".")} -- ${r}`;super(s??o),null!=s&&(this.cause=o),Object.assign(this,i),this.name=this.constructor.name,this.failures=()=>n??(n=[e,...t()])}}function c(e){return"object"==typeof e&&null!==e}function d(e){return"symbol"==typeof e?e.toString():"string"==typeof e?JSON.stringify(e):`${e}`}function u(e,t,n,r){if(!0===e)return;!1===e?e={}:"string"==typeof e&&(e={message:e});const{path:s,branch:i}=t,{type:a}=n,{refinement:o,message:c=`Expected a value of type \\`${a}\\`${o?` with refinement \\`${o}\\``:""}, but received: \\`${d(r)}\\``}=e;return{value:r,type:a,refinement:o,key:s[s.length-1],path:s,branch:i,...e,message:c}}function*l(e,t,n,r){(function(e){return c(e)&&"function"==typeof e[Symbol.iterator]})(e)||(e=[e]);for(const s of e){const e=u(s,t,n,r);e&&(yield e)}}function*h(e,t,n={}){const{path:r=[],branch:s=[e],coerce:i=!1,mask:a=!1}=n,o={path:r,branch:s};if(i&&(e=t.coercer(e,o),a&&"type"!==t.type&&c(t.schema)&&c(e)&&!Array.isArray(e)))for(const n in e)void 0===t.schema[n]&&delete e[n];let d="valid";for(const r of t.validator(e,o))r.explanation=n.message,d="not_valid",yield[r,void 0];for(let[u,l,f]of t.entries(e,o)){const t=h(l,f,{path:void 0===u?r:[...r,u],branch:void 0===u?s:[...s,l],coerce:i,mask:a,message:n.message});for(const n of t)n[0]?(d=null===n[0].refinement||void 0===n[0].refinement?"not_valid":"not_refined",yield[n[0],void 0]):i&&(l=n[1],void 0===u?e=l:e instanceof Map?e.set(u,l):e instanceof Set?e.add(l):c(e)&&(void 0!==l||u in e)&&(e[u]=l))}if("not_valid"!==d)for(const r of t.refiner(e,o))r.explanation=n.message,d="not_refined",yield[r,void 0];"valid"===d&&(yield[void 0,e])}class f{constructor(e){const{type:t,schema:n,validator:r,refiner:s,coercer:i=e=>e,entries:a=function*(){}}=e;this.type=t,this.schema=n,this.entries=a,this.coercer=i,this.validator=r?(e,t)=>l(r(e,t),t,this,e):()=>[],this.refiner=s?(e,t)=>l(s(e,t),t,this,e):()=>[]}assert(e,t){return p(e,this,t)}create(e,t){return m(e,this,t)}is(e){return g(e,this)}mask(e,t){return function(e,t,n){const r=y(e,t,{coerce:!0,mask:!0,message:n});if(r[0])throw r[0];return r[1]}(e,this,t)}validate(e,t={}){return y(e,this,t)}}function p(e,t,n){const r=y(e,t,{message:n});if(r[0])throw r[0]}function m(e,t,n){const r=y(e,t,{coerce:!0,message:n});if(r[0])throw r[0];return r[1]}function g(e,t){return!y(e,t)[0]}function y(e,t,n={}){const r=h(e,t,n),s=function(e){const{done:t,value:n}=e.next();return t?void 0:n}(r);if(s[0]){return[new o(s[0],(function*(){for(const e of r)e[0]&&(yield e[0])})),void 0]}return[void 0,s[1]]}function v(e,t){return new f({type:e,schema:null,validator:t})}function w(e){let t;return new f({type:"lazy",schema:null,*entries(n,r){t??(t=e()),yield*t.entries(n,r)},validator:(n,r)=>(t??(t=e()),t.validator(n,r)),coercer:(n,r)=>(t??(t=e()),t.coercer(n,r)),refiner:(n,r)=>(t??(t=e()),t.refiner(n,r))})}function _(e){return new f({type:"array",schema:e,*entries(t){if(e&&Array.isArray(t))for(const[n,r]of t.entries())yield[n,r,e]},coercer:e=>Array.isArray(e)?e.slice():e,validator:e=>Array.isArray(e)||`Expected an array value, but received: ${d(e)}`})}function b(e){const t=d(e),n=typeof e;return new f({type:"literal",schema:"string"===n||"number"===n||"boolean"===n?e:null,validator:n=>n===e||`Expected the literal \\`${t}\\`, but received: ${d(n)}`})}function x(){return v("never",(()=>!1))}function E(){return v("number",(e=>"number"==typeof e&&!isNaN(e)||`Expected a number, but received: ${d(e)}`))}function k(e){const t=e?Object.keys(e):[],n=x();return new f({type:"object",schema:e??null,*entries(r){if(e&&c(r)){const s=new Set(Object.keys(r));for(const n of t)s.delete(n),yield[n,r[n],e[n]];for(const e of s)yield[e,r[e],n]}},validator:e=>c(e)||`Expected an object, but received: ${d(e)}`,coercer:e=>c(e)?{...e}:e})}function O(e){return new f({...e,validator:(t,n)=>void 0===t||e.validator(t,n),refiner:(t,n)=>void 0===t||e.refiner(t,n)})}function S(e,t){return new f({type:"record",schema:null,*entries(n){if(c(n))for(const r in n){const s=n[r];yield[r,r,e],yield[r,s,t]}},validator:e=>c(e)||`Expected an object, but received: ${d(e)}`})}function A(){return v("string",(e=>"string"==typeof e||`Expected a string, but received: ${d(e)}`))}function N(e){const t=e.map((e=>e.type)).join(" | ");return new f({type:"union",schema:null,coercer(t){for(const n of e){const[e,r]=n.validate(t,{coerce:!0});if(!e)return r}return t},validator(n,r){const s=[];for(const t of e){const[...e]=h(n,t,r),[i]=e;if(!i?.[0])return[];for(const[t]of e)t&&s.push(t)}return[`Expected the value to satisfy a union of \\`${t}\\`, but received: ${d(n)}`,...s]}})}function T(e,t,n){return new f({...e,coercer:(r,s)=>g(r,t)?e.coercer(n(r,s),s):e.coercer(r,s)})}Error;function Z(e){return function(e){return function(e){return"object"==typeof e&&null!==e&&"message"in e}(e)&&"string"==typeof e.message?e.message:null==e?"":String(e)}(e).replace(/\\.$/u,"")}function I(e,t){return n=e,Boolean("string"==typeof n?.prototype?.constructor?.name)?new e({message:t}):e({message:t});var n}class B extends Error{constructor(e){super(e.message),this.code="ERR_ASSERTION"}}const C=e=>k(e);function j({path:e,branch:t}){const n=e[e.length-1];return s(t[t.length-2],n)}function R(e){return new f({...e,type:`optional ${e.type}`,validator:(t,n)=>!j(n)||e.validator(t,n),refiner:(t,n)=>!j(n)||e.refiner(t,n)})}const P=N([b(null),v("boolean",(e=>"boolean"==typeof e)),v("finite number",(e=>g(e,E())&&Number.isFinite(e))),A(),_(w((()=>P))),S(A(),w((()=>P)))]),L=T(P,v("any",(()=>!0)),(e=>(function(e,t,n="Assertion failed",r=B){try{p(e,t)}catch(e){throw I(r,`${n}: ${Z(e)}.`)}}(e,P),JSON.parse(JSON.stringify(e,((e,t)=>{if("__proto__"!==e&&"constructor"!==e)return t}))))));function U(e){try{return function(e){m(e,L)}(e),!0}catch{return!1}}const $=b("2.0"),M=(z=N([E(),A()]),new f({...z,validator:(e,t)=>null===e||z.validator(e,t),refiner:(e,t)=>null===e||z.refiner(e,t)}));var z;const q=C({code:v("integer",(e=>"number"==typeof e&&!isNaN(e)&&Number.isInteger(e)||`Expected an integer, but received: ${d(e)}`)),message:A(),data:R(L),stack:R(A())}),D=N([S(A(),L),_(L)]);C({id:M,jsonrpc:$,method:A(),params:R(D)}),C({jsonrpc:$,method:A(),params:R(D)});k({id:M,jsonrpc:$,result:O(v("unknown",(()=>!0))),error:O(q)});const F=C({id:M,jsonrpc:$,result:L}),V=C({id:M,jsonrpc:$,error:q});N([F,V]);const H={invalidInput:-32e3,resourceNotFound:-32001,resourceUnavailable:-32002,transactionRejected:-32003,methodNotSupported:-32004,limitExceeded:-32005,parse:-32700,invalidRequest:-32600,methodNotFound:-32601,invalidParams:-32602,internal:-32603},K={"-32700":{standard:"JSON RPC 2.0",message:"Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."},"-32600":{standard:"JSON RPC 2.0",message:"The JSON sent is not a valid Request object."},"-32601":{standard:"JSON RPC 2.0",message:"The method does not exist / is not available."},"-32602":{standard:"JSON RPC 2.0",message:"Invalid method parameter(s)."},"-32603":{standard:"JSON RPC 2.0",message:"Internal JSON-RPC error."},"-32000":{standard:"EIP-1474",message:"Invalid input."},"-32001":{standard:"EIP-1474",message:"Resource not found."},"-32002":{standard:"EIP-1474",message:"Resource unavailable."},"-32003":{standard:"EIP-1474",message:"Transaction rejected."},"-32004":{standard:"EIP-1474",message:"Method not supported."},"-32005":{standard:"EIP-1474",message:"Request limit exceeded."},4001:{standard:"EIP-1193",message:"User rejected the request."},4100:{standard:"EIP-1193",message:"The requested account and/or method has not been authorized by the user."},4200:{standard:"EIP-1193",message:"The requested method is not supported by this Ethereum provider."},4900:{standard:"EIP-1193",message:"The provider is disconnected from all chains."},4901:{standard:"EIP-1193",message:"The provider is disconnected from the specified chain."}},W=H.internal,J=(G(W),"Unspecified server error.");function G(e,t="Unspecified error message. This is a bug, please report it."){if(function(e){return Number.isInteger(e)}(e)){const t=e.toString();if(s(K,t))return K[t].message;if(function(e){return e>=-32099&&e<=-32e3}(e))return J}return t}function Y(e){return Array.isArray(e)?e.map((e=>U(e)?e:t(e)?X(e):null)):t(e)?X(e):U(e)?e:null}function X(e){return Object.getOwnPropertyNames(e).reduce(((t,n)=>{const r=e[n];return U(r)&&(t[n]=r),t}),{})}const Q=(ee=a,ee?.__esModule?ee.default:ee);var ee;class te extends Error{constructor(e,n,r){if(!Number.isInteger(e))throw new Error(\'"code" must be an integer.\');if(!n||"string"!=typeof n)throw new Error(\'"message" must be a non-empty string.\');!function(e){return t(e)&&s(e,"cause")&&t(e.cause)}(r)?super(n):(super(n,{cause:r.cause}),s(this,"cause")||Object.assign(this,{cause:r.cause})),void 0!==r&&(this.data=r),this.code=e}serialize(){const e={code:this.code,message:this.message};return void 0!==this.data&&(e.data=this.data,function(e){if("object"!=typeof e||null===e)return!1;try{let t=e;for(;null!==Object.getPrototypeOf(t);)t=Object.getPrototypeOf(t);return Object.getPrototypeOf(e)===t}catch(e){return!1}}(this.data)&&(e.data.cause=Y(this.data.cause))),this.stack&&(e.stack=this.stack),e}toString(){return Q(this.serialize(),ne,2)}}function ne(e,t){if("[Circular]"!==t)return t}const re=e=>ie(H.invalidParams,e),se=e=>ie(H.methodNotFound,e);function ie(e,t){const[n,r]=ae(t);return new te(e,n??G(e),r)}function ae(e){if(e){if("string"==typeof e)return[e];if("object"==typeof e&&!Array.isArray(e)){const{message:t,data:n}=e;if(t&&"string"!=typeof t)throw new Error("Must specify string message.");return[t??void 0,n]}}return[]}var oe,ce;!function(e){e.assertEqual=e=>e,e.assertIs=function(e){},e.assertNever=function(e){throw new Error},e.arrayToEnum=e=>{const t={};for(const n of e)t[n]=n;return t},e.getValidEnumValues=t=>{const n=e.objectKeys(t).filter((e=>"number"!=typeof t[t[e]])),r={};for(const e of n)r[e]=t[e];return e.objectValues(r)},e.objectValues=t=>e.objectKeys(t).map((function(e){return t[e]})),e.objectKeys="function"==typeof Object.keys?e=>Object.keys(e):e=>{const t=[];for(const n in e)Object.prototype.hasOwnProperty.call(e,n)&&t.push(n);return t},e.find=(e,t)=>{for(const n of e)if(t(n))return n},e.isInteger="function"==typeof Number.isInteger?e=>Number.isInteger(e):e=>"number"==typeof e&&isFinite(e)&&Math.floor(e)===e,e.joinValues=function(e,t=" | "){return e.map((e=>"string"==typeof e?`\'${e}\'`:e)).join(t)},e.jsonStringifyReplacer=(e,t)=>"bigint"==typeof t?t.toString():t}(oe||(oe={})),function(e){e.mergeShapes=(e,t)=>({...e,...t})}(ce||(ce={}));const de=oe.arrayToEnum(["string","nan","number","integer","float","boolean","date","bigint","symbol","function","undefined","null","array","object","unknown","promise","void","never","map","set"]),ue=e=>{switch(typeof e){case"undefined":return de.undefined;case"string":return de.string;case"number":return isNaN(e)?de.nan:de.number;case"boolean":return de.boolean;case"function":return de.function;case"bigint":return de.bigint;case"symbol":return de.symbol;case"object":return Array.isArray(e)?de.array:null===e?de.null:e.then&&"function"==typeof e.then&&e.catch&&"function"==typeof e.catch?de.promise:"undefined"!=typeof Map&&e instanceof Map?de.map:"undefined"!=typeof Set&&e instanceof Set?de.set:"undefined"!=typeof Date&&e instanceof Date?de.date:de.object;default:return de.unknown}},le=oe.arrayToEnum(["invalid_type","invalid_literal","custom","invalid_union","invalid_union_discriminator","invalid_enum_value","unrecognized_keys","invalid_arguments","invalid_return_type","invalid_date","invalid_string","too_small","too_big","invalid_intersection_types","not_multiple_of","not_finite"]);class he extends Error{constructor(e){super(),this.issues=[],this.addIssue=e=>{this.issues=[...this.issues,e]},this.addIssues=(e=[])=>{this.issues=[...this.issues,...e]};const t=new.target.prototype;Object.setPrototypeOf?Object.setPrototypeOf(this,t):this.__proto__=t,this.name="ZodError",this.issues=e}get errors(){return this.issues}format(e){const t=e||function(e){return e.message},n={_errors:[]},r=e=>{for(const s of e.issues)if("invalid_union"===s.code)s.unionErrors.map(r);else if("invalid_return_type"===s.code)r(s.returnTypeError);else if("invalid_arguments"===s.code)r(s.argumentsError);else if(0===s.path.length)n._errors.push(t(s));else{let e=n,r=0;for(;r<s.path.length;){const n=s.path[r];r===s.path.length-1?(e[n]=e[n]||{_errors:[]},e[n]._errors.push(t(s))):e[n]=e[n]||{_errors:[]},e=e[n],r++}}};return r(this),n}static assert(e){if(!(e instanceof he))throw new Error(`Not a ZodError: ${e}`)}toString(){return this.message}get message(){return JSON.stringify(this.issues,oe.jsonStringifyReplacer,2)}get isEmpty(){return 0===this.issues.length}flatten(e=e=>e.message){const t={},n=[];for(const r of this.issues)r.path.length>0?(t[r.path[0]]=t[r.path[0]]||[],t[r.path[0]].push(e(r))):n.push(e(r));return{formErrors:n,fieldErrors:t}}get formErrors(){return this.flatten()}}he.create=e=>new he(e);const fe=(e,t)=>{let n;switch(e.code){case le.invalid_type:n=e.received===de.undefined?"Required":`Expected ${e.expected}, received ${e.received}`;break;case le.invalid_literal:n=`Invalid literal value, expected ${JSON.stringify(e.expected,oe.jsonStringifyReplacer)}`;break;case le.unrecognized_keys:n=`Unrecognized key(s) in object: ${oe.joinValues(e.keys,", ")}`;break;case le.invalid_union:n="Invalid input";break;case le.invalid_union_discriminator:n=`Invalid discriminator value. Expected ${oe.joinValues(e.options)}`;break;case le.invalid_enum_value:n=`Invalid enum value. Expected ${oe.joinValues(e.options)}, received \'${e.received}\'`;break;case le.invalid_arguments:n="Invalid function arguments";break;case le.invalid_return_type:n="Invalid function return type";break;case le.invalid_date:n="Invalid date";break;case le.invalid_string:"object"==typeof e.validation?"includes"in e.validation?(n=`Invalid input: must include "${e.validation.includes}"`,"number"==typeof e.validation.position&&(n=`${n} at one or more positions greater than or equal to ${e.validation.position}`)):"startsWith"in e.validation?n=`Invalid input: must start with "${e.validation.startsWith}"`:"endsWith"in e.validation?n=`Invalid input: must end with "${e.validation.endsWith}"`:oe.assertNever(e.validation):n="regex"!==e.validation?`Invalid ${e.validation}`:"Invalid";break;case le.too_small:n="array"===e.type?`Array must contain ${e.exact?"exactly":e.inclusive?"at least":"more than"} ${e.minimum} element(s)`:"string"===e.type?`String must contain ${e.exact?"exactly":e.inclusive?"at least":"over"} ${e.minimum} character(s)`:"number"===e.type?`Number must be ${e.exact?"exactly equal to ":e.inclusive?"greater than or equal to ":"greater than "}${e.minimum}`:"date"===e.type?`Date must be ${e.exact?"exactly equal to ":e.inclusive?"greater than or equal to ":"greater than "}${new Date(Number(e.minimum))}`:"Invalid input";break;case le.too_big:n="array"===e.type?`Array must contain ${e.exact?"exactly":e.inclusive?"at most":"less than"} ${e.maximum} element(s)`:"string"===e.type?`String must contain ${e.exact?"exactly":e.inclusive?"at most":"under"} ${e.maximum} character(s)`:"number"===e.type?`Number must be ${e.exact?"exactly":e.inclusive?"less than or equal to":"less than"} ${e.maximum}`:"bigint"===e.type?`BigInt must be ${e.exact?"exactly":e.inclusive?"less than or equal to":"less than"} ${e.maximum}`:"date"===e.type?`Date must be ${e.exact?"exactly":e.inclusive?"smaller than or equal to":"smaller than"} ${new Date(Number(e.maximum))}`:"Invalid input";break;case le.custom:n="Invalid input";break;case le.invalid_intersection_types:n="Intersection results could not be merged";break;case le.not_multiple_of:n=`Number must be a multiple of ${e.multipleOf}`;break;case le.not_finite:n="Number must be finite";break;default:n=t.defaultError,oe.assertNever(e)}return{message:n}};let pe=fe;function me(){return pe}const ge=e=>{const{data:t,path:n,errorMaps:r,issueData:s}=e,i=[...n,...s.path||[]],a={...s,path:i};if(void 0!==s.message)return{...s,path:i,message:s.message};let o="";const c=r.filter((e=>!!e)).slice().reverse();for(const e of c)o=e(a,{data:t,defaultError:o}).message;return{...s,path:i,message:o}};function ye(e,t){const n=me(),r=ge({issueData:t,data:e.data,path:e.path,errorMaps:[e.common.contextualErrorMap,e.schemaErrorMap,n,n===fe?void 0:fe].filter((e=>!!e))});e.common.issues.push(r)}class ve{constructor(){this.value="valid"}dirty(){"valid"===this.value&&(this.value="dirty")}abort(){"aborted"!==this.value&&(this.value="aborted")}static mergeArray(e,t){const n=[];for(const r of t){if("aborted"===r.status)return we;"dirty"===r.status&&e.dirty(),n.push(r.value)}return{status:e.value,value:n}}static async mergeObjectAsync(e,t){const n=[];for(const e of t){const t=await e.key,r=await e.value;n.push({key:t,value:r})}return ve.mergeObjectSync(e,n)}static mergeObjectSync(e,t){const n={};for(const r of t){const{key:t,value:s}=r;if("aborted"===t.status)return we;if("aborted"===s.status)return we;"dirty"===t.status&&e.dirty(),"dirty"===s.status&&e.dirty(),"__proto__"===t.value||void 0===s.value&&!r.alwaysSet||(n[t.value]=s.value)}return{status:e.value,value:n}}}const we=Object.freeze({status:"aborted"}),_e=e=>({status:"dirty",value:e}),be=e=>({status:"valid",value:e}),xe=e=>"aborted"===e.status,Ee=e=>"dirty"===e.status,ke=e=>"valid"===e.status,Oe=e=>"undefined"!=typeof Promise&&e instanceof Promise;function Se(e,t,n,r){if("a"===n&&!r)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof t?e!==t||!r:!t.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===n?r:"a"===n?r.call(e):r?r.value:t.get(e)}function Ae(e,t,n,r,s){if("m"===r)throw new TypeError("Private method is not writable");if("a"===r&&!s)throw new TypeError("Private accessor was defined without a setter");if("function"==typeof t?e!==t||!s:!t.has(e))throw new TypeError("Cannot write private member to an object whose class did not declare it");return"a"===r?s.call(e,n):s?s.value=n:t.set(e,n),n}var Ne,Te,Ze;"function"==typeof SuppressedError&&SuppressedError,function(e){e.errToObj=e=>"string"==typeof e?{message:e}:e||{},e.toString=e=>"string"==typeof e?e:null==e?void 0:e.message}(Ne||(Ne={}));class Ie{constructor(e,t,n,r){this._cachedPath=[],this.parent=e,this.data=t,this._path=n,this._key=r}get path(){return this._cachedPath.length||(this._key instanceof Array?this._cachedPath.push(...this._path,...this._key):this._cachedPath.push(...this._path,this._key)),this._cachedPath}}const Be=(e,t)=>{if(ke(t))return{success:!0,data:t.value};if(!e.common.issues.length)throw new Error("Validation failed but no issues detected.");return{success:!1,get error(){if(this._error)return this._error;const t=new he(e.common.issues);return this._error=t,this._error}}};function Ce(e){if(!e)return{};const{errorMap:t,invalid_type_error:n,required_error:r,description:s}=e;if(t&&(n||r))throw new Error(\'Can\\\'t use "invalid_type_error" or "required_error" in conjunction with custom error map.\');if(t)return{errorMap:t,description:s};return{errorMap:(t,s)=>{var i,a;const{message:o}=e;return"invalid_enum_value"===t.code?{message:null!=o?o:s.defaultError}:void 0===s.data?{message:null!==(i=null!=o?o:r)&&void 0!==i?i:s.defaultError}:"invalid_type"!==t.code?{message:s.defaultError}:{message:null!==(a=null!=o?o:n)&&void 0!==a?a:s.defaultError}},description:s}}class je{constructor(e){this.spa=this.safeParseAsync,this._def=e,this.parse=this.parse.bind(this),this.safeParse=this.safeParse.bind(this),this.parseAsync=this.parseAsync.bind(this),this.safeParseAsync=this.safeParseAsync.bind(this),this.spa=this.spa.bind(this),this.refine=this.refine.bind(this),this.refinement=this.refinement.bind(this),this.superRefine=this.superRefine.bind(this),this.optional=this.optional.bind(this),this.nullable=this.nullable.bind(this),this.nullish=this.nullish.bind(this),this.array=this.array.bind(this),this.promise=this.promise.bind(this),this.or=this.or.bind(this),this.and=this.and.bind(this),this.transform=this.transform.bind(this),this.brand=this.brand.bind(this),this.default=this.default.bind(this),this.catch=this.catch.bind(this),this.describe=this.describe.bind(this),this.pipe=this.pipe.bind(this),this.readonly=this.readonly.bind(this),this.isNullable=this.isNullable.bind(this),this.isOptional=this.isOptional.bind(this)}get description(){return this._def.description}_getType(e){return ue(e.data)}_getOrReturnCtx(e,t){return t||{common:e.parent.common,data:e.data,parsedType:ue(e.data),schemaErrorMap:this._def.errorMap,path:e.path,parent:e.parent}}_processInputParams(e){return{status:new ve,ctx:{common:e.parent.common,data:e.data,parsedType:ue(e.data),schemaErrorMap:this._def.errorMap,path:e.path,parent:e.parent}}}_parseSync(e){const t=this._parse(e);if(Oe(t))throw new Error("Synchronous parse encountered promise.");return t}_parseAsync(e){const t=this._parse(e);return Promise.resolve(t)}parse(e,t){const n=this.safeParse(e,t);if(n.success)return n.data;throw n.error}safeParse(e,t){var n;const r={common:{issues:[],async:null!==(n=null==t?void 0:t.async)&&void 0!==n&&n,contextualErrorMap:null==t?void 0:t.errorMap},path:(null==t?void 0:t.path)||[],schemaErrorMap:this._def.errorMap,parent:null,data:e,parsedType:ue(e)},s=this._parseSync({data:e,path:r.path,parent:r});return Be(r,s)}async parseAsync(e,t){const n=await this.safeParseAsync(e,t);if(n.success)return n.data;throw n.error}async safeParseAsync(e,t){const n={common:{issues:[],contextualErrorMap:null==t?void 0:t.errorMap,async:!0},path:(null==t?void 0:t.path)||[],schemaErrorMap:this._def.errorMap,parent:null,data:e,parsedType:ue(e)},r=this._parse({data:e,path:n.path,parent:n}),s=await(Oe(r)?r:Promise.resolve(r));return Be(n,s)}refine(e,t){const n=e=>"string"==typeof t||void 0===t?{message:t}:"function"==typeof t?t(e):t;return this._refinement(((t,r)=>{const s=e(t),i=()=>r.addIssue({code:le.custom,...n(t)});return"undefined"!=typeof Promise&&s instanceof Promise?s.then((e=>!!e||(i(),!1))):!!s||(i(),!1)}))}refinement(e,t){return this._refinement(((n,r)=>!!e(n)||(r.addIssue("function"==typeof t?t(n,r):t),!1)))}_refinement(e){return new Nt({schema:this,typeName:Mt.ZodEffects,effect:{type:"refinement",refinement:e}})}superRefine(e){return this._refinement(e)}optional(){return Tt.create(this,this._def)}nullable(){return Zt.create(this,this._def)}nullish(){return this.nullable().optional()}array(){return dt.create(this,this._def)}promise(){return At.create(this,this._def)}or(e){return ht.create([this,e],this._def)}and(e){return gt.create(this,e,this._def)}transform(e){return new Nt({...Ce(this._def),schema:this,typeName:Mt.ZodEffects,effect:{type:"transform",transform:e}})}default(e){const t="function"==typeof e?e:()=>e;return new It({...Ce(this._def),innerType:this,defaultValue:t,typeName:Mt.ZodDefault})}brand(){return new Rt({typeName:Mt.ZodBranded,type:this,...Ce(this._def)})}catch(e){const t="function"==typeof e?e:()=>e;return new Bt({...Ce(this._def),innerType:this,catchValue:t,typeName:Mt.ZodCatch})}describe(e){return new(0,this.constructor)({...this._def,description:e})}pipe(e){return Pt.create(this,e)}readonly(){return Lt.create(this)}isOptional(){return this.safeParse(void 0).success}isNullable(){return this.safeParse(null).success}}const Re=/^c[^\\s-]{8,}$/i,Pe=/^[0-9a-z]+$/,Le=/^[0-9A-HJKMNP-TV-Z]{26}$/,Ue=/^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/i,$e=/^[a-z0-9_-]{21}$/i,Me=/^[-+]?P(?!$)(?:(?:[-+]?\\d+Y)|(?:[-+]?\\d+[.,]\\d+Y$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:(?:[-+]?\\d+W)|(?:[-+]?\\d+[.,]\\d+W$))?(?:(?:[-+]?\\d+D)|(?:[-+]?\\d+[.,]\\d+D$))?(?:T(?=[\\d+-])(?:(?:[-+]?\\d+H)|(?:[-+]?\\d+[.,]\\d+H$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:[-+]?\\d+(?:[.,]\\d+)?S)?)??$/,ze=/^(?!\\.)(?!.*\\.\\.)([A-Z0-9_\'+\\-\\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\\-]*\\.)+[A-Z]{2,}$/i;let qe;const De=/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,Fe=/^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,Ve=/^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,He="((\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\\\d|30)|(02)-(0[1-9]|1\\\\d|2[0-8])))",Ke=new RegExp(`^${He}$`);function We(e){let t="([01]\\\\d|2[0-3]):[0-5]\\\\d:[0-5]\\\\d";return e.precision?t=`${t}\\\\.\\\\d{${e.precision}}`:null==e.precision&&(t=`${t}(\\\\.\\\\d+)?`),t}function Je(e){let t=`${He}T${We(e)}`;const n=[];return n.push(e.local?"Z?":"Z"),e.offset&&n.push("([+-]\\\\d{2}:?\\\\d{2})"),t=`${t}(${n.join("|")})`,new RegExp(`^${t}$`)}class Ge extends je{_parse(e){this._def.coerce&&(e.data=String(e.data));if(this._getType(e)!==de.string){const t=this._getOrReturnCtx(e);return ye(t,{code:le.invalid_type,expected:de.string,received:t.parsedType}),we}const t=new ve;let n;for(const i of this._def.checks)if("min"===i.kind)e.data.length<i.value&&(n=this._getOrReturnCtx(e,n),ye(n,{code:le.too_small,minimum:i.value,type:"string",inclusive:!0,exact:!1,message:i.message}),t.dirty());else if("max"===i.kind)e.data.length>i.value&&(n=this._getOrReturnCtx(e,n),ye(n,{code:le.too_big,maximum:i.value,type:"string",inclusive:!0,exact:!1,message:i.message}),t.dirty());else if("length"===i.kind){const r=e.data.length>i.value,s=e.data.length<i.value;(r||s)&&(n=this._getOrReturnCtx(e,n),r?ye(n,{code:le.too_big,maximum:i.value,type:"string",inclusive:!0,exact:!0,message:i.message}):s&&ye(n,{code:le.too_small,minimum:i.value,type:"string",inclusive:!0,exact:!0,message:i.message}),t.dirty())}else if("email"===i.kind)ze.test(e.data)||(n=this._getOrReturnCtx(e,n),ye(n,{validation:"email",code:le.invalid_string,message:i.message}),t.dirty());else if("emoji"===i.kind)qe||(qe=new RegExp("^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$","u")),qe.test(e.data)||(n=this._getOrReturnCtx(e,n),ye(n,{validation:"emoji",code:le.invalid_string,message:i.message}),t.dirty());else if("uuid"===i.kind)Ue.test(e.data)||(n=this._getOrReturnCtx(e,n),ye(n,{validation:"uuid",code:le.invalid_string,message:i.message}),t.dirty());else if("nanoid"===i.kind)$e.test(e.data)||(n=this._getOrReturnCtx(e,n),ye(n,{validation:"nanoid",code:le.invalid_string,message:i.message}),t.dirty());else if("cuid"===i.kind)Re.test(e.data)||(n=this._getOrReturnCtx(e,n),ye(n,{validation:"cuid",code:le.invalid_string,message:i.message}),t.dirty());else if("cuid2"===i.kind)Pe.test(e.data)||(n=this._getOrReturnCtx(e,n),ye(n,{validation:"cuid2",code:le.invalid_string,message:i.message}),t.dirty());else if("ulid"===i.kind)Le.test(e.data)||(n=this._getOrReturnCtx(e,n),ye(n,{validation:"ulid",code:le.invalid_string,message:i.message}),t.dirty());else if("url"===i.kind)try{new URL(e.data)}catch(r){n=this._getOrReturnCtx(e,n),ye(n,{validation:"url",code:le.invalid_string,message:i.message}),t.dirty()}else if("regex"===i.kind){i.regex.lastIndex=0;i.regex.test(e.data)||(n=this._getOrReturnCtx(e,n),ye(n,{validation:"regex",code:le.invalid_string,message:i.message}),t.dirty())}else if("trim"===i.kind)e.data=e.data.trim();else if("includes"===i.kind)e.data.includes(i.value,i.position)||(n=this._getOrReturnCtx(e,n),ye(n,{code:le.invalid_string,validation:{includes:i.value,position:i.position},message:i.message}),t.dirty());else if("toLowerCase"===i.kind)e.data=e.data.toLowerCase();else if("toUpperCase"===i.kind)e.data=e.data.toUpperCase();else if("startsWith"===i.kind)e.data.startsWith(i.value)||(n=this._getOrReturnCtx(e,n),ye(n,{code:le.invalid_string,validation:{startsWith:i.value},message:i.message}),t.dirty());else if("endsWith"===i.kind)e.data.endsWith(i.value)||(n=this._getOrReturnCtx(e,n),ye(n,{code:le.invalid_string,validation:{endsWith:i.value},message:i.message}),t.dirty());else if("datetime"===i.kind){Je(i).test(e.data)||(n=this._getOrReturnCtx(e,n),ye(n,{code:le.invalid_string,validation:"datetime",message:i.message}),t.dirty())}else if("date"===i.kind){Ke.test(e.data)||(n=this._getOrReturnCtx(e,n),ye(n,{code:le.invalid_string,validation:"date",message:i.message}),t.dirty())}else if("time"===i.kind){new RegExp(`^${We(i)}$`).test(e.data)||(n=this._getOrReturnCtx(e,n),ye(n,{code:le.invalid_string,validation:"time",message:i.message}),t.dirty())}else"duration"===i.kind?Me.test(e.data)||(n=this._getOrReturnCtx(e,n),ye(n,{validation:"duration",code:le.invalid_string,message:i.message}),t.dirty()):"ip"===i.kind?(r=e.data,("v4"!==(s=i.version)&&s||!De.test(r))&&("v6"!==s&&s||!Fe.test(r))&&(n=this._getOrReturnCtx(e,n),ye(n,{validation:"ip",code:le.invalid_string,message:i.message}),t.dirty())):"base64"===i.kind?Ve.test(e.data)||(n=this._getOrReturnCtx(e,n),ye(n,{validation:"base64",code:le.invalid_string,message:i.message}),t.dirty()):oe.assertNever(i);var r,s;return{status:t.value,value:e.data}}_regex(e,t,n){return this.refinement((t=>e.test(t)),{validation:t,code:le.invalid_string,...Ne.errToObj(n)})}_addCheck(e){return new Ge({...this._def,checks:[...this._def.checks,e]})}email(e){return this._addCheck({kind:"email",...Ne.errToObj(e)})}url(e){return this._addCheck({kind:"url",...Ne.errToObj(e)})}emoji(e){return this._addCheck({kind:"emoji",...Ne.errToObj(e)})}uuid(e){return this._addCheck({kind:"uuid",...Ne.errToObj(e)})}nanoid(e){return this._addCheck({kind:"nanoid",...Ne.errToObj(e)})}cuid(e){return this._addCheck({kind:"cuid",...Ne.errToObj(e)})}cuid2(e){return this._addCheck({kind:"cuid2",...Ne.errToObj(e)})}ulid(e){return this._addCheck({kind:"ulid",...Ne.errToObj(e)})}base64(e){return this._addCheck({kind:"base64",...Ne.errToObj(e)})}ip(e){return this._addCheck({kind:"ip",...Ne.errToObj(e)})}datetime(e){var t,n;return"string"==typeof e?this._addCheck({kind:"datetime",precision:null,offset:!1,local:!1,message:e}):this._addCheck({kind:"datetime",precision:void 0===(null==e?void 0:e.precision)?null:null==e?void 0:e.precision,offset:null!==(t=null==e?void 0:e.offset)&&void 0!==t&&t,local:null!==(n=null==e?void 0:e.local)&&void 0!==n&&n,...Ne.errToObj(null==e?void 0:e.message)})}date(e){return this._addCheck({kind:"date",message:e})}time(e){return"string"==typeof e?this._addCheck({kind:"time",precision:null,message:e}):this._addCheck({kind:"time",precision:void 0===(null==e?void 0:e.precision)?null:null==e?void 0:e.precision,...Ne.errToObj(null==e?void 0:e.message)})}duration(e){return this._addCheck({kind:"duration",...Ne.errToObj(e)})}regex(e,t){return this._addCheck({kind:"regex",regex:e,...Ne.errToObj(t)})}includes(e,t){return this._addCheck({kind:"includes",value:e,position:null==t?void 0:t.position,...Ne.errToObj(null==t?void 0:t.message)})}startsWith(e,t){return this._addCheck({kind:"startsWith",value:e,...Ne.errToObj(t)})}endsWith(e,t){return this._addCheck({kind:"endsWith",value:e,...Ne.errToObj(t)})}min(e,t){return this._addCheck({kind:"min",value:e,...Ne.errToObj(t)})}max(e,t){return this._addCheck({kind:"max",value:e,...Ne.errToObj(t)})}length(e,t){return this._addCheck({kind:"length",value:e,...Ne.errToObj(t)})}nonempty(e){return this.min(1,Ne.errToObj(e))}trim(){return new Ge({...this._def,checks:[...this._def.checks,{kind:"trim"}]})}toLowerCase(){return new Ge({...this._def,checks:[...this._def.checks,{kind:"toLowerCase"}]})}toUpperCase(){return new Ge({...this._def,checks:[...this._def.checks,{kind:"toUpperCase"}]})}get isDatetime(){return!!this._def.checks.find((e=>"datetime"===e.kind))}get isDate(){return!!this._def.checks.find((e=>"date"===e.kind))}get isTime(){return!!this._def.checks.find((e=>"time"===e.kind))}get isDuration(){return!!this._def.checks.find((e=>"duration"===e.kind))}get isEmail(){return!!this._def.checks.find((e=>"email"===e.kind))}get isURL(){return!!this._def.checks.find((e=>"url"===e.kind))}get isEmoji(){return!!this._def.checks.find((e=>"emoji"===e.kind))}get isUUID(){return!!this._def.checks.find((e=>"uuid"===e.kind))}get isNANOID(){return!!this._def.checks.find((e=>"nanoid"===e.kind))}get isCUID(){return!!this._def.checks.find((e=>"cuid"===e.kind))}get isCUID2(){return!!this._def.checks.find((e=>"cuid2"===e.kind))}get isULID(){return!!this._def.checks.find((e=>"ulid"===e.kind))}get isIP(){return!!this._def.checks.find((e=>"ip"===e.kind))}get isBase64(){return!!this._def.checks.find((e=>"base64"===e.kind))}get minLength(){let e=null;for(const t of this._def.checks)"min"===t.kind&&(null===e||t.value>e)&&(e=t.value);return e}get maxLength(){let e=null;for(const t of this._def.checks)"max"===t.kind&&(null===e||t.value<e)&&(e=t.value);return e}}function Ye(e,t){const n=(e.toString().split(".")[1]||"").length,r=(t.toString().split(".")[1]||"").length,s=n>r?n:r;return parseInt(e.toFixed(s).replace(".",""))%parseInt(t.toFixed(s).replace(".",""))/Math.pow(10,s)}Ge.create=e=>{var t;return new Ge({checks:[],typeName:Mt.ZodString,coerce:null!==(t=null==e?void 0:e.coerce)&&void 0!==t&&t,...Ce(e)})};class Xe extends je{constructor(){super(...arguments),this.min=this.gte,this.max=this.lte,this.step=this.multipleOf}_parse(e){this._def.coerce&&(e.data=Number(e.data));if(this._getType(e)!==de.number){const t=this._getOrReturnCtx(e);return ye(t,{code:le.invalid_type,expected:de.number,received:t.parsedType}),we}let t;const n=new ve;for(const r of this._def.checks)if("int"===r.kind)oe.isInteger(e.data)||(t=this._getOrReturnCtx(e,t),ye(t,{code:le.invalid_type,expected:"integer",received:"float",message:r.message}),n.dirty());else if("min"===r.kind){(r.inclusive?e.data<r.value:e.data<=r.value)&&(t=this._getOrReturnCtx(e,t),ye(t,{code:le.too_small,minimum:r.value,type:"number",inclusive:r.inclusive,exact:!1,message:r.message}),n.dirty())}else if("max"===r.kind){(r.inclusive?e.data>r.value:e.data>=r.value)&&(t=this._getOrReturnCtx(e,t),ye(t,{code:le.too_big,maximum:r.value,type:"number",inclusive:r.inclusive,exact:!1,message:r.message}),n.dirty())}else"multipleOf"===r.kind?0!==Ye(e.data,r.value)&&(t=this._getOrReturnCtx(e,t),ye(t,{code:le.not_multiple_of,multipleOf:r.value,message:r.message}),n.dirty()):"finite"===r.kind?Number.isFinite(e.data)||(t=this._getOrReturnCtx(e,t),ye(t,{code:le.not_finite,message:r.message}),n.dirty()):oe.assertNever(r);return{status:n.value,value:e.data}}gte(e,t){return this.setLimit("min",e,!0,Ne.toString(t))}gt(e,t){return this.setLimit("min",e,!1,Ne.toString(t))}lte(e,t){return this.setLimit("max",e,!0,Ne.toString(t))}lt(e,t){return this.setLimit("max",e,!1,Ne.toString(t))}setLimit(e,t,n,r){return new Xe({...this._def,checks:[...this._def.checks,{kind:e,value:t,inclusive:n,message:Ne.toString(r)}]})}_addCheck(e){return new Xe({...this._def,checks:[...this._def.checks,e]})}int(e){return this._addCheck({kind:"int",message:Ne.toString(e)})}positive(e){return this._addCheck({kind:"min",value:0,inclusive:!1,message:Ne.toString(e)})}negative(e){return this._addCheck({kind:"max",value:0,inclusive:!1,message:Ne.toString(e)})}nonpositive(e){return this._addCheck({kind:"max",value:0,inclusive:!0,message:Ne.toString(e)})}nonnegative(e){return this._addCheck({kind:"min",value:0,inclusive:!0,message:Ne.toString(e)})}multipleOf(e,t){return this._addCheck({kind:"multipleOf",value:e,message:Ne.toString(t)})}finite(e){return this._addCheck({kind:"finite",message:Ne.toString(e)})}safe(e){return this._addCheck({kind:"min",inclusive:!0,value:Number.MIN_SAFE_INTEGER,message:Ne.toString(e)})._addCheck({kind:"max",inclusive:!0,value:Number.MAX_SAFE_INTEGER,message:Ne.toString(e)})}get minValue(){let e=null;for(const t of this._def.checks)"min"===t.kind&&(null===e||t.value>e)&&(e=t.value);return e}get maxValue(){let e=null;for(const t of this._def.checks)"max"===t.kind&&(null===e||t.value<e)&&(e=t.value);return e}get isInt(){return!!this._def.checks.find((e=>"int"===e.kind||"multipleOf"===e.kind&&oe.isInteger(e.value)))}get isFinite(){let e=null,t=null;for(const n of this._def.checks){if("finite"===n.kind||"int"===n.kind||"multipleOf"===n.kind)return!0;"min"===n.kind?(null===t||n.value>t)&&(t=n.value):"max"===n.kind&&(null===e||n.value<e)&&(e=n.value)}return Number.isFinite(t)&&Number.isFinite(e)}}Xe.create=e=>new Xe({checks:[],typeName:Mt.ZodNumber,coerce:(null==e?void 0:e.coerce)||!1,...Ce(e)});class Qe extends je{constructor(){super(...arguments),this.min=this.gte,this.max=this.lte}_parse(e){this._def.coerce&&(e.data=BigInt(e.data));if(this._getType(e)!==de.bigint){const t=this._getOrReturnCtx(e);return ye(t,{code:le.invalid_type,expected:de.bigint,received:t.parsedType}),we}let t;const n=new ve;for(const r of this._def.checks)if("min"===r.kind){(r.inclusive?e.data<r.value:e.data<=r.value)&&(t=this._getOrReturnCtx(e,t),ye(t,{code:le.too_small,type:"bigint",minimum:r.value,inclusive:r.inclusive,message:r.message}),n.dirty())}else if("max"===r.kind){(r.inclusive?e.data>r.value:e.data>=r.value)&&(t=this._getOrReturnCtx(e,t),ye(t,{code:le.too_big,type:"bigint",maximum:r.value,inclusive:r.inclusive,message:r.message}),n.dirty())}else"multipleOf"===r.kind?e.data%r.value!==BigInt(0)&&(t=this._getOrReturnCtx(e,t),ye(t,{code:le.not_multiple_of,multipleOf:r.value,message:r.message}),n.dirty()):oe.assertNever(r);return{status:n.value,value:e.data}}gte(e,t){return this.setLimit("min",e,!0,Ne.toString(t))}gt(e,t){return this.setLimit("min",e,!1,Ne.toString(t))}lte(e,t){return this.setLimit("max",e,!0,Ne.toString(t))}lt(e,t){return this.setLimit("max",e,!1,Ne.toString(t))}setLimit(e,t,n,r){return new Qe({...this._def,checks:[...this._def.checks,{kind:e,value:t,inclusive:n,message:Ne.toString(r)}]})}_addCheck(e){return new Qe({...this._def,checks:[...this._def.checks,e]})}positive(e){return this._addCheck({kind:"min",value:BigInt(0),inclusive:!1,message:Ne.toString(e)})}negative(e){return this._addCheck({kind:"max",value:BigInt(0),inclusive:!1,message:Ne.toString(e)})}nonpositive(e){return this._addCheck({kind:"max",value:BigInt(0),inclusive:!0,message:Ne.toString(e)})}nonnegative(e){return this._addCheck({kind:"min",value:BigInt(0),inclusive:!0,message:Ne.toString(e)})}multipleOf(e,t){return this._addCheck({kind:"multipleOf",value:e,message:Ne.toString(t)})}get minValue(){let e=null;for(const t of this._def.checks)"min"===t.kind&&(null===e||t.value>e)&&(e=t.value);return e}get maxValue(){let e=null;for(const t of this._def.checks)"max"===t.kind&&(null===e||t.value<e)&&(e=t.value);return e}}Qe.create=e=>{var t;return new Qe({checks:[],typeName:Mt.ZodBigInt,coerce:null!==(t=null==e?void 0:e.coerce)&&void 0!==t&&t,...Ce(e)})};class et extends je{_parse(e){this._def.coerce&&(e.data=Boolean(e.data));if(this._getType(e)!==de.boolean){const t=this._getOrReturnCtx(e);return ye(t,{code:le.invalid_type,expected:de.boolean,received:t.parsedType}),we}return be(e.data)}}et.create=e=>new et({typeName:Mt.ZodBoolean,coerce:(null==e?void 0:e.coerce)||!1,...Ce(e)});class tt extends je{_parse(e){this._def.coerce&&(e.data=new Date(e.data));if(this._getType(e)!==de.date){const t=this._getOrReturnCtx(e);return ye(t,{code:le.invalid_type,expected:de.date,received:t.parsedType}),we}if(isNaN(e.data.getTime())){return ye(this._getOrReturnCtx(e),{code:le.invalid_date}),we}const t=new ve;let n;for(const r of this._def.checks)"min"===r.kind?e.data.getTime()<r.value&&(n=this._getOrReturnCtx(e,n),ye(n,{code:le.too_small,message:r.message,inclusive:!0,exact:!1,minimum:r.value,type:"date"}),t.dirty()):"max"===r.kind?e.data.getTime()>r.value&&(n=this._getOrReturnCtx(e,n),ye(n,{code:le.too_big,message:r.message,inclusive:!0,exact:!1,maximum:r.value,type:"date"}),t.dirty()):oe.assertNever(r);return{status:t.value,value:new Date(e.data.getTime())}}_addCheck(e){return new tt({...this._def,checks:[...this._def.checks,e]})}min(e,t){return this._addCheck({kind:"min",value:e.getTime(),message:Ne.toString(t)})}max(e,t){return this._addCheck({kind:"max",value:e.getTime(),message:Ne.toString(t)})}get minDate(){let e=null;for(const t of this._def.checks)"min"===t.kind&&(null===e||t.value>e)&&(e=t.value);return null!=e?new Date(e):null}get maxDate(){let e=null;for(const t of this._def.checks)"max"===t.kind&&(null===e||t.value<e)&&(e=t.value);return null!=e?new Date(e):null}}tt.create=e=>new tt({checks:[],coerce:(null==e?void 0:e.coerce)||!1,typeName:Mt.ZodDate,...Ce(e)});class nt extends je{_parse(e){if(this._getType(e)!==de.symbol){const t=this._getOrReturnCtx(e);return ye(t,{code:le.invalid_type,expected:de.symbol,received:t.parsedType}),we}return be(e.data)}}nt.create=e=>new nt({typeName:Mt.ZodSymbol,...Ce(e)});class rt extends je{_parse(e){if(this._getType(e)!==de.undefined){const t=this._getOrReturnCtx(e);return ye(t,{code:le.invalid_type,expected:de.undefined,received:t.parsedType}),we}return be(e.data)}}rt.create=e=>new rt({typeName:Mt.ZodUndefined,...Ce(e)});class st extends je{_parse(e){if(this._getType(e)!==de.null){const t=this._getOrReturnCtx(e);return ye(t,{code:le.invalid_type,expected:de.null,received:t.parsedType}),we}return be(e.data)}}st.create=e=>new st({typeName:Mt.ZodNull,...Ce(e)});class it extends je{constructor(){super(...arguments),this._any=!0}_parse(e){return be(e.data)}}it.create=e=>new it({typeName:Mt.ZodAny,...Ce(e)});class at extends je{constructor(){super(...arguments),this._unknown=!0}_parse(e){return be(e.data)}}at.create=e=>new at({typeName:Mt.ZodUnknown,...Ce(e)});class ot extends je{_parse(e){const t=this._getOrReturnCtx(e);return ye(t,{code:le.invalid_type,expected:de.never,received:t.parsedType}),we}}ot.create=e=>new ot({typeName:Mt.ZodNever,...Ce(e)});class ct extends je{_parse(e){if(this._getType(e)!==de.undefined){const t=this._getOrReturnCtx(e);return ye(t,{code:le.invalid_type,expected:de.void,received:t.parsedType}),we}return be(e.data)}}ct.create=e=>new ct({typeName:Mt.ZodVoid,...Ce(e)});class dt extends je{_parse(e){const{ctx:t,status:n}=this._processInputParams(e),r=this._def;if(t.parsedType!==de.array)return ye(t,{code:le.invalid_type,expected:de.array,received:t.parsedType}),we;if(null!==r.exactLength){const e=t.data.length>r.exactLength.value,s=t.data.length<r.exactLength.value;(e||s)&&(ye(t,{code:e?le.too_big:le.too_small,minimum:s?r.exactLength.value:void 0,maximum:e?r.exactLength.value:void 0,type:"array",inclusive:!0,exact:!0,message:r.exactLength.message}),n.dirty())}if(null!==r.minLength&&t.data.length<r.minLength.value&&(ye(t,{code:le.too_small,minimum:r.minLength.value,type:"array",inclusive:!0,exact:!1,message:r.minLength.message}),n.dirty()),null!==r.maxLength&&t.data.length>r.maxLength.value&&(ye(t,{code:le.too_big,maximum:r.maxLength.value,type:"array",inclusive:!0,exact:!1,message:r.maxLength.message}),n.dirty()),t.common.async)return Promise.all([...t.data].map(((e,n)=>r.type._parseAsync(new Ie(t,e,t.path,n))))).then((e=>ve.mergeArray(n,e)));const s=[...t.data].map(((e,n)=>r.type._parseSync(new Ie(t,e,t.path,n))));return ve.mergeArray(n,s)}get element(){return this._def.type}min(e,t){return new dt({...this._def,minLength:{value:e,message:Ne.toString(t)}})}max(e,t){return new dt({...this._def,maxLength:{value:e,message:Ne.toString(t)}})}length(e,t){return new dt({...this._def,exactLength:{value:e,message:Ne.toString(t)}})}nonempty(e){return this.min(1,e)}}function ut(e){if(e instanceof lt){const t={};for(const n in e.shape){const r=e.shape[n];t[n]=Tt.create(ut(r))}return new lt({...e._def,shape:()=>t})}return e instanceof dt?new dt({...e._def,type:ut(e.element)}):e instanceof Tt?Tt.create(ut(e.unwrap())):e instanceof Zt?Zt.create(ut(e.unwrap())):e instanceof yt?yt.create(e.items.map((e=>ut(e)))):e}dt.create=(e,t)=>new dt({type:e,minLength:null,maxLength:null,exactLength:null,typeName:Mt.ZodArray,...Ce(t)});class lt extends je{constructor(){super(...arguments),this._cached=null,this.nonstrict=this.passthrough,this.augment=this.extend}_getCached(){if(null!==this._cached)return this._cached;const e=this._def.shape(),t=oe.objectKeys(e);return this._cached={shape:e,keys:t}}_parse(e){if(this._getType(e)!==de.object){const t=this._getOrReturnCtx(e);return ye(t,{code:le.invalid_type,expected:de.object,received:t.parsedType}),we}const{status:t,ctx:n}=this._processInputParams(e),{shape:r,keys:s}=this._getCached(),i=[];if(!(this._def.catchall instanceof ot&&"strip"===this._def.unknownKeys))for(const e in n.data)s.includes(e)||i.push(e);const a=[];for(const e of s){const t=r[e],s=n.data[e];a.push({key:{status:"valid",value:e},value:t._parse(new Ie(n,s,n.path,e)),alwaysSet:e in n.data})}if(this._def.catchall instanceof ot){const e=this._def.unknownKeys;if("passthrough"===e)for(const e of i)a.push({key:{status:"valid",value:e},value:{status:"valid",value:n.data[e]}});else if("strict"===e)i.length>0&&(ye(n,{code:le.unrecognized_keys,keys:i}),t.dirty());else if("strip"!==e)throw new Error("Internal ZodObject error: invalid unknownKeys value.")}else{const e=this._def.catchall;for(const t of i){const r=n.data[t];a.push({key:{status:"valid",value:t},value:e._parse(new Ie(n,r,n.path,t)),alwaysSet:t in n.data})}}return n.common.async?Promise.resolve().then((async()=>{const e=[];for(const t of a){const n=await t.key,r=await t.value;e.push({key:n,value:r,alwaysSet:t.alwaysSet})}return e})).then((e=>ve.mergeObjectSync(t,e))):ve.mergeObjectSync(t,a)}get shape(){return this._def.shape()}strict(e){return Ne.errToObj,new lt({...this._def,unknownKeys:"strict",...void 0!==e?{errorMap:(t,n)=>{var r,s,i,a;const o=null!==(i=null===(s=(r=this._def).errorMap)||void 0===s?void 0:s.call(r,t,n).message)&&void 0!==i?i:n.defaultError;return"unrecognized_keys"===t.code?{message:null!==(a=Ne.errToObj(e).message)&&void 0!==a?a:o}:{message:o}}}:{}})}strip(){return new lt({...this._def,unknownKeys:"strip"})}passthrough(){return new lt({...this._def,unknownKeys:"passthrough"})}extend(e){return new lt({...this._def,shape:()=>({...this._def.shape(),...e})})}merge(e){return new lt({unknownKeys:e._def.unknownKeys,catchall:e._def.catchall,shape:()=>({...this._def.shape(),...e._def.shape()}),typeName:Mt.ZodObject})}setKey(e,t){return this.augment({[e]:t})}catchall(e){return new lt({...this._def,catchall:e})}pick(e){const t={};return oe.objectKeys(e).forEach((n=>{e[n]&&this.shape[n]&&(t[n]=this.shape[n])})),new lt({...this._def,shape:()=>t})}omit(e){const t={};return oe.objectKeys(this.shape).forEach((n=>{e[n]||(t[n]=this.shape[n])})),new lt({...this._def,shape:()=>t})}deepPartial(){return ut(this)}partial(e){const t={};return oe.objectKeys(this.shape).forEach((n=>{const r=this.shape[n];e&&!e[n]?t[n]=r:t[n]=r.optional()})),new lt({...this._def,shape:()=>t})}required(e){const t={};return oe.objectKeys(this.shape).forEach((n=>{if(e&&!e[n])t[n]=this.shape[n];else{let e=this.shape[n];for(;e instanceof Tt;)e=e._def.innerType;t[n]=e}})),new lt({...this._def,shape:()=>t})}keyof(){return kt(oe.objectKeys(this.shape))}}lt.create=(e,t)=>new lt({shape:()=>e,unknownKeys:"strip",catchall:ot.create(),typeName:Mt.ZodObject,...Ce(t)}),lt.strictCreate=(e,t)=>new lt({shape:()=>e,unknownKeys:"strict",catchall:ot.create(),typeName:Mt.ZodObject,...Ce(t)}),lt.lazycreate=(e,t)=>new lt({shape:e,unknownKeys:"strip",catchall:ot.create(),typeName:Mt.ZodObject,...Ce(t)});class ht extends je{_parse(e){const{ctx:t}=this._processInputParams(e),n=this._def.options;if(t.common.async)return Promise.all(n.map((async e=>{const n={...t,common:{...t.common,issues:[]},parent:null};return{result:await e._parseAsync({data:t.data,path:t.path,parent:n}),ctx:n}}))).then((function(e){for(const t of e)if("valid"===t.result.status)return t.result;for(const n of e)if("dirty"===n.result.status)return t.common.issues.push(...n.ctx.common.issues),n.result;const n=e.map((e=>new he(e.ctx.common.issues)));return ye(t,{code:le.invalid_union,unionErrors:n}),we}));{let e;const r=[];for(const s of n){const n={...t,common:{...t.common,issues:[]},parent:null},i=s._parseSync({data:t.data,path:t.path,parent:n});if("valid"===i.status)return i;"dirty"!==i.status||e||(e={result:i,ctx:n}),n.common.issues.length&&r.push(n.common.issues)}if(e)return t.common.issues.push(...e.ctx.common.issues),e.result;const s=r.map((e=>new he(e)));return ye(t,{code:le.invalid_union,unionErrors:s}),we}}get options(){return this._def.options}}ht.create=(e,t)=>new ht({options:e,typeName:Mt.ZodUnion,...Ce(t)});const ft=e=>e instanceof xt?ft(e.schema):e instanceof Nt?ft(e.innerType()):e instanceof Et?[e.value]:e instanceof Ot?e.options:e instanceof St?oe.objectValues(e.enum):e instanceof It?ft(e._def.innerType):e instanceof rt?[void 0]:e instanceof st?[null]:e instanceof Tt?[void 0,...ft(e.unwrap())]:e instanceof Zt?[null,...ft(e.unwrap())]:e instanceof Rt||e instanceof Lt?ft(e.unwrap()):e instanceof Bt?ft(e._def.innerType):[];class pt extends je{_parse(e){const{ctx:t}=this._processInputParams(e);if(t.parsedType!==de.object)return ye(t,{code:le.invalid_type,expected:de.object,received:t.parsedType}),we;const n=this.discriminator,r=t.data[n],s=this.optionsMap.get(r);return s?t.common.async?s._parseAsync({data:t.data,path:t.path,parent:t}):s._parseSync({data:t.data,path:t.path,parent:t}):(ye(t,{code:le.invalid_union_discriminator,options:Array.from(this.optionsMap.keys()),path:[n]}),we)}get discriminator(){return this._def.discriminator}get options(){return this._def.options}get optionsMap(){return this._def.optionsMap}static create(e,t,n){const r=new Map;for(const n of t){const t=ft(n.shape[e]);if(!t.length)throw new Error(`A discriminator value for key \\`${e}\\` could not be extracted from all schema options`);for(const s of t){if(r.has(s))throw new Error(`Discriminator property ${String(e)} has duplicate value ${String(s)}`);r.set(s,n)}}return new pt({typeName:Mt.ZodDiscriminatedUnion,discriminator:e,options:t,optionsMap:r,...Ce(n)})}}function mt(e,t){const n=ue(e),r=ue(t);if(e===t)return{valid:!0,data:e};if(n===de.object&&r===de.object){const n=oe.objectKeys(t),r=oe.objectKeys(e).filter((e=>-1!==n.indexOf(e))),s={...e,...t};for(const n of r){const r=mt(e[n],t[n]);if(!r.valid)return{valid:!1};s[n]=r.data}return{valid:!0,data:s}}if(n===de.array&&r===de.array){if(e.length!==t.length)return{valid:!1};const n=[];for(let r=0;r<e.length;r++){const s=mt(e[r],t[r]);if(!s.valid)return{valid:!1};n.push(s.data)}return{valid:!0,data:n}}return n===de.date&&r===de.date&&+e==+t?{valid:!0,data:e}:{valid:!1}}class gt extends je{_parse(e){const{status:t,ctx:n}=this._processInputParams(e),r=(e,r)=>{if(xe(e)||xe(r))return we;const s=mt(e.value,r.value);return s.valid?((Ee(e)||Ee(r))&&t.dirty(),{status:t.value,value:s.data}):(ye(n,{code:le.invalid_intersection_types}),we)};return n.common.async?Promise.all([this._def.left._parseAsync({data:n.data,path:n.path,parent:n}),this._def.right._parseAsync({data:n.data,path:n.path,parent:n})]).then((([e,t])=>r(e,t))):r(this._def.left._parseSync({data:n.data,path:n.path,parent:n}),this._def.right._parseSync({data:n.data,path:n.path,parent:n}))}}gt.create=(e,t,n)=>new gt({left:e,right:t,typeName:Mt.ZodIntersection,...Ce(n)});class yt extends je{_parse(e){const{status:t,ctx:n}=this._processInputParams(e);if(n.parsedType!==de.array)return ye(n,{code:le.invalid_type,expected:de.array,received:n.parsedType}),we;if(n.data.length<this._def.items.length)return ye(n,{code:le.too_small,minimum:this._def.items.length,inclusive:!0,exact:!1,type:"array"}),we;!this._def.rest&&n.data.length>this._def.items.length&&(ye(n,{code:le.too_big,maximum:this._def.items.length,inclusive:!0,exact:!1,type:"array"}),t.dirty());const r=[...n.data].map(((e,t)=>{const r=this._def.items[t]||this._def.rest;return r?r._parse(new Ie(n,e,n.path,t)):null})).filter((e=>!!e));return n.common.async?Promise.all(r).then((e=>ve.mergeArray(t,e))):ve.mergeArray(t,r)}get items(){return this._def.items}rest(e){return new yt({...this._def,rest:e})}}yt.create=(e,t)=>{if(!Array.isArray(e))throw new Error("You must pass an array of schemas to z.tuple([ ... ])");return new yt({items:e,typeName:Mt.ZodTuple,rest:null,...Ce(t)})};class vt extends je{get keySchema(){return this._def.keyType}get valueSchema(){return this._def.valueType}_parse(e){const{status:t,ctx:n}=this._processInputParams(e);if(n.parsedType!==de.object)return ye(n,{code:le.invalid_type,expected:de.object,received:n.parsedType}),we;const r=[],s=this._def.keyType,i=this._def.valueType;for(const e in n.data)r.push({key:s._parse(new Ie(n,e,n.path,e)),value:i._parse(new Ie(n,n.data[e],n.path,e)),alwaysSet:e in n.data});return n.common.async?ve.mergeObjectAsync(t,r):ve.mergeObjectSync(t,r)}get element(){return this._def.valueType}static create(e,t,n){return new vt(t instanceof je?{keyType:e,valueType:t,typeName:Mt.ZodRecord,...Ce(n)}:{keyType:Ge.create(),valueType:e,typeName:Mt.ZodRecord,...Ce(t)})}}class wt extends je{get keySchema(){return this._def.keyType}get valueSchema(){return this._def.valueType}_parse(e){const{status:t,ctx:n}=this._processInputParams(e);if(n.parsedType!==de.map)return ye(n,{code:le.invalid_type,expected:de.map,received:n.parsedType}),we;const r=this._def.keyType,s=this._def.valueType,i=[...n.data.entries()].map((([e,t],i)=>({key:r._parse(new Ie(n,e,n.path,[i,"key"])),value:s._parse(new Ie(n,t,n.path,[i,"value"]))})));if(n.common.async){const e=new Map;return Promise.resolve().then((async()=>{for(const n of i){const r=await n.key,s=await n.value;if("aborted"===r.status||"aborted"===s.status)return we;"dirty"!==r.status&&"dirty"!==s.status||t.dirty(),e.set(r.value,s.value)}return{status:t.value,value:e}}))}{const e=new Map;for(const n of i){const r=n.key,s=n.value;if("aborted"===r.status||"aborted"===s.status)return we;"dirty"!==r.status&&"dirty"!==s.status||t.dirty(),e.set(r.value,s.value)}return{status:t.value,value:e}}}}wt.create=(e,t,n)=>new wt({valueType:t,keyType:e,typeName:Mt.ZodMap,...Ce(n)});class _t extends je{_parse(e){const{status:t,ctx:n}=this._processInputParams(e);if(n.parsedType!==de.set)return ye(n,{code:le.invalid_type,expected:de.set,received:n.parsedType}),we;const r=this._def;null!==r.minSize&&n.data.size<r.minSize.value&&(ye(n,{code:le.too_small,minimum:r.minSize.value,type:"set",inclusive:!0,exact:!1,message:r.minSize.message}),t.dirty()),null!==r.maxSize&&n.data.size>r.maxSize.value&&(ye(n,{code:le.too_big,maximum:r.maxSize.value,type:"set",inclusive:!0,exact:!1,message:r.maxSize.message}),t.dirty());const s=this._def.valueType;function i(e){const n=new Set;for(const r of e){if("aborted"===r.status)return we;"dirty"===r.status&&t.dirty(),n.add(r.value)}return{status:t.value,value:n}}const a=[...n.data.values()].map(((e,t)=>s._parse(new Ie(n,e,n.path,t))));return n.common.async?Promise.all(a).then((e=>i(e))):i(a)}min(e,t){return new _t({...this._def,minSize:{value:e,message:Ne.toString(t)}})}max(e,t){return new _t({...this._def,maxSize:{value:e,message:Ne.toString(t)}})}size(e,t){return this.min(e,t).max(e,t)}nonempty(e){return this.min(1,e)}}_t.create=(e,t)=>new _t({valueType:e,minSize:null,maxSize:null,typeName:Mt.ZodSet,...Ce(t)});class bt extends je{constructor(){super(...arguments),this.validate=this.implement}_parse(e){const{ctx:t}=this._processInputParams(e);if(t.parsedType!==de.function)return ye(t,{code:le.invalid_type,expected:de.function,received:t.parsedType}),we;function n(e,n){return ge({data:e,path:t.path,errorMaps:[t.common.contextualErrorMap,t.schemaErrorMap,me(),fe].filter((e=>!!e)),issueData:{code:le.invalid_arguments,argumentsError:n}})}function r(e,n){return ge({data:e,path:t.path,errorMaps:[t.common.contextualErrorMap,t.schemaErrorMap,me(),fe].filter((e=>!!e)),issueData:{code:le.invalid_return_type,returnTypeError:n}})}const s={errorMap:t.common.contextualErrorMap},i=t.data;if(this._def.returns instanceof At){const e=this;return be((async function(...t){const a=new he([]),o=await e._def.args.parseAsync(t,s).catch((e=>{throw a.addIssue(n(t,e)),a})),c=await Reflect.apply(i,this,o);return await e._def.returns._def.type.parseAsync(c,s).catch((e=>{throw a.addIssue(r(c,e)),a}))}))}{const e=this;return be((function(...t){const a=e._def.args.safeParse(t,s);if(!a.success)throw new he([n(t,a.error)]);const o=Reflect.apply(i,this,a.data),c=e._def.returns.safeParse(o,s);if(!c.success)throw new he([r(o,c.error)]);return c.data}))}}parameters(){return this._def.args}returnType(){return this._def.returns}args(...e){return new bt({...this._def,args:yt.create(e).rest(at.create())})}returns(e){return new bt({...this._def,returns:e})}implement(e){return this.parse(e)}strictImplement(e){return this.parse(e)}static create(e,t,n){return new bt({args:e||yt.create([]).rest(at.create()),returns:t||at.create(),typeName:Mt.ZodFunction,...Ce(n)})}}class xt extends je{get schema(){return this._def.getter()}_parse(e){const{ctx:t}=this._processInputParams(e);return this._def.getter()._parse({data:t.data,path:t.path,parent:t})}}xt.create=(e,t)=>new xt({getter:e,typeName:Mt.ZodLazy,...Ce(t)});class Et extends je{_parse(e){if(e.data!==this._def.value){const t=this._getOrReturnCtx(e);return ye(t,{received:t.data,code:le.invalid_literal,expected:this._def.value}),we}return{status:"valid",value:e.data}}get value(){return this._def.value}}function kt(e,t){return new Ot({values:e,typeName:Mt.ZodEnum,...Ce(t)})}Et.create=(e,t)=>new Et({value:e,typeName:Mt.ZodLiteral,...Ce(t)});class Ot extends je{constructor(){super(...arguments),Te.set(this,void 0)}_parse(e){if("string"!=typeof e.data){const t=this._getOrReturnCtx(e),n=this._def.values;return ye(t,{expected:oe.joinValues(n),received:t.parsedType,code:le.invalid_type}),we}if(Se(this,Te,"f")||Ae(this,Te,new Set(this._def.values),"f"),!Se(this,Te,"f").has(e.data)){const t=this._getOrReturnCtx(e),n=this._def.values;return ye(t,{received:t.data,code:le.invalid_enum_value,options:n}),we}return be(e.data)}get options(){return this._def.values}get enum(){const e={};for(const t of this._def.values)e[t]=t;return e}get Values(){const e={};for(const t of this._def.values)e[t]=t;return e}get Enum(){const e={};for(const t of this._def.values)e[t]=t;return e}extract(e,t=this._def){return Ot.create(e,{...this._def,...t})}exclude(e,t=this._def){return Ot.create(this.options.filter((t=>!e.includes(t))),{...this._def,...t})}}Te=new WeakMap,Ot.create=kt;class St extends je{constructor(){super(...arguments),Ze.set(this,void 0)}_parse(e){const t=oe.getValidEnumValues(this._def.values),n=this._getOrReturnCtx(e);if(n.parsedType!==de.string&&n.parsedType!==de.number){const e=oe.objectValues(t);return ye(n,{expected:oe.joinValues(e),received:n.parsedType,code:le.invalid_type}),we}if(Se(this,Ze,"f")||Ae(this,Ze,new Set(oe.getValidEnumValues(this._def.values)),"f"),!Se(this,Ze,"f").has(e.data)){const e=oe.objectValues(t);return ye(n,{received:n.data,code:le.invalid_enum_value,options:e}),we}return be(e.data)}get enum(){return this._def.values}}Ze=new WeakMap,St.create=(e,t)=>new St({values:e,typeName:Mt.ZodNativeEnum,...Ce(t)});class At extends je{unwrap(){return this._def.type}_parse(e){const{ctx:t}=this._processInputParams(e);if(t.parsedType!==de.promise&&!1===t.common.async)return ye(t,{code:le.invalid_type,expected:de.promise,received:t.parsedType}),we;const n=t.parsedType===de.promise?t.data:Promise.resolve(t.data);return be(n.then((e=>this._def.type.parseAsync(e,{path:t.path,errorMap:t.common.contextualErrorMap}))))}}At.create=(e,t)=>new At({type:e,typeName:Mt.ZodPromise,...Ce(t)});class Nt extends je{innerType(){return this._def.schema}sourceType(){return this._def.schema._def.typeName===Mt.ZodEffects?this._def.schema.sourceType():this._def.schema}_parse(e){const{status:t,ctx:n}=this._processInputParams(e),r=this._def.effect||null,s={addIssue:e=>{ye(n,e),e.fatal?t.abort():t.dirty()},get path(){return n.path}};if(s.addIssue=s.addIssue.bind(s),"preprocess"===r.type){const e=r.transform(n.data,s);if(n.common.async)return Promise.resolve(e).then((async e=>{if("aborted"===t.value)return we;const r=await this._def.schema._parseAsync({data:e,path:n.path,parent:n});return"aborted"===r.status?we:"dirty"===r.status||"dirty"===t.value?_e(r.value):r}));{if("aborted"===t.value)return we;const r=this._def.schema._parseSync({data:e,path:n.path,parent:n});return"aborted"===r.status?we:"dirty"===r.status||"dirty"===t.value?_e(r.value):r}}if("refinement"===r.type){const e=e=>{const t=r.refinement(e,s);if(n.common.async)return Promise.resolve(t);if(t instanceof Promise)throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");return e};if(!1===n.common.async){const r=this._def.schema._parseSync({data:n.data,path:n.path,parent:n});return"aborted"===r.status?we:("dirty"===r.status&&t.dirty(),e(r.value),{status:t.value,value:r.value})}return this._def.schema._parseAsync({data:n.data,path:n.path,parent:n}).then((n=>"aborted"===n.status?we:("dirty"===n.status&&t.dirty(),e(n.value).then((()=>({status:t.value,value:n.value}))))))}if("transform"===r.type){if(!1===n.common.async){const e=this._def.schema._parseSync({data:n.data,path:n.path,parent:n});if(!ke(e))return e;const i=r.transform(e.value,s);if(i instanceof Promise)throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");return{status:t.value,value:i}}return this._def.schema._parseAsync({data:n.data,path:n.path,parent:n}).then((e=>ke(e)?Promise.resolve(r.transform(e.value,s)).then((e=>({status:t.value,value:e}))):e))}oe.assertNever(r)}}Nt.create=(e,t,n)=>new Nt({schema:e,typeName:Mt.ZodEffects,effect:t,...Ce(n)}),Nt.createWithPreprocess=(e,t,n)=>new Nt({schema:t,effect:{type:"preprocess",transform:e},typeName:Mt.ZodEffects,...Ce(n)});class Tt extends je{_parse(e){return this._getType(e)===de.undefined?be(void 0):this._def.innerType._parse(e)}unwrap(){return this._def.innerType}}Tt.create=(e,t)=>new Tt({innerType:e,typeName:Mt.ZodOptional,...Ce(t)});class Zt extends je{_parse(e){return this._getType(e)===de.null?be(null):this._def.innerType._parse(e)}unwrap(){return this._def.innerType}}Zt.create=(e,t)=>new Zt({innerType:e,typeName:Mt.ZodNullable,...Ce(t)});class It extends je{_parse(e){const{ctx:t}=this._processInputParams(e);let n=t.data;return t.parsedType===de.undefined&&(n=this._def.defaultValue()),this._def.innerType._parse({data:n,path:t.path,parent:t})}removeDefault(){return this._def.innerType}}It.create=(e,t)=>new It({innerType:e,typeName:Mt.ZodDefault,defaultValue:"function"==typeof t.default?t.default:()=>t.default,...Ce(t)});class Bt extends je{_parse(e){const{ctx:t}=this._processInputParams(e),n={...t,common:{...t.common,issues:[]}},r=this._def.innerType._parse({data:n.data,path:n.path,parent:{...n}});return Oe(r)?r.then((e=>({status:"valid",value:"valid"===e.status?e.value:this._def.catchValue({get error(){return new he(n.common.issues)},input:n.data})}))):{status:"valid",value:"valid"===r.status?r.value:this._def.catchValue({get error(){return new he(n.common.issues)},input:n.data})}}removeCatch(){return this._def.innerType}}Bt.create=(e,t)=>new Bt({innerType:e,typeName:Mt.ZodCatch,catchValue:"function"==typeof t.catch?t.catch:()=>t.catch,...Ce(t)});class Ct extends je{_parse(e){if(this._getType(e)!==de.nan){const t=this._getOrReturnCtx(e);return ye(t,{code:le.invalid_type,expected:de.nan,received:t.parsedType}),we}return{status:"valid",value:e.data}}}Ct.create=e=>new Ct({typeName:Mt.ZodNaN,...Ce(e)});const jt=Symbol("zod_brand");class Rt extends je{_parse(e){const{ctx:t}=this._processInputParams(e),n=t.data;return this._def.type._parse({data:n,path:t.path,parent:t})}unwrap(){return this._def.type}}class Pt extends je{_parse(e){const{status:t,ctx:n}=this._processInputParams(e);if(n.common.async){return(async()=>{const e=await this._def.in._parseAsync({data:n.data,path:n.path,parent:n});return"aborted"===e.status?we:"dirty"===e.status?(t.dirty(),_e(e.value)):this._def.out._parseAsync({data:e.value,path:n.path,parent:n})})()}{const e=this._def.in._parseSync({data:n.data,path:n.path,parent:n});return"aborted"===e.status?we:"dirty"===e.status?(t.dirty(),{status:"dirty",value:e.value}):this._def.out._parseSync({data:e.value,path:n.path,parent:n})}}static create(e,t){return new Pt({in:e,out:t,typeName:Mt.ZodPipeline})}}class Lt extends je{_parse(e){const t=this._def.innerType._parse(e),n=e=>(ke(e)&&(e.value=Object.freeze(e.value)),e);return Oe(t)?t.then((e=>n(e))):n(t)}unwrap(){return this._def.innerType}}function Ut(e,t={},n){return e?it.create().superRefine(((r,s)=>{var i,a;if(!e(r)){const e="function"==typeof t?t(r):"string"==typeof t?{message:t}:t,o=null===(a=null!==(i=e.fatal)&&void 0!==i?i:n)||void 0===a||a,c="string"==typeof e?{message:e}:e;s.addIssue({code:"custom",...c,fatal:o})}})):it.create()}Lt.create=(e,t)=>new Lt({innerType:e,typeName:Mt.ZodReadonly,...Ce(t)});const $t={object:lt.lazycreate};var Mt;!function(e){e.ZodString="ZodString",e.ZodNumber="ZodNumber",e.ZodNaN="ZodNaN",e.ZodBigInt="ZodBigInt",e.ZodBoolean="ZodBoolean",e.ZodDate="ZodDate",e.ZodSymbol="ZodSymbol",e.ZodUndefined="ZodUndefined",e.ZodNull="ZodNull",e.ZodAny="ZodAny",e.ZodUnknown="ZodUnknown",e.ZodNever="ZodNever",e.ZodVoid="ZodVoid",e.ZodArray="ZodArray",e.ZodObject="ZodObject",e.ZodUnion="ZodUnion",e.ZodDiscriminatedUnion="ZodDiscriminatedUnion",e.ZodIntersection="ZodIntersection",e.ZodTuple="ZodTuple",e.ZodRecord="ZodRecord",e.ZodMap="ZodMap",e.ZodSet="ZodSet",e.ZodFunction="ZodFunction",e.ZodLazy="ZodLazy",e.ZodLiteral="ZodLiteral",e.ZodEnum="ZodEnum",e.ZodEffects="ZodEffects",e.ZodNativeEnum="ZodNativeEnum",e.ZodOptional="ZodOptional",e.ZodNullable="ZodNullable",e.ZodDefault="ZodDefault",e.ZodCatch="ZodCatch",e.ZodPromise="ZodPromise",e.ZodBranded="ZodBranded",e.ZodPipeline="ZodPipeline",e.ZodReadonly="ZodReadonly"}(Mt||(Mt={}));const zt=Ge.create,qt=Xe.create,Dt=Ct.create,Ft=Qe.create,Vt=et.create,Ht=tt.create,Kt=nt.create,Wt=rt.create,Jt=st.create,Gt=it.create,Yt=at.create,Xt=ot.create,Qt=ct.create,en=dt.create,tn=lt.create,nn=lt.strictCreate,rn=ht.create,sn=pt.create,an=gt.create,on=yt.create,cn=vt.create,dn=wt.create,un=_t.create,ln=bt.create,hn=xt.create,fn=Et.create,pn=Ot.create,mn=St.create,gn=At.create,yn=Nt.create,vn=Tt.create,wn=Zt.create,_n=Nt.createWithPreprocess,bn=Pt.create,xn={string:e=>Ge.create({...e,coerce:!0}),number:e=>Xe.create({...e,coerce:!0}),boolean:e=>et.create({...e,coerce:!0}),bigint:e=>Qe.create({...e,coerce:!0}),date:e=>tt.create({...e,coerce:!0})},En=we;var kn=Object.freeze({__proto__:null,defaultErrorMap:fe,setErrorMap:function(e){pe=e},getErrorMap:me,makeIssue:ge,EMPTY_PATH:[],addIssueToContext:ye,ParseStatus:ve,INVALID:we,DIRTY:_e,OK:be,isAborted:xe,isDirty:Ee,isValid:ke,isAsync:Oe,get util(){return oe},get objectUtil(){return ce},ZodParsedType:de,getParsedType:ue,ZodType:je,datetimeRegex:Je,ZodString:Ge,ZodNumber:Xe,ZodBigInt:Qe,ZodBoolean:et,ZodDate:tt,ZodSymbol:nt,ZodUndefined:rt,ZodNull:st,ZodAny:it,ZodUnknown:at,ZodNever:ot,ZodVoid:ct,ZodArray:dt,ZodObject:lt,ZodUnion:ht,ZodDiscriminatedUnion:pt,ZodIntersection:gt,ZodTuple:yt,ZodRecord:vt,ZodMap:wt,ZodSet:_t,ZodFunction:bt,ZodLazy:xt,ZodLiteral:Et,ZodEnum:Ot,ZodNativeEnum:St,ZodPromise:At,ZodEffects:Nt,ZodTransformer:Nt,ZodOptional:Tt,ZodNullable:Zt,ZodDefault:It,ZodCatch:Bt,ZodNaN:Ct,BRAND:jt,ZodBranded:Rt,ZodPipeline:Pt,ZodReadonly:Lt,custom:Ut,Schema:je,ZodSchema:je,late:$t,get ZodFirstPartyTypeKind(){return Mt},coerce:xn,any:Gt,array:en,bigint:Ft,boolean:Vt,date:Ht,discriminatedUnion:sn,effect:yn,enum:pn,function:ln,instanceof:(e,t={message:`Input not instance of ${e.name}`})=>Ut((t=>t instanceof e),t),intersection:an,lazy:hn,literal:fn,map:dn,nan:Dt,nativeEnum:mn,never:Xt,null:Jt,nullable:wn,number:qt,object:tn,oboolean:()=>Vt().optional(),onumber:()=>qt().optional(),optional:vn,ostring:()=>zt().optional(),pipeline:bn,preprocess:_n,promise:gn,record:cn,set:un,strictObject:nn,string:zt,symbol:Kt,transformer:yn,tuple:on,undefined:Wt,union:rn,unknown:Yt,void:Qt,NEVER:En,ZodIssueCode:le,quotelessJson:e=>JSON.stringify(e,null,2).replace(/"([^"]+)":/g,"$1:"),ZodError:he});function On(e){if(!Number.isSafeInteger(e)||e<0)throw new Error("positive integer expected, got "+e)}function Sn(e,...t){if(!((n=e)instanceof Uint8Array||ArrayBuffer.isView(n)&&"Uint8Array"===n.constructor.name))throw new Error("Uint8Array expected");var n;if(t.length>0&&!t.includes(e.length))throw new Error("Uint8Array expected of length "+t+", got length="+e.length)}function An(e){if("function"!=typeof e||"function"!=typeof e.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");On(e.outputLen),On(e.blockLen)}function Nn(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function Tn(e,t){Sn(e);const n=t.outputLen;if(e.length<n)throw new Error("digestInto() expects output buffer of length at least "+n)}const Zn="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0;const In=e=>new DataView(e.buffer,e.byteOffset,e.byteLength),Bn=(e,t)=>e<<32-t|e>>>t;Array.from({length:256},((e,t)=>t.toString(16).padStart(2,"0")));function Cn(e){return"string"==typeof e&&(e=function(e){if("string"!=typeof e)throw new Error("utf8ToBytes expected string, got "+typeof e);return new Uint8Array((new TextEncoder).encode(e))}(e)),Sn(e),e}class jn{clone(){return this._cloneInto()}}function Rn(e=32){if(Zn&&"function"==typeof Zn.getRandomValues)return Zn.getRandomValues(new Uint8Array(e));if(Zn&&"function"==typeof Zn.randomBytes)return Zn.randomBytes(e);throw new Error("crypto.getRandomValues must be defined")}const Pn=(e,t,n)=>e&t^e&n^t&n;class Ln extends jn{constructor(e,t,n,r){super(),this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=r,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=In(this.buffer)}update(e){Nn(this);const{view:t,buffer:n,blockLen:r}=this,s=(e=Cn(e)).length;for(let i=0;i<s;){const a=Math.min(r-this.pos,s-i);if(a!==r)n.set(e.subarray(i,i+a),this.pos),this.pos+=a,i+=a,this.pos===r&&(this.process(t,0),this.pos=0);else{const t=In(e);for(;r<=s-i;i+=r)this.process(t,i)}}return this.length+=e.length,this.roundClean(),this}digestInto(e){Nn(this),Tn(e,this),this.finished=!0;const{buffer:t,view:n,blockLen:r,isLE:s}=this;let{pos:i}=this;t[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>r-i&&(this.process(n,0),i=0);for(let e=i;e<r;e++)t[e]=0;!function(e,t,n,r){if("function"==typeof e.setBigUint64)return e.setBigUint64(t,n,r);const s=BigInt(32),i=BigInt(4294967295),a=Number(n>>s&i),o=Number(n&i),c=r?4:0,d=r?0:4;e.setUint32(t+c,a,r),e.setUint32(t+d,o,r)}(n,r-8,BigInt(8*this.length),s),this.process(n,0);const a=In(e),o=this.outputLen;if(o%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const c=o/4,d=this.get();if(c>d.length)throw new Error("_sha2: outputLen bigger than state");for(let e=0;e<c;e++)a.setUint32(4*e,d[e],s)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:n,length:r,finished:s,destroyed:i,pos:a}=this;return e.length=r,e.pos=a,e.finished=s,e.destroyed=i,r%t&&e.buffer.set(n),e}}const Un=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),$n=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Mn=new Uint32Array(64);class zn extends Ln{constructor(){super(64,32,8,!1),this.A=0|$n[0],this.B=0|$n[1],this.C=0|$n[2],this.D=0|$n[3],this.E=0|$n[4],this.F=0|$n[5],this.G=0|$n[6],this.H=0|$n[7]}get(){const{A:e,B:t,C:n,D:r,E:s,F:i,G:a,H:o}=this;return[e,t,n,r,s,i,a,o]}set(e,t,n,r,s,i,a,o){this.A=0|e,this.B=0|t,this.C=0|n,this.D=0|r,this.E=0|s,this.F=0|i,this.G=0|a,this.H=0|o}process(e,t){for(let n=0;n<16;n++,t+=4)Mn[n]=e.getUint32(t,!1);for(let e=16;e<64;e++){const t=Mn[e-15],n=Mn[e-2],r=Bn(t,7)^Bn(t,18)^t>>>3,s=Bn(n,17)^Bn(n,19)^n>>>10;Mn[e]=s+Mn[e-7]+r+Mn[e-16]|0}let{A:n,B:r,C:s,D:i,E:a,F:o,G:c,H:d}=this;for(let e=0;e<64;e++){const t=d+(Bn(a,6)^Bn(a,11)^Bn(a,25))+((u=a)&o^~u&c)+Un[e]+Mn[e]|0,l=(Bn(n,2)^Bn(n,13)^Bn(n,22))+Pn(n,r,s)|0;d=c,c=o,o=a,a=i+t|0,i=s,s=r,r=n,n=t+l|0}var u;n=n+this.A|0,r=r+this.B|0,s=s+this.C|0,i=i+this.D|0,a=a+this.E|0,o=o+this.F|0,c=c+this.G|0,d=d+this.H|0,this.set(n,r,s,i,a,o,c,d)}roundClean(){Mn.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const qn=function(e){const t=t=>e().update(Cn(t)).digest(),n=e();return t.outputLen=n.outputLen,t.blockLen=n.blockLen,t.create=()=>e(),t}((()=>new zn));class Dn extends jn{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,An(e);const n=Cn(t);if(this.iHash=e.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const r=this.blockLen,s=new Uint8Array(r);s.set(n.length>r?e.create().update(n).digest():n);for(let e=0;e<s.length;e++)s[e]^=54;this.iHash.update(s),this.oHash=e.create();for(let e=0;e<s.length;e++)s[e]^=106;this.oHash.update(s),s.fill(0)}update(e){return Nn(this),this.iHash.update(e),this}digestInto(e){Nn(this),Sn(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:n,finished:r,destroyed:s,blockLen:i,outputLen:a}=this;return e.finished=r,e.destroyed=s,e.blockLen=i,e.outputLen=a,e.oHash=t._cloneInto(e.oHash),e.iHash=n._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Fn=(e,t,n)=>new Dn(e,t).update(n).digest();Fn.create=(e,t)=>new Dn(e,t);const Vn=BigInt(0),Hn=BigInt(1),Kn=BigInt(2);function Wn(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&"Uint8Array"===e.constructor.name}function Jn(e){if(!Wn(e))throw new Error("Uint8Array expected")}function Gn(e,t){if("boolean"!=typeof t)throw new Error(e+" boolean expected, got "+t)}const Yn=Array.from({length:256},((e,t)=>t.toString(16).padStart(2,"0")));function Xn(e){Jn(e);let t="";for(let n=0;n<e.length;n++)t+=Yn[e[n]];return t}function Qn(e){const t=e.toString(16);return 1&t.length?"0"+t:t}function er(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);return""===e?Vn:BigInt("0x"+e)}const tr={_0:48,_9:57,A:65,F:70,a:97,f:102};function nr(e){return e>=tr._0&&e<=tr._9?e-tr._0:e>=tr.A&&e<=tr.F?e-(tr.A-10):e>=tr.a&&e<=tr.f?e-(tr.a-10):void 0}function rr(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);const t=e.length,n=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);const r=new Uint8Array(n);for(let t=0,s=0;t<n;t++,s+=2){const n=nr(e.charCodeAt(s)),i=nr(e.charCodeAt(s+1));if(void 0===n||void 0===i){const t=e[s]+e[s+1];throw new Error(\'hex string expected, got non-hex character "\'+t+\'" at index \'+s)}r[t]=16*n+i}return r}function sr(e){return er(Xn(e))}function ir(e){return Jn(e),er(Xn(Uint8Array.from(e).reverse()))}function ar(e,t){return rr(e.toString(16).padStart(2*t,"0"))}function or(e,t){return ar(e,t).reverse()}function cr(e,t,n){let r;if("string"==typeof t)try{r=rr(t)}catch(t){throw new Error(e+" must be hex string or Uint8Array, cause: "+t)}else{if(!Wn(t))throw new Error(e+" must be hex string or Uint8Array");r=Uint8Array.from(t)}const s=r.length;if("number"==typeof n&&s!==n)throw new Error(e+" of length "+n+" expected, got "+s);return r}function dr(...e){let t=0;for(let n=0;n<e.length;n++){const r=e[n];Jn(r),t+=r.length}const n=new Uint8Array(t);for(let t=0,r=0;t<e.length;t++){const s=e[t];n.set(s,r),r+=s.length}return n}const ur=e=>"bigint"==typeof e&&Vn<=e;function lr(e,t,n){return ur(e)&&ur(t)&&ur(n)&&t<=e&&e<n}function hr(e,t,n,r){if(!lr(t,n,r))throw new Error("expected valid "+e+": "+n+" <= n < "+r+", got "+t)}function fr(e){let t;for(t=0;e>Vn;e>>=Hn,t+=1);return t}const pr=e=>(Kn<<BigInt(e-1))-Hn,mr=e=>new Uint8Array(e),gr=e=>Uint8Array.from(e);function yr(e,t,n){if("number"!=typeof e||e<2)throw new Error("hashLen must be a number");if("number"!=typeof t||t<2)throw new Error("qByteLen must be a number");if("function"!=typeof n)throw new Error("hmacFn must be a function");let r=mr(e),s=mr(e),i=0;const a=()=>{r.fill(1),s.fill(0),i=0},o=(...e)=>n(s,r,...e),c=(e=mr())=>{s=o(gr([0]),e),r=o(),0!==e.length&&(s=o(gr([1]),e),r=o())},d=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let e=0;const n=[];for(;e<t;){r=o();const t=r.slice();n.push(t),e+=r.length}return dr(...n)};return(e,t)=>{let n;for(a(),c(e);!(n=t(d()));)c();return a(),n}}const vr={bigint:e=>"bigint"==typeof e,function:e=>"function"==typeof e,boolean:e=>"boolean"==typeof e,string:e=>"string"==typeof e,stringOrUint8Array:e=>"string"==typeof e||Wn(e),isSafeInteger:e=>Number.isSafeInteger(e),array:e=>Array.isArray(e),field:(e,t)=>t.Fp.isValid(e),hash:e=>"function"==typeof e&&Number.isSafeInteger(e.outputLen)};function wr(e,t,n={}){const r=(t,n,r)=>{const s=vr[n];if("function"!=typeof s)throw new Error("invalid validator function");const i=e[t];if(!(r&&void 0===i||s(i,e)))throw new Error("param "+String(t)+" is invalid. Expected "+n+", got "+i)};for(const[e,n]of Object.entries(t))r(e,n,!1);for(const[e,t]of Object.entries(n))r(e,t,!0);return e}function _r(e){const t=new WeakMap;return(n,...r)=>{const s=t.get(n);if(void 0!==s)return s;const i=e(n,...r);return t.set(n,i),i}}const br=BigInt(0),xr=BigInt(1),Er=BigInt(2),kr=BigInt(3),Or=BigInt(4),Sr=BigInt(5),Ar=BigInt(8);BigInt(9),BigInt(16);function Nr(e,t){const n=e%t;return n>=br?n:t+n}function Tr(e,t,n){if(t<br)throw new Error("invalid exponent, negatives unsupported");if(n<=br)throw new Error("invalid modulus");if(n===xr)return br;let r=xr;for(;t>br;)t&xr&&(r=r*e%n),e=e*e%n,t>>=xr;return r}function Zr(e,t,n){let r=e;for(;t-- >br;)r*=r,r%=n;return r}function Ir(e,t){if(e===br)throw new Error("invert: expected non-zero number");if(t<=br)throw new Error("invert: expected positive modulus, got "+t);let n=Nr(e,t),r=t,s=br,i=xr,a=xr,o=br;for(;n!==br;){const e=r/n,t=r%n,c=s-a*e,d=i-o*e;r=n,n=t,s=a,i=o,a=c,o=d}if(r!==xr)throw new Error("invert: does not exist");return Nr(s,t)}function Br(e){if(e%Or===kr){const t=(e+xr)/Or;return function(e,n){const r=e.pow(n,t);if(!e.eql(e.sqr(r),n))throw new Error("Cannot find square root");return r}}if(e%Ar===Sr){const t=(e-Sr)/Ar;return function(e,n){const r=e.mul(n,Er),s=e.pow(r,t),i=e.mul(n,s),a=e.mul(e.mul(i,Er),s),o=e.mul(i,e.sub(a,e.ONE));if(!e.eql(e.sqr(o),n))throw new Error("Cannot find square root");return o}}return function(e){const t=(e-xr)/Er;let n,r,s;for(n=e-xr,r=0;n%Er===br;n/=Er,r++);for(s=Er;s<e&&Tr(s,t,e)!==e-xr;s++)if(s>1e3)throw new Error("Cannot find square root: likely non-prime P");if(1===r){const t=(e+xr)/Or;return function(e,n){const r=e.pow(n,t);if(!e.eql(e.sqr(r),n))throw new Error("Cannot find square root");return r}}const i=(n+xr)/Er;return function(e,a){if(e.pow(a,t)===e.neg(e.ONE))throw new Error("Cannot find square root");let o=r,c=e.pow(e.mul(e.ONE,s),n),d=e.pow(a,i),u=e.pow(a,n);for(;!e.eql(u,e.ONE);){if(e.eql(u,e.ZERO))return e.ZERO;let t=1;for(let n=e.sqr(u);t<o&&!e.eql(n,e.ONE);t++)n=e.sqr(n);const n=e.pow(c,xr<<BigInt(o-t-1));c=e.sqr(n),d=e.mul(d,n),u=e.mul(u,c),o=t}return d}}(e)}const Cr=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function jr(e,t){const n=void 0!==t?t:e.toString(2).length;return{nBitLength:n,nByteLength:Math.ceil(n/8)}}function Rr(e,t,n=!1,r={}){if(e<=br)throw new Error("invalid field: expected ORDER > 0, got "+e);const{nBitLength:s,nByteLength:i}=jr(e,t);if(i>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let a;const o=Object.freeze({ORDER:e,BITS:s,BYTES:i,MASK:pr(s),ZERO:br,ONE:xr,create:t=>Nr(t,e),isValid:t=>{if("bigint"!=typeof t)throw new Error("invalid field element: expected bigint, got "+typeof t);return br<=t&&t<e},is0:e=>e===br,isOdd:e=>(e&xr)===xr,neg:t=>Nr(-t,e),eql:(e,t)=>e===t,sqr:t=>Nr(t*t,e),add:(t,n)=>Nr(t+n,e),sub:(t,n)=>Nr(t-n,e),mul:(t,n)=>Nr(t*n,e),pow:(e,t)=>function(e,t,n){if(n<br)throw new Error("invalid exponent, negatives unsupported");if(n===br)return e.ONE;if(n===xr)return t;let r=e.ONE,s=t;for(;n>br;)n&xr&&(r=e.mul(r,s)),s=e.sqr(s),n>>=xr;return r}(o,e,t),div:(t,n)=>Nr(t*Ir(n,e),e),sqrN:e=>e*e,addN:(e,t)=>e+t,subN:(e,t)=>e-t,mulN:(e,t)=>e*t,inv:t=>Ir(t,e),sqrt:r.sqrt||(t=>(a||(a=Br(e)),a(o,t))),invertBatch:e=>function(e,t){const n=new Array(t.length),r=t.reduce(((t,r,s)=>e.is0(r)?t:(n[s]=t,e.mul(t,r))),e.ONE),s=e.inv(r);return t.reduceRight(((t,r,s)=>e.is0(r)?t:(n[s]=e.mul(t,n[s]),e.mul(t,r))),s),n}(o,e),cmov:(e,t,n)=>n?t:e,toBytes:e=>n?or(e,i):ar(e,i),fromBytes:e=>{if(e.length!==i)throw new Error("Field.fromBytes: expected "+i+" bytes, got "+e.length);return n?ir(e):sr(e)}});return Object.freeze(o)}function Pr(e){if("bigint"!=typeof e)throw new Error("field order must be bigint");const t=e.toString(2).length;return Math.ceil(t/8)}function Lr(e){const t=Pr(e);return t+Math.ceil(t/2)}const Ur=BigInt(0),$r=BigInt(1);function Mr(e,t){const n=t.negate();return e?n:t}function zr(e,t){if(!Number.isSafeInteger(e)||e<=0||e>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+e)}function qr(e,t){zr(e,t);return{windows:Math.ceil(t/e)+1,windowSize:2**(e-1)}}function Dr(e,t){if(!Array.isArray(e))throw new Error("array expected");e.forEach(((e,n)=>{if(!(e instanceof t))throw new Error("invalid point at index "+n)}))}function Fr(e,t){if(!Array.isArray(e))throw new Error("array of scalars expected");e.forEach(((e,n)=>{if(!t.isValid(e))throw new Error("invalid scalar at index "+n)}))}const Vr=new WeakMap,Hr=new WeakMap;function Kr(e){return Hr.get(e)||1}function Wr(e){return function(e){const t=Cr.reduce(((e,t)=>(e[t]="function",e)),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"});wr(e,t)}(e.Fp),wr(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...jr(e.n,e.nBitLength),...e,p:e.Fp.ORDER})}function Jr(e){void 0!==e.lowS&&Gn("lowS",e.lowS),void 0!==e.prehash&&Gn("prehash",e.prehash)}const{Ph:Gr,aT:Yr}=e,Xr={Err:class extends Error{constructor(e=""){super(e)}},_tlv:{encode:(e,t)=>{const{Err:n}=Xr;if(e<0||e>256)throw new n("tlv.encode: wrong tag");if(1&t.length)throw new n("tlv.encode: unpadded data");const r=t.length/2,s=Qn(r);if(s.length/2&128)throw new n("tlv.encode: long form length too big");const i=r>127?Qn(s.length/2|128):"";return Qn(e)+i+s+t},decode(e,t){const{Err:n}=Xr;let r=0;if(e<0||e>256)throw new n("tlv.encode: wrong tag");if(t.length<2||t[r++]!==e)throw new n("tlv.decode: wrong tlv");const s=t[r++];let i=0;if(!!(128&s)){const e=127&s;if(!e)throw new n("tlv.decode(long): indefinite length not supported");if(e>4)throw new n("tlv.decode(long): byte length is too big");const a=t.subarray(r,r+e);if(a.length!==e)throw new n("tlv.decode: length bytes not complete");if(0===a[0])throw new n("tlv.decode(long): zero leftmost byte");for(const e of a)i=i<<8|e;if(r+=e,i<128)throw new n("tlv.decode(long): not minimal encoding")}else i=s;const a=t.subarray(r,r+i);if(a.length!==i)throw new n("tlv.decode: wrong value length");return{v:a,l:t.subarray(r+i)}}},_int:{encode(e){const{Err:t}=Xr;if(e<Qr)throw new t("integer: negative integers are not allowed");let n=Qn(e);if(8&Number.parseInt(n[0],16)&&(n="00"+n),1&n.length)throw new t("unexpected DER parsing assertion: unpadded hex");return n},decode(e){const{Err:t}=Xr;if(128&e[0])throw new t("invalid signature integer: negative");if(0===e[0]&&!(128&e[1]))throw new t("invalid signature integer: unnecessary leading zero");return Gr(e)}},toSig(e){const{Err:t,_int:n,_tlv:r}=Xr,s="string"==typeof e?Yr(e):e;Jn(s);const{v:i,l:a}=r.decode(48,s);if(a.length)throw new t("invalid signature: left bytes after parsing");const{v:o,l:c}=r.decode(2,i),{v:d,l:u}=r.decode(2,c);if(u.length)throw new t("invalid signature: left bytes after parsing");return{r:n.decode(o),s:n.decode(d)}},hexFromSig(e){const{_tlv:t,_int:n}=Xr,r=t.encode(2,n.encode(e.r))+t.encode(2,n.encode(e.s));return t.encode(48,r)}},Qr=BigInt(0),es=BigInt(1),ts=(BigInt(2),BigInt(3));BigInt(4);function ns(e){const t=function(e){const t=Wr(e);wr(t,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:n,Fp:r,a:s}=t;if(n){if(!r.eql(s,r.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if("object"!=typeof n||"bigint"!=typeof n.beta||"function"!=typeof n.splitScalar)throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...t})}(e),{Fp:n}=t,r=Rr(t.n,t.nBitLength),s=t.toBytes||((e,t,r)=>{const s=t.toAffine();return dr(Uint8Array.from([4]),n.toBytes(s.x),n.toBytes(s.y))}),i=t.fromBytes||(e=>{const t=e.subarray(1);return{x:n.fromBytes(t.subarray(0,n.BYTES)),y:n.fromBytes(t.subarray(n.BYTES,2*n.BYTES))}});function a(e){const{a:r,b:s}=t,i=n.sqr(e),a=n.mul(i,e);return n.add(n.add(a,n.mul(e,r)),s)}if(!n.eql(n.sqr(t.Gy),a(t.Gx)))throw new Error("bad generator point: equation left != right");function o(e){const{allowedPrivateKeyLengths:n,nByteLength:r,wrapPrivateKey:s,n:i}=t;if(n&&"bigint"!=typeof e){if(Wn(e)&&(e=Xn(e)),"string"!=typeof e||!n.includes(e.length))throw new Error("invalid private key");e=e.padStart(2*r,"0")}let a;try{a="bigint"==typeof e?e:sr(cr("private key",e,r))}catch(t){throw new Error("invalid private key, expected hex or "+r+" bytes, got "+typeof e)}return s&&(a=Nr(a,i)),hr("private key",a,es,i),a}function c(e){if(!(e instanceof l))throw new Error("ProjectivePoint expected")}const d=_r(((e,t)=>{const{px:r,py:s,pz:i}=e;if(n.eql(i,n.ONE))return{x:r,y:s};const a=e.is0();null==t&&(t=a?n.ONE:n.inv(i));const o=n.mul(r,t),c=n.mul(s,t),d=n.mul(i,t);if(a)return{x:n.ZERO,y:n.ZERO};if(!n.eql(d,n.ONE))throw new Error("invZ was invalid");return{x:o,y:c}})),u=_r((e=>{if(e.is0()){if(t.allowInfinityPoint&&!n.is0(e.py))return;throw new Error("bad point: ZERO")}const{x:r,y:s}=e.toAffine();if(!n.isValid(r)||!n.isValid(s))throw new Error("bad point: x or y not FE");const i=n.sqr(s),o=a(r);if(!n.eql(i,o))throw new Error("bad point: equation left != right");if(!e.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0}));class l{constructor(e,t,r){if(this.px=e,this.py=t,this.pz=r,null==e||!n.isValid(e))throw new Error("x required");if(null==t||!n.isValid(t))throw new Error("y required");if(null==r||!n.isValid(r))throw new Error("z required");Object.freeze(this)}static fromAffine(e){const{x:t,y:r}=e||{};if(!e||!n.isValid(t)||!n.isValid(r))throw new Error("invalid affine point");if(e instanceof l)throw new Error("projective point not allowed");const s=e=>n.eql(e,n.ZERO);return s(t)&&s(r)?l.ZERO:new l(t,r,n.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(e){const t=n.invertBatch(e.map((e=>e.pz)));return e.map(((e,n)=>e.toAffine(t[n]))).map(l.fromAffine)}static fromHex(e){const t=l.fromAffine(i(cr("pointHex",e)));return t.assertValidity(),t}static fromPrivateKey(e){return l.BASE.multiply(o(e))}static msm(e,t){return function(e,t,n,r){if(Dr(n,e),Fr(r,t),n.length!==r.length)throw new Error("arrays of points and scalars must have equal length");const s=e.ZERO,i=fr(BigInt(n.length)),a=i>12?i-3:i>4?i-2:i?2:1,o=(1<<a)-1,c=new Array(o+1).fill(s);let d=s;for(let e=Math.floor((t.BITS-1)/a)*a;e>=0;e-=a){c.fill(s);for(let t=0;t<r.length;t++){const s=r[t],i=Number(s>>BigInt(e)&BigInt(o));c[i]=c[i].add(n[t])}let t=s;for(let e=c.length-1,n=s;e>0;e--)n=n.add(c[e]),t=t.add(n);if(d=d.add(t),0!==e)for(let e=0;e<a;e++)d=d.double()}return d}(l,r,e,t)}_setWindowSize(e){f.setWindowSize(this,e)}assertValidity(){u(this)}hasEvenY(){const{y:e}=this.toAffine();if(n.isOdd)return!n.isOdd(e);throw new Error("Field doesn\'t support isOdd")}equals(e){c(e);const{px:t,py:r,pz:s}=this,{px:i,py:a,pz:o}=e,d=n.eql(n.mul(t,o),n.mul(i,s)),u=n.eql(n.mul(r,o),n.mul(a,s));return d&&u}negate(){return new l(this.px,n.neg(this.py),this.pz)}double(){const{a:e,b:r}=t,s=n.mul(r,ts),{px:i,py:a,pz:o}=this;let c=n.ZERO,d=n.ZERO,u=n.ZERO,h=n.mul(i,i),f=n.mul(a,a),p=n.mul(o,o),m=n.mul(i,a);return m=n.add(m,m),u=n.mul(i,o),u=n.add(u,u),c=n.mul(e,u),d=n.mul(s,p),d=n.add(c,d),c=n.sub(f,d),d=n.add(f,d),d=n.mul(c,d),c=n.mul(m,c),u=n.mul(s,u),p=n.mul(e,p),m=n.sub(h,p),m=n.mul(e,m),m=n.add(m,u),u=n.add(h,h),h=n.add(u,h),h=n.add(h,p),h=n.mul(h,m),d=n.add(d,h),p=n.mul(a,o),p=n.add(p,p),h=n.mul(p,m),c=n.sub(c,h),u=n.mul(p,f),u=n.add(u,u),u=n.add(u,u),new l(c,d,u)}add(e){c(e);const{px:r,py:s,pz:i}=this,{px:a,py:o,pz:d}=e;let u=n.ZERO,h=n.ZERO,f=n.ZERO;const p=t.a,m=n.mul(t.b,ts);let g=n.mul(r,a),y=n.mul(s,o),v=n.mul(i,d),w=n.add(r,s),_=n.add(a,o);w=n.mul(w,_),_=n.add(g,y),w=n.sub(w,_),_=n.add(r,i);let b=n.add(a,d);return _=n.mul(_,b),b=n.add(g,v),_=n.sub(_,b),b=n.add(s,i),u=n.add(o,d),b=n.mul(b,u),u=n.add(y,v),b=n.sub(b,u),f=n.mul(p,_),u=n.mul(m,v),f=n.add(u,f),u=n.sub(y,f),f=n.add(y,f),h=n.mul(u,f),y=n.add(g,g),y=n.add(y,g),v=n.mul(p,v),_=n.mul(m,_),y=n.add(y,v),v=n.sub(g,v),v=n.mul(p,v),_=n.add(_,v),g=n.mul(y,_),h=n.add(h,g),g=n.mul(b,_),u=n.mul(w,u),u=n.sub(u,g),g=n.mul(w,y),f=n.mul(b,f),f=n.add(f,g),new l(u,h,f)}subtract(e){return this.add(e.negate())}is0(){return this.equals(l.ZERO)}wNAF(e){return f.wNAFCached(this,e,l.normalizeZ)}multiplyUnsafe(e){const{endo:r,n:s}=t;hr("scalar",e,Qr,s);const i=l.ZERO;if(e===Qr)return i;if(this.is0()||e===es)return this;if(!r||f.hasPrecomputes(this))return f.wNAFCachedUnsafe(this,e,l.normalizeZ);let{k1neg:a,k1:o,k2neg:c,k2:d}=r.splitScalar(e),u=i,h=i,p=this;for(;o>Qr||d>Qr;)o&es&&(u=u.add(p)),d&es&&(h=h.add(p)),p=p.double(),o>>=es,d>>=es;return a&&(u=u.negate()),c&&(h=h.negate()),h=new l(n.mul(h.px,r.beta),h.py,h.pz),u.add(h)}multiply(e){const{endo:r,n:s}=t;let i,a;if(hr("scalar",e,es,s),r){const{k1neg:t,k1:s,k2neg:o,k2:c}=r.splitScalar(e);let{p:d,f:u}=this.wNAF(s),{p:h,f:p}=this.wNAF(c);d=f.constTimeNegate(t,d),h=f.constTimeNegate(o,h),h=new l(n.mul(h.px,r.beta),h.py,h.pz),i=d.add(h),a=u.add(p)}else{const{p:t,f:n}=this.wNAF(e);i=t,a=n}return l.normalizeZ([i,a])[0]}multiplyAndAddUnsafe(e,t,n){const r=l.BASE,s=(e,t)=>t!==Qr&&t!==es&&e.equals(r)?e.multiply(t):e.multiplyUnsafe(t),i=s(this,t).add(s(e,n));return i.is0()?void 0:i}toAffine(e){return d(this,e)}isTorsionFree(){const{h:e,isTorsionFree:n}=t;if(e===es)return!0;if(n)return n(l,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:e,clearCofactor:n}=t;return e===es?this:n?n(l,this):this.multiplyUnsafe(t.h)}toRawBytes(e=!0){return Gn("isCompressed",e),this.assertValidity(),s(l,this,e)}toHex(e=!0){return Gn("isCompressed",e),Xn(this.toRawBytes(e))}}l.BASE=new l(t.Gx,t.Gy,n.ONE),l.ZERO=new l(n.ZERO,n.ONE,n.ZERO);const h=t.nBitLength,f=(p=l,m=t.endo?Math.ceil(h/2):h,{constTimeNegate:Mr,hasPrecomputes:e=>1!==Kr(e),unsafeLadder(e,t,n=p.ZERO){let r=e;for(;t>Ur;)t&$r&&(n=n.add(r)),r=r.double(),t>>=$r;return n},precomputeWindow(e,t){const{windows:n,windowSize:r}=qr(t,m),s=[];let i=e,a=i;for(let e=0;e<n;e++){a=i,s.push(a);for(let e=1;e<r;e++)a=a.add(i),s.push(a);i=a.double()}return s},wNAF(e,t,n){const{windows:r,windowSize:s}=qr(e,m);let i=p.ZERO,a=p.BASE;const o=BigInt(2**e-1),c=2**e,d=BigInt(e);for(let e=0;e<r;e++){const r=e*s;let u=Number(n&o);n>>=d,u>s&&(u-=c,n+=$r);const l=r,h=r+Math.abs(u)-1,f=e%2!=0,p=u<0;0===u?a=a.add(Mr(f,t[l])):i=i.add(Mr(p,t[h]))}return{p:i,f:a}},wNAFUnsafe(e,t,n,r=p.ZERO){const{windows:s,windowSize:i}=qr(e,m),a=BigInt(2**e-1),o=2**e,c=BigInt(e);for(let e=0;e<s;e++){const s=e*i;if(n===Ur)break;let d=Number(n&a);if(n>>=c,d>i&&(d-=o,n+=$r),0===d)continue;let u=t[s+Math.abs(d)-1];d<0&&(u=u.negate()),r=r.add(u)}return r},getPrecomputes(e,t,n){let r=Vr.get(t);return r||(r=this.precomputeWindow(t,e),1!==e&&Vr.set(t,n(r))),r},wNAFCached(e,t,n){const r=Kr(e);return this.wNAF(r,this.getPrecomputes(r,e,n),t)},wNAFCachedUnsafe(e,t,n,r){const s=Kr(e);return 1===s?this.unsafeLadder(e,t,r):this.wNAFUnsafe(s,this.getPrecomputes(s,e,n),t,r)},setWindowSize(e,t){zr(t,m),Hr.set(e,t),Vr.delete(e)}});var p,m;return{CURVE:t,ProjectivePoint:l,normPrivateKeyToScalar:o,weierstrassEquation:a,isWithinCurveOrder:function(e){return lr(e,es,t.n)}}}function rs(e){const t=function(e){const t=Wr(e);return wr(t,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...t})}(e),{Fp:n,n:r}=t,s=n.BYTES+1,i=2*n.BYTES+1;function a(e){return Nr(e,r)}function o(e){return Ir(e,r)}const{ProjectivePoint:c,normPrivateKeyToScalar:d,weierstrassEquation:u,isWithinCurveOrder:l}=ns({...t,toBytes(e,t,r){const s=t.toAffine(),i=n.toBytes(s.x),a=dr;return Gn("isCompressed",r),r?a(Uint8Array.from([t.hasEvenY()?2:3]),i):a(Uint8Array.from([4]),i,n.toBytes(s.y))},fromBytes(e){const t=e.length,r=e[0],a=e.subarray(1);if(t!==s||2!==r&&3!==r){if(t===i&&4===r){return{x:n.fromBytes(a.subarray(0,n.BYTES)),y:n.fromBytes(a.subarray(n.BYTES,2*n.BYTES))}}throw new Error("invalid Point, expected length of "+s+", or uncompressed "+i+", got "+t)}{const e=sr(a);if(!lr(e,es,n.ORDER))throw new Error("Point is not on curve");const t=u(e);let s;try{s=n.sqrt(t)}catch(e){const t=e instanceof Error?": "+e.message:"";throw new Error("Point is not on curve"+t)}return!(1&~r)!==((s&es)===es)&&(s=n.neg(s)),{x:e,y:s}}}}),h=e=>Xn(ar(e,t.nByteLength));function f(e){return e>r>>es}const p=(e,t,n)=>sr(e.slice(t,n));class m{constructor(e,t,n){this.r=e,this.s=t,this.recovery=n,this.assertValidity()}static fromCompact(e){const n=t.nByteLength;return e=cr("compactSignature",e,2*n),new m(p(e,0,n),p(e,n,2*n))}static fromDER(e){const{r:t,s:n}=Xr.toSig(cr("DER",e));return new m(t,n)}assertValidity(){hr("r",this.r,es,r),hr("s",this.s,es,r)}addRecoveryBit(e){return new m(this.r,this.s,e)}recoverPublicKey(e){const{r,s,recovery:i}=this,d=w(cr("msgHash",e));if(null==i||![0,1,2,3].includes(i))throw new Error("recovery id invalid");const u=2===i||3===i?r+t.n:r;if(u>=n.ORDER)throw new Error("recovery id 2 or 3 invalid");const l=1&i?"03":"02",f=c.fromHex(l+h(u)),p=o(u),m=a(-d*p),g=a(s*p),y=c.BASE.multiplyAndAddUnsafe(f,m,g);if(!y)throw new Error("point at infinify");return y.assertValidity(),y}hasHighS(){return f(this.s)}normalizeS(){return this.hasHighS()?new m(this.r,a(-this.s),this.recovery):this}toDERRawBytes(){return rr(this.toDERHex())}toDERHex(){return Xr.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return rr(this.toCompactHex())}toCompactHex(){return h(this.r)+h(this.s)}}const g={isValidPrivateKey(e){try{return d(e),!0}catch(e){return!1}},normPrivateKeyToScalar:d,randomPrivateKey:()=>{const e=Lr(t.n);return function(e,t,n=!1){const r=e.length,s=Pr(t),i=Lr(t);if(r<16||r<i||r>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+r);const a=Nr(n?sr(e):ir(e),t-xr)+xr;return n?or(a,s):ar(a,s)}(t.randomBytes(e),t.n)},precompute:(e=8,t=c.BASE)=>(t._setWindowSize(e),t.multiply(BigInt(3)),t)};function y(e){const t=Wn(e),n="string"==typeof e,r=(t||n)&&e.length;return t?r===s||r===i:n?r===2*s||r===2*i:e instanceof c}const v=t.bits2int||function(e){if(e.length>8192)throw new Error("input is too large");const n=sr(e),r=8*e.length-t.nBitLength;return r>0?n>>BigInt(r):n},w=t.bits2int_modN||function(e){return a(v(e))},_=pr(t.nBitLength);function b(e){return hr("num < 2^"+t.nBitLength,e,Qr,_),ar(e,t.nByteLength)}function x(e,r,s=E){if(["recovered","canonical"].some((e=>e in s)))throw new Error("sign() legacy options not supported");const{hash:i,randomBytes:u}=t;let{lowS:h,prehash:p,extraEntropy:g}=s;null==h&&(h=!0),e=cr("msgHash",e),Jr(s),p&&(e=cr("prehashed msgHash",i(e)));const y=w(e),_=d(r),x=[b(_),b(y)];if(null!=g&&!1!==g){const e=!0===g?u(n.BYTES):g;x.push(cr("extraEntropy",e))}const k=dr(...x),O=y;return{seed:k,k2sig:function(e){const t=v(e);if(!l(t))return;const n=o(t),r=c.BASE.multiply(t).toAffine(),s=a(r.x);if(s===Qr)return;const i=a(n*a(O+s*_));if(i===Qr)return;let d=(r.x===s?0:2)|Number(r.y&es),u=i;return h&&f(i)&&(u=function(e){return f(e)?a(-e):e}(i),d^=1),new m(s,u,d)}}}const E={lowS:t.lowS,prehash:!1},k={lowS:t.lowS,prehash:!1};return c.BASE._setWindowSize(8),{CURVE:t,getPublicKey:function(e,t=!0){return c.fromPrivateKey(e).toRawBytes(t)},getSharedSecret:function(e,t,n=!0){if(y(e))throw new Error("first arg must be private key");if(!y(t))throw new Error("second arg must be public key");return c.fromHex(t).multiply(d(e)).toRawBytes(n)},sign:function(e,n,r=E){const{seed:s,k2sig:i}=x(e,n,r),a=t;return yr(a.hash.outputLen,a.nByteLength,a.hmac)(s,i)},verify:function(e,n,r,s=k){const i=e;n=cr("msgHash",n),r=cr("publicKey",r);const{lowS:d,prehash:u,format:l}=s;if(Jr(s),"strict"in s)throw new Error("options.strict was renamed to lowS");if(void 0!==l&&"compact"!==l&&"der"!==l)throw new Error("format must be compact or der");const h="string"==typeof i||Wn(i),f=!h&&!l&&"object"==typeof i&&null!==i&&"bigint"==typeof i.r&&"bigint"==typeof i.s;if(!h&&!f)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let p,g;try{if(f&&(p=new m(i.r,i.s)),h){try{"compact"!==l&&(p=m.fromDER(i))}catch(e){if(!(e instanceof Xr.Err))throw e}p||"der"===l||(p=m.fromCompact(i))}g=c.fromHex(r)}catch(e){return!1}if(!p)return!1;if(d&&p.hasHighS())return!1;u&&(n=t.hash(n));const{r:y,s:v}=p,_=w(n),b=o(v),x=a(_*b),E=a(y*b),O=c.BASE.multiplyAndAddUnsafe(g,x,E)?.toAffine();return!!O&&a(O.x)===y},ProjectivePoint:c,Signature:m,utils:g}}function ss(e){return{hash:e,hmac:(t,...n)=>Fn(e,t,function(...e){let t=0;for(let n=0;n<e.length;n++){const r=e[n];Sn(r),t+=r.length}const n=new Uint8Array(t);for(let t=0,r=0;t<e.length;t++){const s=e[t];n.set(s,r),r+=s.length}return n}(...n)),randomBytes:Rn}}const is=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),as=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),os=BigInt(1),cs=BigInt(2),ds=(e,t)=>(e+t/cs)/t;function us(e){const t=is,n=BigInt(3),r=BigInt(6),s=BigInt(11),i=BigInt(22),a=BigInt(23),o=BigInt(44),c=BigInt(88),d=e*e*e%t,u=d*d*e%t,l=Zr(u,n,t)*u%t,h=Zr(l,n,t)*u%t,f=Zr(h,cs,t)*d%t,p=Zr(f,s,t)*f%t,m=Zr(p,i,t)*p%t,g=Zr(m,o,t)*m%t,y=Zr(g,c,t)*g%t,v=Zr(y,o,t)*m%t,w=Zr(v,n,t)*u%t,_=Zr(w,a,t)*p%t,b=Zr(_,r,t)*d%t,x=Zr(b,cs,t);if(!ls.eql(ls.sqr(x),e))throw new Error("Cannot find square root");return x}const ls=Rr(is,void 0,void 0,{sqrt:us}),hs=function(e,t){const n=t=>rs({...e,...ss(t)});return Object.freeze({...n(t),create:n})}({a:BigInt(0),b:BigInt(7),Fp:ls,n:as,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:e=>{const t=as,n=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-os*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),i=n,a=BigInt("0x100000000000000000000000000000000"),o=ds(i*e,t),c=ds(-r*e,t);let d=Nr(e-o*n-c*s,t),u=Nr(-o*r-c*i,t);const l=d>a,h=u>a;if(l&&(d=t-d),h&&(u=t-u),d>a||u>a)throw new Error("splitScalar: Endomorphism failed, k="+e);return{k1neg:l,k1:d,k2neg:h,k2:u}}}},qn);BigInt(0);hs.ProjectivePoint;function fs(e,...t){if(!((n=e)instanceof Uint8Array||ArrayBuffer.isView(n)&&"Uint8Array"===n.constructor.name))throw new Error("Uint8Array expected");var n;if(t.length>0&&!t.includes(e.length))throw new Error("Uint8Array expected of length "+t+", got length="+e.length)}function ps(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function ms(e,t){fs(e);const n=t.outputLen;if(e.length<n)throw new Error("digestInto() expects output buffer of length at least "+n)}const gs=e=>new DataView(e.buffer,e.byteOffset,e.byteLength),ys=(e,t)=>e<<32-t|e>>>t;Array.from({length:256},((e,t)=>t.toString(16).padStart(2,"0")));function vs(e){return"string"==typeof e&&(e=function(e){if("string"!=typeof e)throw new Error("utf8ToBytes expected string, got "+typeof e);return new Uint8Array((new TextEncoder).encode(e))}(e)),fs(e),e}class ws{clone(){return this._cloneInto()}}const _s=(e,t,n)=>e&t^e&n^t&n;class bs extends ws{constructor(e,t,n,r){super(),this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=r,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=gs(this.buffer)}update(e){ps(this);const{view:t,buffer:n,blockLen:r}=this,s=(e=vs(e)).length;for(let i=0;i<s;){const a=Math.min(r-this.pos,s-i);if(a!==r)n.set(e.subarray(i,i+a),this.pos),this.pos+=a,i+=a,this.pos===r&&(this.process(t,0),this.pos=0);else{const t=gs(e);for(;r<=s-i;i+=r)this.process(t,i)}}return this.length+=e.length,this.roundClean(),this}digestInto(e){ps(this),ms(e,this),this.finished=!0;const{buffer:t,view:n,blockLen:r,isLE:s}=this;let{pos:i}=this;t[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>r-i&&(this.process(n,0),i=0);for(let e=i;e<r;e++)t[e]=0;!function(e,t,n,r){if("function"==typeof e.setBigUint64)return e.setBigUint64(t,n,r);const s=BigInt(32),i=BigInt(4294967295),a=Number(n>>s&i),o=Number(n&i),c=r?4:0,d=r?0:4;e.setUint32(t+c,a,r),e.setUint32(t+d,o,r)}(n,r-8,BigInt(8*this.length),s),this.process(n,0);const a=gs(e),o=this.outputLen;if(o%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const c=o/4,d=this.get();if(c>d.length)throw new Error("_sha2: outputLen bigger than state");for(let e=0;e<c;e++)a.setUint32(4*e,d[e],s)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:n,length:r,finished:s,destroyed:i,pos:a}=this;return e.length=r,e.pos=a,e.finished=s,e.destroyed=i,r%t&&e.buffer.set(n),e}}const xs=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Es=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),ks=new Uint32Array(64);class Os extends bs{constructor(){super(64,32,8,!1),this.A=0|Es[0],this.B=0|Es[1],this.C=0|Es[2],this.D=0|Es[3],this.E=0|Es[4],this.F=0|Es[5],this.G=0|Es[6],this.H=0|Es[7]}get(){const{A:e,B:t,C:n,D:r,E:s,F:i,G:a,H:o}=this;return[e,t,n,r,s,i,a,o]}set(e,t,n,r,s,i,a,o){this.A=0|e,this.B=0|t,this.C=0|n,this.D=0|r,this.E=0|s,this.F=0|i,this.G=0|a,this.H=0|o}process(e,t){for(let n=0;n<16;n++,t+=4)ks[n]=e.getUint32(t,!1);for(let e=16;e<64;e++){const t=ks[e-15],n=ks[e-2],r=ys(t,7)^ys(t,18)^t>>>3,s=ys(n,17)^ys(n,19)^n>>>10;ks[e]=s+ks[e-7]+r+ks[e-16]|0}let{A:n,B:r,C:s,D:i,E:a,F:o,G:c,H:d}=this;for(let e=0;e<64;e++){const t=d+(ys(a,6)^ys(a,11)^ys(a,25))+((u=a)&o^~u&c)+xs[e]+ks[e]|0,l=(ys(n,2)^ys(n,13)^ys(n,22))+_s(n,r,s)|0;d=c,c=o,o=a,a=i+t|0,i=s,s=r,r=n,n=t+l|0}var u;n=n+this.A|0,r=r+this.B|0,s=s+this.C|0,i=i+this.D|0,a=a+this.E|0,o=o+this.F|0,c=c+this.G|0,d=d+this.H|0,this.set(n,r,s,i,a,o,c,d)}roundClean(){ks.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const Ss=function(e){const t=t=>e().update(vs(t)).digest(),n=e();return t.outputLen=n.outputLen,t.blockLen=n.blockLen,t.create=()=>e(),t}((()=>new Os));function As(e,t){return Ns(e,"pattern",(n=>t.test(n)||`Expected a ${e.type} matching \\`/${t.source}/\\` but received "${n}"`))}function Ns(e,t,n){return new f({...e,*refiner(r,s){yield*e.refiner(r,s);const i=l(n(r,s),s,e,r);for(const e of i)yield{...e,refinement:t}}})}As(A(),/^(?:0x)?[0-9a-f]+$/iu),As(A(),/^0x[0-9a-f]+$/iu),As(A(),/^0x[0-9a-f]{40}$/u),As(A(),/^0x[0-9a-fA-F]{40}$/u);function Ts(e){return e.startsWith("0x")||e.startsWith("0X")?e.substring(2):e}function Zs(e,...t){if(!((n=e)instanceof Uint8Array||null!=n&&"object"==typeof n&&"Uint8Array"===n.constructor.name))throw new Error("Uint8Array expected");var n;if(t.length>0&&!t.includes(e.length))throw new Error(`Uint8Array expected of length ${t}, not of length=${e.length}`)}if(!(68===new Uint8Array(new Uint32Array([287454020]).buffer)[0]))throw new Error("Non little-endian hardware is not supported");const Is=Array.from({length:256},((e,t)=>t.toString(16).padStart(2,"0")));function Bs(e){Zs(e);let t="";for(let n=0;n<e.length;n++)t+=Is[e[n]];return t}const Cs=48,js=57,Rs=65,Ps=70,Ls=97,Us=102;function $s(e){return e>=Cs&&e<=js?e-Cs:e>=Rs&&e<=Ps?e-(Rs-10):e>=Ls&&e<=Us?e-(Ls-10):void 0}function Ms(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);const t=e.length,n=t/2;if(t%2)throw new Error("padded hex string expected, got unpadded hex of length "+t);const r=new Uint8Array(n);for(let t=0,s=0;t<n;t++,s+=2){const n=$s(e.charCodeAt(s)),i=$s(e.charCodeAt(s+1));if(void 0===n||void 0===i){const t=e[s]+e[s+1];throw new Error(\'hex string expected, got non-hex character "\'+t+\'" at index \'+s)}r[t]=16*n+i}return r}async function zs(){const e=await async function(){return await snap.request({method:"snap_getEntropy",params:{version:1}})}();return Ms(Ts(e))}async function qs(){const e=await zs();return`0x${Bs(hs.getPublicKey(e))}`}const Ds=kn.object({message:kn.string().startsWith("metamask:")});const Fs=async({request:e})=>{switch(e.method){case"getPublicKey":return qs();case"signMessage":{const{params:t}=e;!function(e){try{Ds.parse(e)}catch{throw re({message:"`signMessage`, must take a `message` parameter that must begin with `metamask:`"})}}(t);const{message:n}=t;return await async function(e){const t=await zs(),n=Ss(e);return`0x${hs.sign(n,t).toCompactHex()}`}(n)}default:throw se({data:{method:e.method}})}}})();var s=exports;for(var i in r)s[i]=r[i];r.__esModule&&Object.defineProperty(s,"__esModule",{value:!0})})();',
                    },
                  ],
                  removable: !1,
                };
              };
            };
      },
      {
        package: '@metamask/message-signing-snap',
        file: 'node_modules/@metamask/message-signing-snap/dist/preinstalled-snap.json',
      },
    ],
    [
      211,
      { lodash: 4921 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = void 0);
                var r = e('lodash');
                n.default = {
                  version: 7,
                  migrate(e) {
                    const t = (0, r.cloneDeep)(e);
                    t.meta.version = 7;
                    try {
                      const e = (function (e) {
                        const t = {
                          ...e,
                          TransactionManager: {
                            transactions: e.transactions || [],
                            gasMultiplier: e.gasMultiplier || 1,
                          },
                        };
                        return delete t.transactions, delete t.gasMultiplier, t;
                      })(t.data);
                      t.data = e;
                    } catch (e) {
                      console.warn(`MetaMask Migration #7${e.stack}`);
                    }
                    return Promise.resolve(t);
                  },
                };
              };
            };
      },
      { package: '$root$', file: 'app/scripts/migrations/007.js' },
    ],
    [
      2114,
      {},
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                var r;
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.MultichainApiNotifications = void 0),
                  (function (e) {
                    (e.sessionChanged = 'wallet_sessionChanged'),
                      (e.walletNotify = 'wallet_notify');
                  })(r || (n.MultichainApiNotifications = r = {}));
              };
            };
      },
      {
        package: '@metamask/multichain-api-middleware',
        file: 'node_modules/@metamask/multichain-api-middleware/dist/handlers/types.cjs',
      },
    ],
    [
      2115,
      { '@metamask/chain-agnostic-permission': 2129 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.walletGetSession = void 0);
                const r = e('@metamask/chain-agnostic-permission');
                n.walletGetSession = {
                  methodNames: ['wallet_getSession'],
                  implementation: async function (e, t, n, s, a) {
                    let o;
                    try {
                      o = a.getCaveatForOrigin(r.Caip25EndowmentPermissionName, r.Caip25CaveatType);
                    } catch {}
                    return o
                      ? ((t.result = {
                          sessionScopes: (0, r.getSessionScopes)(o.value, {
                            getNonEvmSupportedMethods: a.getNonEvmSupportedMethods,
                          }),
                        }),
                        s())
                      : ((t.result = { sessionScopes: {} }), s());
                  },
                  hookNames: { getCaveatForOrigin: !0, getNonEvmSupportedMethods: !0 },
                };
              };
            };
      },
      {
        package: '@metamask/multichain-api-middleware',
        file: 'node_modules/@metamask/multichain-api-middleware/dist/handlers/wallet-getSession.cjs',
      },
    ],
    [
      2116,
      {
        '@metamask/chain-agnostic-permission': 2129,
        '@metamask/rpc-errors': 2585,
        '@metamask/utils': 2995,
      },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.walletInvokeMethod = void 0);
                const r = e('@metamask/chain-agnostic-permission'),
                  s = e('@metamask/rpc-errors'),
                  a = e('@metamask/utils');
                n.walletInvokeMethod = {
                  methodNames: ['wallet_invokeMethod'],
                  implementation: async function (e, t, n, o, i) {
                    const { scope: c, request: l } = e.params;
                    let d;
                    (0, r.assertIsInternalScopeString)(c);
                    try {
                      d = i.getCaveatForOrigin(r.Caip25EndowmentPermissionName, r.Caip25CaveatType);
                    } catch {}
                    if (!d?.value?.isMultichainOrigin) return o(s.providerErrors.unauthorized());
                    const u = (0, r.getSessionScopes)(d.value, {
                      getNonEvmSupportedMethods: i.getNonEvmSupportedMethods,
                    })[c];
                    if (!u?.methods?.includes(l.method)) return o(s.providerErrors.unauthorized());
                    const { namespace: h, reference: p } = (0, r.parseScopeString)(c),
                      m =
                        (h === a.KnownCaipNamespace.Wallet &&
                          (!p || p === a.KnownCaipNamespace.Eip155)) ||
                        h === a.KnownCaipNamespace.Eip155,
                      f = { ...e, scope: c, method: l.method, params: l.params };
                    if (m) {
                      let t;
                      return (
                        h === a.KnownCaipNamespace.Wallet
                          ? (t = i.getSelectedNetworkClientId())
                          : h === a.KnownCaipNamespace.Eip155 &&
                            p &&
                            (t = i.findNetworkClientIdByChainId(
                              (0, a.numberToHex)(parseInt(p, 10))
                            )),
                        t
                          ? (Object.assign(e, { ...f, networkClientId: t }), n())
                          : (console.error(
                              'failed to resolve network client for wallet_invokeMethod',
                              e
                            ),
                            o(s.rpcErrors.internal()))
                      );
                    }
                    try {
                      t.result = await i.handleNonEvmRequestForOrigin({
                        connectedAddresses: u.accounts,
                        scope: c,
                        request: f,
                      });
                    } catch (e) {
                      return o(e);
                    }
                    return o();
                  },
                  hookNames: {
                    getCaveatForOrigin: !0,
                    findNetworkClientIdByChainId: !0,
                    getSelectedNetworkClientId: !0,
                    getNonEvmSupportedMethods: !0,
                    handleNonEvmRequestForOrigin: !0,
                  },
                };
              };
            };
      },
      {
        package: '@metamask/multichain-api-middleware',
        file: 'node_modules/@metamask/multichain-api-middleware/dist/handlers/wallet-invokeMethod.cjs',
      },
    ],
    [
      2117,
      {
        '@metamask/chain-agnostic-permission': 2129,
        '@metamask/permission-controller': 2421,
        '@metamask/rpc-errors': 2585,
      },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.walletRevokeSession = void 0);
                const r = e('@metamask/chain-agnostic-permission'),
                  s = e('@metamask/permission-controller'),
                  a = e('@metamask/rpc-errors');
                n.walletRevokeSession = {
                  methodNames: ['wallet_revokeSession'],
                  implementation: async function (e, t, n, o, i) {
                    try {
                      i.revokePermissionForOrigin(r.Caip25EndowmentPermissionName);
                    } catch (e) {
                      if (
                        !(
                          e instanceof s.UnrecognizedSubjectError ||
                          e instanceof s.PermissionDoesNotExistError
                        )
                      )
                        return console.error(e), o(a.rpcErrors.internal());
                    }
                    return (t.result = !0), o();
                  },
                  hookNames: { revokePermissionForOrigin: !0 },
                };
              };
            };
      },
      {
        package: '@metamask/multichain-api-middleware',
        file: 'node_modules/@metamask/multichain-api-middleware/dist/handlers/wallet-revokeSession.cjs',
      },
    ],
    [
      2118,
      {
        './handlers/types.cjs': 2114,
        './handlers/wallet-getSession.cjs': 2115,
        './handlers/wallet-invokeMethod.cjs': 2116,
        './handlers/wallet-revokeSession.cjs': 2117,
        './middlewares/MultichainMiddlewareManager.cjs': 2119,
        './middlewares/MultichainSubscriptionManager.cjs': 2120,
        './middlewares/multichainMethodCallValidatorMiddleware.cjs': 2121,
      },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.MultichainApiNotifications =
                    n.MultichainSubscriptionManager =
                    n.MultichainMiddlewareManager =
                    n.multichainMethodCallValidatorMiddleware =
                    n.walletRevokeSession =
                    n.walletInvokeMethod =
                    n.walletGetSession =
                      void 0);
                var r = e('./handlers/wallet-getSession.cjs');
                Object.defineProperty(n, 'walletGetSession', {
                  enumerable: !0,
                  get: function () {
                    return r.walletGetSession;
                  },
                });
                var s = e('./handlers/wallet-invokeMethod.cjs');
                Object.defineProperty(n, 'walletInvokeMethod', {
                  enumerable: !0,
                  get: function () {
                    return s.walletInvokeMethod;
                  },
                });
                var a = e('./handlers/wallet-revokeSession.cjs');
                Object.defineProperty(n, 'walletRevokeSession', {
                  enumerable: !0,
                  get: function () {
                    return a.walletRevokeSession;
                  },
                });
                var o = e('./middlewares/multichainMethodCallValidatorMiddleware.cjs');
                Object.defineProperty(n, 'multichainMethodCallValidatorMiddleware', {
                  enumerable: !0,
                  get: function () {
                    return o.multichainMethodCallValidatorMiddleware;
                  },
                });
                var i = e('./middlewares/MultichainMiddlewareManager.cjs');
                Object.defineProperty(n, 'MultichainMiddlewareManager', {
                  enumerable: !0,
                  get: function () {
                    return i.MultichainMiddlewareManager;
                  },
                });
                var c = e('./middlewares/MultichainSubscriptionManager.cjs');
                Object.defineProperty(n, 'MultichainSubscriptionManager', {
                  enumerable: !0,
                  get: function () {
                    return c.MultichainSubscriptionManager;
                  },
                });
                var l = e('./handlers/types.cjs');
                Object.defineProperty(n, 'MultichainApiNotifications', {
                  enumerable: !0,
                  get: function () {
                    return l.MultichainApiNotifications;
                  },
                });
              };
            };
      },
      {
        package: '@metamask/multichain-api-middleware',
        file: 'node_modules/@metamask/multichain-api-middleware/dist/index.cjs',
      },
    ],
    [
      2119,
      { '@metamask/rpc-errors': 2585 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                var r,
                  s,
                  a,
                  o,
                  i,
                  c =
                    (this && this.__classPrivateFieldGet) ||
                    function (e, t, n, r) {
                      if ('a' === n && !r)
                        throw new TypeError('Private accessor was defined without a getter');
                      if ('function' == typeof t ? e !== t || !r : !t.has(e))
                        throw new TypeError(
                          'Cannot read private member from an object whose class did not declare it'
                        );
                      return 'm' === n ? r : 'a' === n ? r.call(e) : r ? r.value : t.get(e);
                    },
                  l =
                    (this && this.__classPrivateFieldSet) ||
                    function (e, t, n, r, s) {
                      if ('m' === r) throw new TypeError('Private method is not writable');
                      if ('a' === r && !s)
                        throw new TypeError('Private accessor was defined without a setter');
                      if ('function' == typeof t ? e !== t || !s : !t.has(e))
                        throw new TypeError(
                          'Cannot write private member to an object whose class did not declare it'
                        );
                      return 'a' === r ? s.call(e, n) : s ? (s.value = n) : t.set(e, n), n;
                    };
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.MultichainMiddlewareManager = void 0);
                const d = e('@metamask/rpc-errors'),
                  u = ['eth_subscribe', 'eth_unsubscribe'];
                (n.MultichainMiddlewareManager = class {
                  constructor() {
                    r.add(this), s.set(this, []);
                  }
                  addMiddleware(e) {
                    const { scope: t, origin: n, tabId: o } = e;
                    c(this, r, 'm', a).call(this, { scope: t, origin: n, tabId: o }) ||
                      c(this, s, 'f').push(e);
                  }
                  removeMiddlewareByScope(e) {
                    c(this, s, 'f').forEach(t => {
                      t.scope === e && c(this, r, 'm', i).call(this, t);
                    });
                  }
                  removeMiddlewareByScopeAndOrigin(e, t) {
                    c(this, s, 'f').forEach(n => {
                      n.scope === e && n.origin === t && c(this, r, 'm', i).call(this, n);
                    });
                  }
                  removeMiddlewareByOriginAndTabId(e, t) {
                    c(this, s, 'f').forEach(n => {
                      n.origin === e && n.tabId === t && c(this, r, 'm', i).call(this, n);
                    });
                  }
                  generateMultichainMiddlewareForOriginAndTabId(e, t) {
                    const n = (n, s, o, i) => {
                      const { scope: l } = n,
                        h = c(this, r, 'm', a).call(this, { scope: l, origin: e, tabId: t });
                      return u.includes(n.method)
                        ? h
                          ? (h.middleware(n, s, o, i), undefined)
                          : i(d.rpcErrors.methodNotFound())
                        : o();
                    };
                    return (n.destroy = this.removeMiddlewareByOriginAndTabId.bind(this, e, t)), n;
                  }
                }),
                  (s = new WeakMap()),
                  (r = new WeakSet()),
                  (a = function ({ scope: e, origin: t, tabId: n }) {
                    return c(this, s, 'f').find(
                      r => r.scope === e && r.origin === t && r.tabId === n
                    );
                  }),
                  (o = function ({ scope: e, origin: t, tabId: n }) {
                    l(
                      this,
                      s,
                      c(this, s, 'f').filter(r => r.scope !== e || r.origin !== t || r.tabId !== n),
                      'f'
                    );
                  }),
                  (i = function (e) {
                    Promise.resolve(e.middleware.destroy?.()).catch(() => {}),
                      c(this, r, 'm', o).call(this, e);
                  });
              };
            };
      },
      {
        package: '@metamask/multichain-api-middleware',
        file: 'node_modules/@metamask/multichain-api-middleware/dist/middlewares/MultichainMiddlewareManager.cjs',
      },
    ],
    [
      212,
      { lodash: 4921 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = void 0);
                var r = e('lodash');
                n.default = {
                  version: 8,
                  migrate(e) {
                    const t = (0, r.cloneDeep)(e);
                    t.meta.version = 8;
                    try {
                      const e = (function (e) {
                        const t = { ...e, NoticeController: { noticesList: e.noticesList || [] } };
                        return delete t.noticesList, t;
                      })(t.data);
                      t.data = e;
                    } catch (e) {
                      console.warn(`MetaMask Migration #8${e.stack}`);
                    }
                    return Promise.resolve(t);
                  },
                };
              };
            };
      },
      { package: '$root$', file: 'app/scripts/migrations/008.js' },
    ],
    [
      2120,
      {
        '../handlers/types.cjs': 2114,
        '@metamask/controller-utils': 1515,
        '@metamask/eth-json-rpc-filters/subscriptionManager.js': 1602,
        '@metamask/safe-event-emitter': 2587,
        '@metamask/utils': 2995,
      },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                var r,
                  s,
                  a,
                  o,
                  i,
                  c,
                  l,
                  d =
                    (this && this.__classPrivateFieldSet) ||
                    function (e, t, n, r, s) {
                      if ('m' === r) throw new TypeError('Private method is not writable');
                      if ('a' === r && !s)
                        throw new TypeError('Private accessor was defined without a setter');
                      if ('function' == typeof t ? e !== t || !s : !t.has(e))
                        throw new TypeError(
                          'Cannot write private member to an object whose class did not declare it'
                        );
                      return 'a' === r ? s.call(e, n) : s ? (s.value = n) : t.set(e, n), n;
                    },
                  u =
                    (this && this.__classPrivateFieldGet) ||
                    function (e, t, n, r) {
                      if ('a' === n && !r)
                        throw new TypeError('Private accessor was defined without a getter');
                      if ('function' == typeof t ? e !== t || !r : !t.has(e))
                        throw new TypeError(
                          'Cannot read private member from an object whose class did not declare it'
                        );
                      return 'm' === n ? r : 'a' === n ? r.call(e) : r ? r.value : t.get(e);
                    },
                  h =
                    (this && this.__importDefault) ||
                    function (e) {
                      return e && e.__esModule ? e : { default: e };
                    };
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.MultichainSubscriptionManager = void 0);
                const p = e('@metamask/controller-utils'),
                  m = h(e('@metamask/eth-json-rpc-filters/subscriptionManager.js')),
                  f = h(e('@metamask/safe-event-emitter')),
                  g = e('@metamask/utils'),
                  b = e('../handlers/types.cjs');
                class y extends f.default {
                  constructor(e) {
                    super(),
                      r.add(this),
                      s.set(this, void 0),
                      a.set(this, void 0),
                      o.set(this, []),
                      d(this, s, e.findNetworkClientIdByChainId, 'f'),
                      d(this, a, e.getNetworkClientById, 'f');
                  }
                  notify({ scope: e, origin: t, tabId: n }, { method: r, params: s }) {
                    this.emit('notification', t, n, {
                      method: b.MultichainApiNotifications.walletNotify,
                      params: { scope: e, notification: { method: r, params: s } },
                    });
                  }
                  subscribe(e) {
                    const t = u(this, r, 'm', i).call(this, e);
                    if (t) return t.subscriptionManager;
                    const n = u(this, s, 'f').call(
                        this,
                        (0, p.toHex)((0, g.parseCaipChainId)(e.scope).reference)
                      ),
                      c = u(this, a, 'f').call(this, n),
                      d = (0, m.default)({ blockTracker: c.blockTracker, provider: c.provider });
                    d.events.on('notification', t => {
                      this.notify(e, t);
                    });
                    const h = { ...e, subscriptionManager: d };
                    return (
                      (d.destroy = d.middleware.destroy),
                      (d.middleware.destroy = u(this, r, 'm', l).bind(this, h)),
                      u(this, o, 'f').push(h),
                      d
                    );
                  }
                  unsubscribeByScope(e) {
                    u(this, o, 'f').forEach(t => {
                      t.scope === e && u(this, r, 'm', l).call(this, t);
                    });
                  }
                  unsubscribeByScopeAndOrigin(e, t) {
                    u(this, o, 'f').forEach(n => {
                      n.scope === e && n.origin === t && u(this, r, 'm', l).call(this, n);
                    });
                  }
                  unsubscribeByOriginAndTabId(e, t) {
                    u(this, o, 'f').forEach(n => {
                      n.origin === e && n.tabId === t && u(this, r, 'm', l).call(this, n);
                    });
                  }
                }
                (n.MultichainSubscriptionManager = y),
                  (s = new WeakMap()),
                  (a = new WeakMap()),
                  (o = new WeakMap()),
                  (r = new WeakSet()),
                  (i = function ({ scope: e, origin: t, tabId: n }) {
                    return u(this, o, 'f').find(
                      r => r.scope === e && r.origin === t && r.tabId === n
                    );
                  }),
                  (c = function ({ scope: e, origin: t, tabId: n }) {
                    d(
                      this,
                      o,
                      u(this, o, 'f').filter(r => r.scope !== e || r.origin !== t || r.tabId !== n),
                      'f'
                    );
                  }),
                  (l = function (e) {
                    e.subscriptionManager.destroy?.(), u(this, r, 'm', c).call(this, e);
                  });
              };
            };
      },
      {
        package: '@metamask/multichain-api-middleware',
        file: 'node_modules/@metamask/multichain-api-middleware/dist/middlewares/MultichainSubscriptionManager.cjs',
      },
    ],
    [
      2121,
      {
        '@metamask/api-specs': 2124,
        '@metamask/json-rpc-engine': 1964,
        '@metamask/rpc-errors': 2585,
        '@metamask/utils': 2995,
        '@open-rpc/schema-utils-js/build/dereference-document.js': 3059,
        '@open-rpc/schema-utils-js/build/parse-open-rpc-document.js': 3060,
        jsonschema: 4756,
      },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                var r =
                  (this && this.__importDefault) ||
                  function (e) {
                    return e && e.__esModule ? e : { default: e };
                  };
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.multichainMethodCallValidatorMiddleware = void 0);
                const s = e('@metamask/api-specs'),
                  a = e('@metamask/json-rpc-engine'),
                  o = e('@metamask/rpc-errors'),
                  i = e('@metamask/utils'),
                  c = r(e('@open-rpc/schema-utils-js/build/dereference-document.js')),
                  l = e('@open-rpc/schema-utils-js/build/parse-open-rpc-document.js'),
                  d = e('jsonschema'),
                  u = (e, t, n) => {
                    const r = `${t.name}${e.path.length > 0 ? `.${e.path.join('.')}` : ''} ${e.message}`;
                    return o.rpcErrors.invalidParams({
                      message: r,
                      data: { param: t.name, path: e.path, schema: e.schema, got: n },
                    });
                  },
                  h = new d.Validator(),
                  p = (0, c.default)(s.MultiChainOpenRPCDocument, (0, l.makeCustomResolver)({}));
                n.multichainMethodCallValidatorMiddleware = (0, a.createAsyncMiddleware)(
                  async (e, t, n) => {
                    const r = await (async (e, t) => {
                      const n = (await p).methods.find(t => t.name === e);
                      if (!n || !(0, i.isObject)(n) || !('params' in n))
                        return [o.rpcErrors.methodNotFound({ data: { method: e } })];
                      const r = [];
                      for (const e of n.params) {
                        if (!(0, i.isObject)(t)) return [o.rpcErrors.invalidParams()];
                        const n = e,
                          s = t[n.name],
                          a = h.validate(s, n.schema, { required: n.required });
                        a.errors && r.push(...a.errors.map(e => u(e, n, s)));
                      }
                      return r;
                    })(e.method, e.params);
                    if (r.length > 0) throw o.rpcErrors.invalidParams({ data: r });
                    return await n();
                  }
                );
              };
            };
      },
      {
        package: '@metamask/multichain-api-middleware',
        file: 'node_modules/@metamask/multichain-api-middleware/dist/middlewares/multichainMethodCallValidatorMiddleware.cjs',
      },
    ],
    [
      2122,
      {},
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                t.exports = {
                  openrpc: '1.2.4',
                  info: {
                    title: 'MetaMask MultiChain API',
                    version: '1.0.0',
                    description:
                      'This provides the specs for the MultiChain API Layer for the MetaMask API',
                  },
                  methods: [
                    {
                      name: 'wallet_notify',
                      paramStructure: 'by-name',
                      params: [
                        {
                          name: 'scope',
                          description:
                            'a valid `scope` string that has been previously authorized via `provider_authorize`',
                          required: !0,
                          schema: { $ref: '#/components/schemas/ScopeString' },
                        },
                        {
                          name: 'notification',
                          description:
                            'an object containing a JSON-RPC notification with `method` and `params`',
                          deprecated: !1,
                          required: !0,
                          schema: {
                            type: 'object',
                            properties: { method: { type: 'string' }, params: !0 },
                          },
                        },
                      ],
                    },
                    {
                      name: 'wallet_invokeMethod',
                      paramStructure: 'by-name',
                      params: [
                        {
                          name: 'scope',
                          description:
                            'a valid `scope` string that has been previously authorized via `provider_authorize`',
                          required: !0,
                          schema: { $ref: '#/components/schemas/ScopeString' },
                        },
                        {
                          name: 'request',
                          description:
                            'an object containing a JSON-RPC request with `method` and `params`',
                          deprecated: !1,
                          required: !0,
                          schema: {
                            type: 'object',
                            properties: { method: { type: 'string' }, params: !0 },
                          },
                        },
                      ],
                      result: { name: 'wallet_invokeMethodResult', schema: !0 },
                      examples: [
                        {
                          name: 'wallet_invokeMethodExample',
                          params: [
                            { name: 'scope', value: 'eip155:1' },
                            { name: 'request', value: { method: 'eth_getBalance', params: [] } },
                          ],
                          result: { name: 'wallet_invokeMethodResult', value: '0x1' },
                        },
                      ],
                    },
                    {
                      name: 'wallet_revokeSession',
                      description:
                        'The `wallet_revokeSession` method revokes the entire active session.',
                      params: [],
                      result: { name: 'wallet_revokeSessionResult', schema: { type: 'boolean' } },
                      examples: [
                        {
                          name: 'wallet_revokeSessionExample',
                          params: [],
                          result: { name: 'wallet_revokeSessionExampleResult', value: !0 },
                        },
                      ],
                      errors: [{ $ref: '#/components/errors/UnknownError' }],
                    },
                    {
                      name: 'wallet_sessionChanged',
                      paramStructure: 'by-name',
                      description:
                        "This notification is published by the wallet to notify the callers of updates to a shared session's authorization scopes. The event payload contains the new `sessionScopes`.",
                      params: [
                        {
                          name: 'sessionScopes',
                          schema: { $ref: '#/components/schemas/SessionScopes' },
                        },
                      ],
                      examples: [
                        {
                          name: 'wallet_sessionChangedExample',
                          description: 'Example of a wallet_sessionChanged notification.',
                          params: [
                            {
                              name: 'sessionScopes',
                              value: {
                                'eip155:1337': {
                                  accounts: [
                                    'eip155:1337:0x5cfe73b6021e818b776b421b1c4db2474086a7e1',
                                  ],
                                  methods: [
                                    'wallet_watchAsset',
                                    'eth_sendTransaction',
                                    'eth_decrypt',
                                    'eth_getEncryptionPublicKey',
                                    'web3_clientVersion',
                                    'eth_subscribe',
                                    'eth_unsubscribe',
                                    'eth_blockNumber',
                                    'eth_call',
                                    'eth_chainId',
                                    'eth_estimateGas',
                                    'eth_feeHistory',
                                    'eth_gasPrice',
                                    'eth_getBalance',
                                    'eth_getBlockByHash',
                                    'eth_getBlockByNumber',
                                    'eth_getBlockTransactionCountByHash',
                                    'eth_getBlockTransactionCountByNumber',
                                    'eth_getCode',
                                    'eth_getFilterChanges',
                                    'eth_getFilterLogs',
                                    'eth_getLogs',
                                    'eth_getProof',
                                    'eth_getStorageAt',
                                    'eth_getTransactionByBlockHashAndIndex',
                                    'eth_getTransactionByBlockNumberAndIndex',
                                    'eth_getTransactionByHash',
                                    'eth_getTransactionCount',
                                    'eth_getTransactionReceipt',
                                    'eth_getUncleCountByBlockHash',
                                    'eth_getUncleCountByBlockNumber',
                                    'eth_newBlockFilter',
                                    'eth_newFilter',
                                    'eth_newPendingTransactionFilter',
                                    'eth_sendRawTransaction',
                                    'eth_syncing',
                                    'eth_uninstallFilter',
                                  ],
                                  notifications: ['eth_subscription'],
                                },
                                wallet: {
                                  accounts: [],
                                  methods: ['wallet_registerOnboarding', 'wallet_scanQRCode'],
                                  notifications: [],
                                },
                                'wallet:eip155': {
                                  accounts: [
                                    'wallet:eip155:0x5cfe73b6021e818b776b421b1c4db2474086a7e1',
                                  ],
                                  methods: [
                                    'wallet_addEthereumChain',
                                    'personal_sign',
                                    'eth_signTypedData_v4',
                                  ],
                                  notifications: [],
                                },
                              },
                            },
                          ],
                        },
                      ],
                    },
                    {
                      name: 'wallet_getSession',
                      description: 'The `wallet_getSession` method returns an active session.',
                      params: [],
                      result: {
                        name: 'wallet_getSessionResult',
                        schema: {
                          type: 'object',
                          properties: {
                            sessionScopes: { $ref: '#/components/schemas/SessionScopes' },
                          },
                        },
                      },
                      examples: [
                        {
                          name: 'wallet_getSessionExample',
                          description: 'Example of a getSession request.',
                          params: [],
                          result: {
                            name: 'wallet_getSessionResultExample',
                            value: {
                              sessionScopes: {
                                'eip155:1337': {
                                  accounts: [
                                    'eip155:1337:0x5cfe73b6021e818b776b421b1c4db2474086a7e1',
                                  ],
                                  methods: [
                                    'wallet_watchAsset',
                                    'eth_sendTransaction',
                                    'eth_decrypt',
                                    'eth_getEncryptionPublicKey',
                                    'web3_clientVersion',
                                    'eth_subscribe',
                                    'eth_unsubscribe',
                                    'eth_blockNumber',
                                    'eth_call',
                                    'eth_chainId',
                                    'eth_estimateGas',
                                    'eth_feeHistory',
                                    'eth_gasPrice',
                                    'eth_getBalance',
                                    'eth_getBlockByHash',
                                    'eth_getBlockByNumber',
                                    'eth_getBlockTransactionCountByHash',
                                    'eth_getBlockTransactionCountByNumber',
                                    'eth_getCode',
                                    'eth_getFilterChanges',
                                    'eth_getFilterLogs',
                                    'eth_getLogs',
                                    'eth_getProof',
                                    'eth_getStorageAt',
                                    'eth_getTransactionByBlockHashAndIndex',
                                    'eth_getTransactionByBlockNumberAndIndex',
                                    'eth_getTransactionByHash',
                                    'eth_getTransactionCount',
                                    'eth_getTransactionReceipt',
                                    'eth_getUncleCountByBlockHash',
                                    'eth_getUncleCountByBlockNumber',
                                    'eth_newBlockFilter',
                                    'eth_newFilter',
                                    'eth_newPendingTransactionFilter',
                                    'eth_sendRawTransaction',
                                    'eth_syncing',
                                    'eth_uninstallFilter',
                                  ],
                                  notifications: ['eth_subscription'],
                                },
                                wallet: {
                                  accounts: [],
                                  methods: ['wallet_registerOnboarding', 'wallet_scanQRCode'],
                                  notifications: [],
                                },
                                'wallet:eip155': {
                                  accounts: [
                                    'wallet:eip155:0x5cfe73b6021e818b776b421b1c4db2474086a7e1',
                                  ],
                                  methods: [
                                    'wallet_addEthereumChain',
                                    'personal_sign',
                                    'eth_signTypedData_v4',
                                  ],
                                  notifications: [],
                                },
                              },
                            },
                          },
                        },
                      ],
                    },
                    {
                      name: 'wallet_createSession',
                      paramStructure: 'by-name',
                      params: [
                        {
                          name: 'requiredScopes',
                          description:
                            'Scopes that the wallet must support in order to be used with this provider.',
                          schema: {
                            type: 'object',
                            patternProperties: {
                              '[-a-z0-9]{3,8}(:[-_a-zA-Z0-9]{1,32})?': {
                                $ref: '#/components/schemas/Scope',
                              },
                            },
                          },
                        },
                        {
                          name: 'optionalScopes',
                          description:
                            'Scopes that the wallet may support in order to be used with this provider.',
                          schema: {
                            type: 'object',
                            patternProperties: {
                              '[-a-z0-9]{3,8}(:[-_a-zA-Z0-9]{1,32})?': {
                                $ref: '#/components/schemas/Scope',
                              },
                            },
                          },
                        },
                        {
                          name: 'sessionProperties',
                          description:
                            'Properties that the wallet may use to determine if the session is valid.',
                          schema: {
                            type: 'object',
                            properties: { expiry: { type: 'string', format: 'date-time' } },
                          },
                        },
                      ],
                      result: {
                        name: 'wallet_createSessionResult',
                        schema: {
                          type: 'object',
                          properties: {
                            sessionScopes: { $ref: '#/components/schemas/SessionScopes' },
                            sessionProperties: {
                              type: 'object',
                              properties: { expiry: { type: 'string', format: 'date-time' } },
                            },
                          },
                        },
                      },
                      examples: [
                        {
                          name: 'wallet_createSessionEthExample',
                          description: 'Example of a createSession request.',
                          params: [
                            {
                              name: 'requiredScopes',
                              value: {
                                'eip155:1337': {
                                  methods: [
                                    'wallet_watchAsset',
                                    'eth_sendTransaction',
                                    'eth_decrypt',
                                    'eth_getEncryptionPublicKey',
                                    'web3_clientVersion',
                                    'eth_subscribe',
                                    'eth_unsubscribe',
                                    'eth_blockNumber',
                                    'eth_call',
                                    'eth_chainId',
                                    'eth_estimateGas',
                                    'eth_feeHistory',
                                    'eth_gasPrice',
                                    'eth_getBalance',
                                    'eth_getBlockByHash',
                                    'eth_getBlockByNumber',
                                    'eth_getBlockTransactionCountByHash',
                                    'eth_getBlockTransactionCountByNumber',
                                    'eth_getCode',
                                    'eth_getFilterChanges',
                                    'eth_getFilterLogs',
                                    'eth_getLogs',
                                    'eth_getProof',
                                    'eth_getStorageAt',
                                    'eth_getTransactionByBlockHashAndIndex',
                                    'eth_getTransactionByBlockNumberAndIndex',
                                    'eth_getTransactionByHash',
                                    'eth_getTransactionCount',
                                    'eth_getTransactionReceipt',
                                    'eth_getUncleCountByBlockHash',
                                    'eth_getUncleCountByBlockNumber',
                                    'eth_newBlockFilter',
                                    'eth_newFilter',
                                    'eth_newPendingTransactionFilter',
                                    'eth_sendRawTransaction',
                                    'eth_syncing',
                                    'eth_uninstallFilter',
                                  ],
                                  notifications: ['eth_subscription'],
                                },
                                wallet: {
                                  methods: ['wallet_registerOnboarding', 'wallet_scanQRCode'],
                                  notifications: [],
                                },
                                'wallet:eip155': {
                                  methods: [
                                    'wallet_addEthereumChain',
                                    'personal_sign',
                                    'eth_signTypedData_v4',
                                  ],
                                  notifications: [],
                                },
                              },
                            },
                            {
                              name: 'sessionProperties',
                              value: { expiry: '2022-12-24T17:07:31+00:00' },
                            },
                          ],
                          result: {
                            name: 'wallet_createSessionResultExample',
                            value: {
                              sessionScopes: {
                                'eip155:1337': {
                                  accounts: [
                                    'eip155:1337:0x5cfe73b6021e818b776b421b1c4db2474086a7e1',
                                  ],
                                  methods: [
                                    'wallet_watchAsset',
                                    'eth_sendTransaction',
                                    'eth_decrypt',
                                    'eth_getEncryptionPublicKey',
                                    'web3_clientVersion',
                                    'eth_subscribe',
                                    'eth_unsubscribe',
                                    'eth_blockNumber',
                                    'eth_call',
                                    'eth_chainId',
                                    'eth_estimateGas',
                                    'eth_feeHistory',
                                    'eth_gasPrice',
                                    'eth_getBalance',
                                    'eth_getBlockByHash',
                                    'eth_getBlockByNumber',
                                    'eth_getBlockTransactionCountByHash',
                                    'eth_getBlockTransactionCountByNumber',
                                    'eth_getCode',
                                    'eth_getFilterChanges',
                                    'eth_getFilterLogs',
                                    'eth_getLogs',
                                    'eth_getProof',
                                    'eth_getStorageAt',
                                    'eth_getTransactionByBlockHashAndIndex',
                                    'eth_getTransactionByBlockNumberAndIndex',
                                    'eth_getTransactionByHash',
                                    'eth_getTransactionCount',
                                    'eth_getTransactionReceipt',
                                    'eth_getUncleCountByBlockHash',
                                    'eth_getUncleCountByBlockNumber',
                                    'eth_newBlockFilter',
                                    'eth_newFilter',
                                    'eth_newPendingTransactionFilter',
                                    'eth_sendRawTransaction',
                                    'eth_syncing',
                                    'eth_uninstallFilter',
                                  ],
                                  notifications: ['eth_subscription'],
                                },
                                wallet: {
                                  accounts: [],
                                  methods: ['wallet_registerOnboarding', 'wallet_scanQRCode'],
                                  notifications: [],
                                },
                                'wallet:eip155': {
                                  accounts: [
                                    'wallet:eip155:0x5cfe73b6021e818b776b421b1c4db2474086a7e1',
                                  ],
                                  methods: [
                                    'wallet_addEthereumChain',
                                    'personal_sign',
                                    'eth_signTypedData_v4',
                                  ],
                                  notifications: [],
                                },
                                sessionProperties: { expiry: '2022-11-31T17:07:31+00:00' },
                              },
                            },
                          },
                        },
                        {
                          name: 'wallet_createSessionEthUnsupportedMethodsExample',
                          description:
                            'Example of a createSession request with unsupported eip155 methods.',
                          params: [
                            {
                              name: 'optionalScopes',
                              value: {
                                'eip155:1337': { methods: ['not_supported'], notifications: [] },
                                wallet: { methods: [], notifications: [] },
                                'wallet:eip155': { methods: [], notifications: [] },
                              },
                            },
                            {
                              name: 'sessionProperties',
                              value: { expiry: '2022-12-24T17:07:31+00:00' },
                            },
                          ],
                          result: {
                            name: 'wallet_createSessionEthUnsupportedMethodsResultExample',
                            value: {
                              sessionScopes: {
                                'eip155:1337': {
                                  accounts: [
                                    'eip155:1337:0x5cfe73b6021e818b776b421b1c4db2474086a7e1',
                                  ],
                                  methods: [
                                    'wallet_watchAsset',
                                    'eth_sendTransaction',
                                    'eth_decrypt',
                                    'eth_getEncryptionPublicKey',
                                    'web3_clientVersion',
                                    'eth_subscribe',
                                    'eth_unsubscribe',
                                    'eth_blockNumber',
                                    'eth_call',
                                    'eth_chainId',
                                    'eth_estimateGas',
                                    'eth_feeHistory',
                                    'eth_gasPrice',
                                    'eth_getBalance',
                                    'eth_getBlockByHash',
                                    'eth_getBlockByNumber',
                                    'eth_getBlockTransactionCountByHash',
                                    'eth_getBlockTransactionCountByNumber',
                                    'eth_getCode',
                                    'eth_getFilterChanges',
                                    'eth_getFilterLogs',
                                    'eth_getLogs',
                                    'eth_getProof',
                                    'eth_getStorageAt',
                                    'eth_getTransactionByBlockHashAndIndex',
                                    'eth_getTransactionByBlockNumberAndIndex',
                                    'eth_getTransactionByHash',
                                    'eth_getTransactionCount',
                                    'eth_getTransactionReceipt',
                                    'eth_getUncleCountByBlockHash',
                                    'eth_getUncleCountByBlockNumber',
                                    'eth_newBlockFilter',
                                    'eth_newFilter',
                                    'eth_newPendingTransactionFilter',
                                    'eth_sendRawTransaction',
                                    'eth_syncing',
                                    'eth_uninstallFilter',
                                  ],
                                  notifications: ['eth_subscription'],
                                },
                                wallet: {
                                  accounts: [],
                                  methods: ['wallet_registerOnboarding', 'wallet_scanQRCode'],
                                  notifications: [],
                                },
                                'wallet:eip155': {
                                  accounts: [
                                    'wallet:eip155:0x5cfe73b6021e818b776b421b1c4db2474086a7e1',
                                  ],
                                  methods: [
                                    'wallet_addEthereumChain',
                                    'personal_sign',
                                    'eth_signTypedData_v4',
                                  ],
                                  notifications: [],
                                },
                              },
                              sessionProperties: { expiry: '2022-11-31T17:07:31+00:00' },
                            },
                          },
                        },
                        {
                          name: 'wallet_createSessionUnsupportedScopesExample',
                          description:
                            'Example of a createSession request with unsupported scopes.',
                          params: [
                            {
                              name: 'requiredScopes',
                              value: {
                                foobar: {
                                  methods: ['eth_getBalance'],
                                  notifications: ['eth_subscription'],
                                },
                              },
                            },
                          ],
                          result: {
                            name: 'wallet_createSessionUnsupportedScopesResultExample',
                            value: {
                              sessionScopes: {
                                'eip155:1': {
                                  accounts: ['eip155:1:0x5cfe73b6021e818b776b421b1c4db2474086a7e1'],
                                  methods: [
                                    'wallet_watchAsset',
                                    'eth_sendTransaction',
                                    'eth_decrypt',
                                    'eth_getEncryptionPublicKey',
                                    'web3_clientVersion',
                                    'eth_subscribe',
                                    'eth_unsubscribe',
                                    'eth_blockNumber',
                                    'eth_call',
                                    'eth_chainId',
                                    'eth_estimateGas',
                                    'eth_feeHistory',
                                    'eth_gasPrice',
                                    'eth_getBalance',
                                    'eth_getBlockByHash',
                                    'eth_getBlockByNumber',
                                    'eth_getBlockTransactionCountByHash',
                                    'eth_getBlockTransactionCountByNumber',
                                    'eth_getCode',
                                    'eth_getFilterChanges',
                                    'eth_getFilterLogs',
                                    'eth_getLogs',
                                    'eth_getProof',
                                    'eth_getStorageAt',
                                    'eth_getTransactionByBlockHashAndIndex',
                                    'eth_getTransactionByBlockNumberAndIndex',
                                    'eth_getTransactionByHash',
                                    'eth_getTransactionCount',
                                    'eth_getTransactionReceipt',
                                    'eth_getUncleCountByBlockHash',
                                    'eth_getUncleCountByBlockNumber',
                                    'eth_newBlockFilter',
                                    'eth_newFilter',
                                    'eth_newPendingTransactionFilter',
                                    'eth_sendRawTransaction',
                                    'eth_syncing',
                                    'eth_uninstallFilter',
                                  ],
                                  notifications: ['eth_subscription'],
                                },
                                'eip155:59144': {
                                  accounts: [
                                    'eip155:59144:0x5cfe73b6021e818b776b421b1c4db2474086a7e1',
                                  ],
                                  methods: [
                                    'wallet_watchAsset',
                                    'eth_sendTransaction',
                                    'eth_decrypt',
                                    'eth_getEncryptionPublicKey',
                                    'web3_clientVersion',
                                    'eth_subscribe',
                                    'eth_unsubscribe',
                                    'eth_blockNumber',
                                    'eth_call',
                                    'eth_chainId',
                                    'eth_estimateGas',
                                    'eth_feeHistory',
                                    'eth_gasPrice',
                                    'eth_getBalance',
                                    'eth_getBlockByHash',
                                    'eth_getBlockByNumber',
                                    'eth_getBlockTransactionCountByHash',
                                    'eth_getBlockTransactionCountByNumber',
                                    'eth_getCode',
                                    'eth_getFilterChanges',
                                    'eth_getFilterLogs',
                                    'eth_getLogs',
                                    'eth_getProof',
                                    'eth_getStorageAt',
                                    'eth_getTransactionByBlockHashAndIndex',
                                    'eth_getTransactionByBlockNumberAndIndex',
                                    'eth_getTransactionByHash',
                                    'eth_getTransactionCount',
                                    'eth_getTransactionReceipt',
                                    'eth_getUncleCountByBlockHash',
                                    'eth_getUncleCountByBlockNumber',
                                    'eth_newBlockFilter',
                                    'eth_newFilter',
                                    'eth_newPendingTransactionFilter',
                                    'eth_sendRawTransaction',
                                    'eth_syncing',
                                    'eth_uninstallFilter',
                                  ],
                                  notifications: ['eth_subscription'],
                                },
                              },
                            },
                            sessionProperties: { expiry: '2022-11-31T17:07:31+00:00' },
                          },
                        },
                      ],
                      errors: [
                        { $ref: '#/components/errors/UnknownError' },
                        { code: 5100, message: 'Requested networks are not supported' },
                        { code: 5101, message: 'Requested methods are not supported' },
                        { code: 5102, message: 'Requested notifications are not supported' },
                        { code: 5300, message: 'Invalid scopedProperties requested' },
                        {
                          code: 5301,
                          message: 'scopedProperties can only be outside of sessionScopes',
                        },
                        { code: 5302, message: 'Invalid sessionProperties requested' },
                      ],
                    },
                  ],
                  components: {
                    errors: { UnknownError: { code: 5e3, message: 'Unknown error with request' } },
                    schemas: {
                      SessionScopes: {
                        type: 'object',
                        patternProperties: {
                          '[-a-z0-9]{3,8}(:[-_a-zA-Z0-9]{1,32})?': {
                            $ref: '#/components/schemas/Scope',
                          },
                        },
                      },
                      ScopeString: {
                        type: 'string',
                        pattern: '[-a-z0-9]{3,8}(:[-_a-zA-Z0-9]{1,32})?',
                      },
                      Scope: {
                        type: 'object',
                        title: 'Scope',
                        description: 'Scope for a multi-chain connection',
                        additionalProperties: !0,
                        required: ['notifications', 'methods'],
                        properties: {
                          scopes: {
                            type: 'array',
                            items: { $ref: '#/components/schemas/ScopeString' },
                          },
                          methods: {
                            description:
                              'Methods that the wallet must support in order to be used with this provider.',
                            type: 'array',
                            items: { type: 'string' },
                          },
                          notifications: {
                            description:
                              'Notifications that the wallet must support in order to be used with this provider.',
                            type: 'array',
                            items: { type: 'string' },
                          },
                          rpcEndpoints: {
                            description: 'JSON-RPC endpoints for this namespace.',
                            type: 'array',
                            items: { type: 'string', format: 'uri' },
                          },
                          rpcDocuments: {
                            type: 'array',
                            description:
                              'OpenRPC documents that define RPC methods in which to anchor the methods authorized in a CAIP-25 interaction.',
                            items: { type: 'string', format: 'uri' },
                          },
                        },
                      },
                    },
                  },
                };
              };
            };
      },
      {
        package: '@metamask/multichain-api-middleware>@metamask/api-specs',
        file: 'node_modules/@metamask/multichain-api-middleware/node_modules/@metamask/api-specs/dist/build/multichain-openrpc.json',
      },
    ],
    [
      2123,
      {},
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                t.exports = {
                  openrpc: '1.2.4',
                  info: {
                    title: 'JSON-RPC API',
                    version: '1.0.0',
                    description:
                      "This section provides an interactive reference for MetaMask's Wallet JSON-RPC API. The API builds on a set of standard Ethereum methods with MetaMask-specific enhancements, and is designed for seamless integration into dapps.",
                  },
                  methods: [
                    {
                      name: 'wallet_addEthereumChain',
                      tags: [
                        { $ref: '#/components/tags/MetaMask' },
                        { $ref: '#/components/tags/Multichain' },
                      ],
                      summary: 'Adds an Ethereum chain to the wallet.',
                      description:
                        'Creates a confirmation asking the user to add the specified chain to the wallet application. The caller must specify a chain ID and some chain metadata. Specified by [EIP-3085](https://eips.ethereum.org/EIPS/eip-3085).',
                      params: [
                        {
                          name: 'Chain',
                          schema: { $ref: '#/components/schemas/AddEthereumChainParameter' },
                        },
                      ],
                      errors: [
                        {
                          code: -32602,
                          message:
                            "Expected null or array with at least one valid string HTTPS URL 'blockExplorerUrl'. Received: ${blockExplorerUrls}",
                        },
                        {
                          code: -32602,
                          message:
                            "Expected 0x-prefixed, unpadded, non-zero hexadecimal string 'chainId'. Received:\n${chainId}",
                        },
                        {
                          code: -32602,
                          message:
                            'Invalid chain ID "${_chainId}": numerical value greater than max safe value. Received:\n${chainId}',
                        },
                        { code: -32602, message: 'May not specify default MetaMask chain.' },
                        {
                          code: -32602,
                          message:
                            "Expected 2-6 character string 'nativeCurrency.symbol'. Received:\n${ticker}",
                        },
                        {
                          code: -32602,
                          message:
                            'nativeCurrency.symbol does not match currency symbol for a network the user already has added with the same chainId. Received:\n${ticker}',
                        },
                      ],
                      result: {
                        name: 'Null response',
                        description: 'This method returns `null` if the chain is added.',
                        schema: { type: 'null' },
                      },
                      examples: [
                        {
                          name: 'wallet_addEthereumChain example',
                          params: [
                            {
                              name: 'Chain',
                              value: {
                                chainId: '0x64',
                                chainName: 'Gnosis',
                                rpcUrls: ['https://rpc.gnosischain.com'],
                                iconUrls: [
                                  'https://xdaichain.com/fake/example/url/xdai.svg',
                                  'https://xdaichain.com/fake/example/url/xdai.png',
                                ],
                                nativeCurrency: { name: 'XDAI', symbol: 'XDAI', decimals: 18 },
                                blockExplorerUrls: ['https://blockscout.com/poa/xdai/'],
                              },
                            },
                          ],
                          result: { name: 'Null response', value: 'null' },
                        },
                      ],
                    },
                    {
                      name: 'wallet_switchEthereumChain',
                      tags: [{ $ref: '#/components/tags/MetaMask' }],
                      summary: "Switches the wallet's active Ethereum chain.",
                      description:
                        'Requests that the wallet switches its active Ethereum chain. Specified by [EIP-3326](https://eips.ethereum.org/EIPS/eip-3326).',
                      params: [
                        {
                          name: 'Chain',
                          schema: {
                            title: 'Chain',
                            description: 'Object containing the chain ID to switch to.',
                            type: 'object',
                            required: ['chainId'],
                            properties: {
                              chainId: {
                                description:
                                  'The chain ID as a `0x`-prefixed hexadecimal string, as returned by the `eth_chainId` method.',
                                type: 'string',
                              },
                            },
                          },
                        },
                      ],
                      result: {
                        name: 'Null response',
                        description: 'This method returns `null` if the active chain is switched.',
                        schema: { type: 'null' },
                      },
                      errors: [
                        {
                          code: 4902,
                          message:
                            'Unrecognized chain ID. Try adding the chain using wallet_addEthereumChain first.',
                        },
                      ],
                      examples: [
                        {
                          name: 'wallet_switchEthereumChain example',
                          params: [{ name: 'Chain', value: { chainId: '0x64' } }],
                          result: { name: 'Null response', value: 'null' },
                        },
                      ],
                    },
                    {
                      name: 'wallet_getPermissions',
                      tags: [{ $ref: '#/components/tags/MetaMask' }],
                      summary: "Gets the user's permissions.",
                      description:
                        "Gets the user's permissions. Specified by [EIP-2255](https://eips.ethereum.org/EIPS/eip-2255).",
                      params: [],
                      result: {
                        name: 'Permissions list',
                        schema: { $ref: '#/components/schemas/PermissionsList' },
                      },
                      examples: [
                        {
                          name: 'wallet_getPermissions example',
                          params: [],
                          result: { name: 'Permission list', value: { eth_accounts: {} } },
                        },
                      ],
                    },
                    {
                      name: 'wallet_requestPermissions',
                      tags: [{ $ref: '#/components/tags/MetaMask' }],
                      summary: 'Requests additional permissions.',
                      description:
                        'Requests additional permissions from the user. This method accepts a single permission per call. Specified by [EIP-2255](https://eips.ethereum.org/EIPS/eip-2255).',
                      params: [
                        {
                          name: 'Permission',
                          required: !0,
                          schema: {
                            title: 'Permission',
                            description: 'Object containing the permission to request.',
                            type: 'object',
                            properties: {
                              permission_name: {
                                type: 'object',
                                description:
                                  'The permission object. `permission_name` is the name of the permission being requested.',
                                additionalProperties: !0,
                              },
                            },
                          },
                        },
                      ],
                      result: {
                        name: 'Permissions list',
                        schema: { $ref: '#/components/schemas/PermissionsList' },
                      },
                      examples: [
                        {
                          name: 'wallet_requestPermissions example',
                          params: [{ name: 'Permission', value: { eth_accounts: {} } }],
                          result: { name: 'Permission list', value: { eth_accounts: {} } },
                        },
                      ],
                      errors: [{ $ref: '#/components/errors/UserRejected' }],
                    },
                    {
                      name: 'wallet_revokePermissions',
                      tags: [
                        { $ref: '#/components/tags/MetaMask' },
                        { $ref: '#/components/tags/Experimental' },
                      ],
                      summary: 'Revokes the current dapp permissions.',
                      description:
                        'Revokes previously granted permissions for the current dapp identified by its origin. This method accepts a single permission per call. Specified by [MIP-2](https://github.com/MetaMask/metamask-improvement-proposals/blob/main/MIPs/mip-2.md) and only available for the MetaMask browser extension.',
                      params: [
                        {
                          name: 'Permission',
                          required: !0,
                          schema: {
                            title: 'Permission',
                            description: 'Object containing the permission to revoke.',
                            type: 'object',
                            properties: {
                              permission_name: {
                                type: 'object',
                                description:
                                  'The permission object. `permission_name` is the name of the permission being revoked.',
                                additionalProperties: !0,
                              },
                            },
                          },
                        },
                      ],
                      result: {
                        name: 'Null response',
                        description: 'This method returns `null` if the permission is revoked.',
                        schema: { type: 'null' },
                      },
                      errors: [],
                      examples: [
                        {
                          name: 'wallet_revokePermissions example',
                          params: [{ name: 'Permission', value: { eth_accounts: {} } }],
                          result: { name: 'Null response', value: 'null' },
                        },
                      ],
                    },
                    {
                      name: 'personal_sign',
                      tags: [
                        { $ref: '#/components/tags/MetaMask' },
                        { $ref: '#/components/tags/Restricted' },
                        { $ref: '#/components/tags/Multichain' },
                      ],
                      summary: 'Presents a plain text signature challenge to the user.',
                      description:
                        "Presents a plain text signature challenge to the user and returns the signed response. Prepends a safe prefix to the signed message to prevent the challenge tricking users into signing a financial transaction. <br><br> MetaMask implements `personal_sign` similarly to the Go Ethereum client's `eth_sign` implementation. MetaMask's `personal_sign` doesn't accept a password. <br><br> This method requires that the user has granted permission to interact with their account first, so make sure to call `eth_requestAccounts` (recommended) or `wallet_requestPermissions` first.",
                      deprecated: !1,
                      params: [
                        {
                          name: 'Challenge',
                          required: !0,
                          description:
                            'A hex-encoded UTF-8 string to present to the user. See how to encode a string like this in the [`browser-string-hexer`](https://github.com/danfinlay/browser-string-hexer) module.',
                          schema: { type: 'string', pattern: '^0x[a-fA-F\\d]+$' },
                        },
                        {
                          name: 'Address',
                          required: !0,
                          description: 'The address of the requested signing account.',
                          schema: { type: 'string', pattern: '^0x[0-9a-fA-F]{40}$' },
                        },
                      ],
                      result: {
                        name: 'Signature',
                        description: 'A hex-encoded signature.',
                        schema: { type: 'string', pattern: '^0x[0-9a-f]*$' },
                      },
                      examples: [
                        {
                          name: 'personal_sign example',
                          params: [
                            {
                              name: 'Challenge',
                              value:
                                '0x506c65617365207369676e2074686973206d65737361676520746f20636f6e6669726d20796f7572206964656e746974792e',
                            },
                            {
                              name: 'Address',
                              value: '0x4B0897b0513FdBeEc7C469D9aF4fA6C0752aBea7',
                            },
                          ],
                          result: {
                            name: 'Signature',
                            value:
                              '0x43d7215ebe96c09a5adac69fc76dea5647286b501954ea273e417cf65e6c80e1db4891826375a7de02467a3e01caf125f64c851a8e9ee9467fd6f7e83523b2115bed8e79d527a85e28a36807d79b85fc551b5c15c1ead2e43456c31f565219203db2aed86cb3601b33ec3b410836d4be7718c6148dc9ac82ecc0a04c5edecd8914',
                          },
                        },
                      ],
                    },
                    {
                      name: 'eth_signTypedData_v4',
                      tags: [
                        { $ref: '#/components/tags/MetaMask' },
                        { $ref: '#/components/tags/Restricted' },
                        { $ref: '#/components/tags/Multichain' },
                      ],
                      summary: 'Presents a structured data message for the user to sign.',
                      description:
                        'Presents a data message for the user to sign in a structured and readable format and returns the signed response. Introduced by [EIP-712](https://eips.ethereum.org/EIPS/eip-712). This method requires that the user has granted permission to interact with their account first, so make sure to call `eth_requestAccounts` (recommended) or `wallet_requestPermissions` first.',
                      params: [
                        {
                          name: 'Address',
                          required: !0,
                          description: 'The address of the requested signing account.',
                          schema: { $ref: '#/components/schemas/address' },
                        },
                        {
                          name: 'TypedData',
                          required: !0,
                          schema: { $ref: '#/components/schemas/TypedData' },
                        },
                      ],
                      result: { name: 'Signature', schema: { $ref: '#/components/schemas/bytes' } },
                      examples: [
                        {
                          name: 'eth_SignTypedData_v4 example',
                          params: [
                            {
                              name: 'Address',
                              value: '0x0000000000000000000000000000000000000000',
                            },
                            {
                              name: 'TypedData',
                              value: {
                                types: {
                                  EIP712Domain: [
                                    { name: 'name', type: 'string' },
                                    { name: 'version', type: 'string' },
                                    { name: 'chainId', type: 'uint256' },
                                    { name: 'verifyingContract', type: 'address' },
                                  ],
                                  Person: [
                                    { name: 'name', type: 'string' },
                                    { name: 'wallet', type: 'address' },
                                  ],
                                  Mail: [
                                    { name: 'from', type: 'Person' },
                                    { name: 'to', type: 'Person' },
                                    { name: 'contents', type: 'string' },
                                  ],
                                },
                                primaryType: 'Mail',
                                domain: {
                                  name: 'Ether Mail',
                                  version: '1',
                                  chainId: 1,
                                  verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
                                },
                                message: {
                                  from: {
                                    name: 'Cow',
                                    wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
                                  },
                                  to: {
                                    name: 'Bob',
                                    wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
                                  },
                                  contents: 'Hello, Bob!',
                                },
                              },
                            },
                          ],
                          result: {
                            name: 'Signature',
                            value:
                              '0x4355c47d63924e8a72e509b65029052eb6c299d53a04e167c5775fd466751c9d07299936d304c153f6443dfa05f40ff007d72911b6f72307f996231605b915621c',
                          },
                        },
                      ],
                    },
                    {
                      name: 'wallet_registerOnboarding',
                      tags: [
                        { $ref: '#/components/tags/MetaMask' },
                        { $ref: '#/components/tags/Multichain' },
                      ],
                      summary: 'Redirects the user back to the site after onboarding.',
                      description:
                        "Registers the requesting site with MetaMask as the initiator of onboarding, enabling MetaMask to redirect the user back to the site after onboarding. Returns a promise that resolves to `true`, or rejects if there's an error. Instead of calling this method directly, you should use the [`@metamask/onboarding`](https://github.com/MetaMask/metamask-onboarding) library.",
                      params: [],
                      result: {
                        name: 'RegisterOnboardingResult',
                        description: '`true` if the request was successful, `false` otherwise.',
                        schema: { type: 'boolean' },
                      },
                    },
                    {
                      name: 'wallet_watchAsset',
                      tags: [
                        { $ref: '#/components/tags/MetaMask' },
                        { $ref: '#/components/tags/Experimental' },
                        { $ref: '#/components/tags/Multichain' },
                      ],
                      summary: 'Tracks a token in MetaMask.',
                      description:
                        'Requests that the user track the specified token in MetaMask. Returns a boolean indicating if the token was successfully added. Once added, the token is indistinguishable from those added using legacy methods, such as a centralized registry. Introduced by [EIP-747](https://eips.ethereum.org/EIPS/eip-747).',
                      paramStructure: 'by-name',
                      params: [
                        {
                          name: 'type',
                          schema: {
                            type: 'string',
                            description:
                              'Supports ERC-20, ERC-721, and ERC-1155 tokens. Support for ERC-721 and ERC-1155 tokens is experimental and currently only available on the extension (not on mobile). See [MIP-1](https://github.com/MetaMask/metamask-improvement-proposals/blob/main/MIPs/mip-1.md) and [MIP proposal lifecycle](https://github.com/MetaMask/metamask-improvement-proposals/blob/main/PROCESS-GUIDE.md#proposal-lifecycle) for more information.',
                            enum: ['ERC20', 'ERC721', 'ERC1155'],
                          },
                          required: !0,
                        },
                        {
                          name: 'options',
                          schema: {
                            title: 'WatchAssetOptions',
                            type: 'object',
                            required: ['address'],
                            properties: {
                              address: {
                                description: 'The address of the token contract.',
                                type: 'string',
                              },
                              symbol: {
                                description:
                                  'A ticker symbol or shorthand, up to 11 characters (optional for ERC-20 tokens).',
                                minLength: 2,
                                maxLength: 11,
                                type: 'string',
                              },
                              decimals: {
                                description:
                                  'The number of token decimals (optional for ERC-20 tokens).',
                                type: 'number',
                              },
                              image: {
                                description:
                                  'A string URL of the token logo (optional for ERC-20 tokens).',
                                type: 'string',
                              },
                              tokenId: {
                                description:
                                  'The unique identifier of the NFT (required for ERC-721 and ERC-1155 tokens).',
                                type: 'string',
                              },
                            },
                          },
                        },
                      ],
                      errors: [
                        { code: -32602, message: 'Must specify address, symbol, and decimals.' },
                        { code: -32602, message: 'Invalid symbol: not a string.' },
                        {
                          code: -32602,
                          message: "Invalid symbol '${symbol}': longer than 11 characters.",
                        },
                        {
                          code: -32602,
                          message: "Invalid decimals '${decimals}': must be 0 <= 36.",
                        },
                        { code: -32602, message: "Invalid address '${address}'." },
                        { code: -32602, message: 'Asset type is required.' },
                        { code: -32602, message: 'Both address and tokenId are required.' },
                        { code: -32602, message: 'Invalid address.' },
                        {
                          code: -32e3,
                          message: 'Suggested NFT is not owned by the selected account.',
                        },
                        {
                          code: -32e3,
                          message:
                            'Suggested NFT of type ${standard} does not match received type ${type}.',
                        },
                        {
                          code: -32002,
                          message:
                            "Unable to verify ownership. Possibly because the standard is not supported or the user's currently selected network does not match the chain of the asset in question.",
                        },
                      ],
                      result: {
                        name: 'WatchAssetResult',
                        description: '`true` if the token was added, `false` otherwise.',
                        schema: { type: 'boolean' },
                      },
                      examples: [
                        {
                          name: 'wallet_watchAsset ERC-20 example',
                          params: [
                            { name: 'type', value: 'ERC20' },
                            {
                              name: 'options',
                              value: {
                                address: '0xb60e8dd61c5d32be8058bb8eb970870f07233155',
                                symbol: 'FOO',
                                decimals: 18,
                                image: 'https://foo.io/token-image.svg',
                              },
                            },
                          ],
                          result: { name: 'wallet_watchAssetExampleResult', value: !0 },
                        },
                        {
                          name: 'wallet_watchAsset ERC-721 example',
                          params: [
                            { name: 'type', value: 'ERC721' },
                            {
                              name: 'options',
                              value: {
                                address: '0x123456789abcdef0123456789abcdef01234567',
                                tokenId: '42',
                              },
                            },
                          ],
                          result: { name: 'wallet_watchAssetERC721ExampleResult', value: !0 },
                        },
                        {
                          name: 'wallet_watchAsset ERC-1155 example',
                          params: [
                            { name: 'type', value: 'ERC1155' },
                            {
                              name: 'options',
                              value: {
                                address: '0xabcdef0123456789abcdef0123456789abcdef01',
                                tokenId: '1337',
                              },
                            },
                          ],
                          result: { name: 'wallet_watchAssetERC1155ExampleResult', value: !0 },
                        },
                      ],
                    },
                    {
                      name: 'wallet_scanQRCode',
                      tags: [
                        { $ref: '#/components/tags/MetaMask' },
                        { $ref: '#/components/tags/Mobile' },
                        { $ref: '#/components/tags/Multichain' },
                      ],
                      summary: 'Requests that the user scan a QR code.',
                      description:
                        'Requests that the user scan a QR code using their device camera. Introduced by [EIP-945](https://github.com/ethereum/EIPs/issues/945).',
                      params: [
                        {
                          name: 'regex',
                          required: !1,
                          description:
                            'A regular expression (regex) string for matching arbitrary QR code strings.',
                          schema: { type: 'string', title: 'regex' },
                        },
                      ],
                      result: {
                        name: 'ScanQRCodeResult',
                        description:
                          'A string corresponding to the scanned QR code. If a regex string is provided, the resulting string matches it. If no regex string is provided, the resulting string matches an Ethereum address. If neither condition is met, the method returns an error.',
                        schema: { type: 'string', title: 'ScanQRCodeResult' },
                      },
                    },
                    {
                      name: 'eth_requestAccounts',
                      tags: [{ $ref: '#/components/tags/MetaMask' }],
                      description:
                        'Requests that the user provide an Ethereum address to be identified by. This method is specified by [EIP-1102](https://eips.ethereum.org/EIPS/eip-1102). Internally, this method calls `wallet_requestPermissions` for permission to call `eth_accounts`.',
                      summary: 'Requests that the user provide an Ethereum address.',
                      params: [],
                      result: {
                        name: 'AddressList',
                        schema: { type: 'array', items: { $ref: '#/components/schemas/address' } },
                      },
                      errors: [{ $ref: '#/components/errors/UserRejected' }],
                      examples: [
                        {
                          name: 'eth_requestAccounts example',
                          params: [],
                          result: {
                            name: 'eth_requestAccountsExampleResult',
                            value: '0xa77392123a1085f75e62eec7dea7e0e1e5142d5f',
                          },
                        },
                      ],
                    },
                    {
                      name: 'eth_accounts',
                      tags: [
                        { $ref: '#/components/tags/MetaMask' },
                        { $ref: '#/components/tags/Restricted' },
                      ],
                      description:
                        'Returns a list of addresses for the accounts owned by the user. This method requires calling `wallet_requestPermissions` for permission. We recommend using `eth_requestAccounts`, which internally calls `wallet_requestPermission`.',
                      summary: "Gets a list of addresses for the user's accounts.",
                      params: [],
                      result: {
                        name: 'AddressList',
                        schema: { type: 'array', items: { $ref: '#/components/schemas/address' } },
                      },
                      examples: [
                        {
                          name: 'eth_accounts example',
                          params: [],
                          result: {
                            name: 'eth_accountsExampleResult',
                            value: '0xa77392123a1085f75e62eec7dea7e0e1e5142d5f',
                          },
                        },
                      ],
                    },
                    {
                      name: 'eth_sendTransaction',
                      tags: [
                        { $ref: '#/components/tags/MetaMask' },
                        { $ref: '#/components/tags/Restricted' },
                        { $ref: '#/components/tags/Multichain' },
                      ],
                      description:
                        "Creates a new wallet confirmation to make an Ethereum transaction from the user's account. This method requires that the user has granted permission to interact with their account first, so make sure to call `eth_requestAccounts` (recommended) or `wallet_requestPermissions` first.",
                      summary: 'Initiates a new transaction.',
                      params: [
                        {
                          name: 'Transaction',
                          required: !0,
                          description: 'The transaction object to sign and send.',
                          schema: {
                            type: 'object',
                            title: 'Transaction',
                            description:
                              'The parameters to customize a transaction. If a `to` address is not provided, it will be assumed that the transaction is a contract creation transaction, and the `data` field of the transaction will be used as the contract initialization code. `gasPrice` cannot be used together with `maxPriorityFeePerGas` and `maxFeePerGas`.',
                            required: ['from'],
                            if: { properties: { to: { not: { type: 'string' } } } },
                            then: { required: ['data'] },
                            properties: {
                              to: { title: 'to address', $ref: '#/components/schemas/address' },
                              from: { title: 'from address', $ref: '#/components/schemas/address' },
                              gas: { title: 'gas limit', $ref: '#/components/schemas/uint' },
                              value: { title: 'value', $ref: '#/components/schemas/uint' },
                              data: { title: 'data', $ref: '#/components/schemas/bytes' },
                              gasPrice: {
                                title: 'gas price',
                                description:
                                  'The gas price the sender is willing to pay to miners in wei. Used in pre-1559 transactions.',
                                $ref: '#/components/schemas/uint',
                              },
                              maxPriorityFeePerGas: {
                                title: 'max priority fee per gas',
                                description:
                                  'Maximum fee per gas the sender is willing to pay to miners in wei. Used in 1559 transactions.',
                                $ref: '#/components/schemas/uint',
                              },
                              maxFeePerGas: {
                                title: 'max fee per gas',
                                description:
                                  'The maximum total fee per gas the sender is willing to pay (includes the network / base fee and miner / priority fee) in wei. Used in 1559 transactions.',
                                $ref: '#/components/schemas/uint',
                              },
                            },
                          },
                        },
                      ],
                      result: {
                        name: 'TransactionHash',
                        description: 'The transaction hash of the sent transaction.',
                        schema: { $ref: '#/components/schemas/bytes32' },
                      },
                      errors: [
                        {
                          code: 4100,
                          message:
                            'The requested account and/or method has not been authorized by the user.',
                        },
                      ],
                      examples: [
                        {
                          name: 'sendTransaction',
                          params: [
                            {
                              name: 'Transaction',
                              value: {
                                to: '0x4B0897b0513FdBeEc7C469D9aF4fA6C0752aBea7',
                                from: '0xDeaDbeefdEAdbeefdEadbEEFdeadbeefDEADbEEF',
                                gas: '0x76c0',
                                value: '0x8ac7230489e80000',
                                data: '0x',
                                gasPrice: '0x4a817c800',
                              },
                            },
                          ],
                          result: {
                            name: 'eth_sendTransactionExampleResult',
                            value:
                              '0x4e306b5a5a37532e1734503f7d2427a86f2c992fbe471f5be403b9f734e667c8',
                          },
                        },
                      ],
                    },
                    {
                      name: 'eth_decrypt',
                      tags: [
                        { $ref: '#/components/tags/MetaMask' },
                        { $ref: '#/components/tags/Restricted' },
                        { $ref: '#/components/tags/Deprecated' },
                      ],
                      summary: 'Decrypts an encrypted message.',
                      description:
                        'This method is deprecated and may be removed in the future.\n\n Requests that MetaMask decrypt the specified encrypted message.\n The message must have been encrypted using the public encryption key of the specified Ethereum address.\n Returns a promise that resolves to the decrypted message, or rejects if the decryption attempt fails.',
                      params: [
                        {
                          name: 'EncryptedMessage',
                          required: !0,
                          description: 'The encrypted message to decrypt.',
                          schema: { type: 'string' },
                        },
                        {
                          name: 'Address',
                          required: !0,
                          description:
                            'The address of the Ethereum account that can decrypt the message.',
                          schema: { $ref: '#/components/schemas/address' },
                        },
                      ],
                      result: {
                        name: 'PermissionsList',
                        schema: { $ref: '#/components/schemas/PermissionsList' },
                      },
                      errors: [
                        {
                          code: 4100,
                          message:
                            'The requested account and/or method has not been authorized by the user.',
                        },
                      ],
                      examples: [
                        {
                          name: 'decryptExample',
                          params: [
                            {
                              name: 'EncryptedMessage',
                              value:
                                '0x7b2276657273696f6e223a227832353531392d7873616c736132302d706f6c7931333035222c226e6f6e6365223a2243533967507076467071765358704655416679726a7179774e35302b7a747766222c22657068656d5075626c69634b6579223a224372774b61456d2f4b356d6d714239764c376f5872636d6441417757764479324f784c3333527135576e553d222c2263697068657274657874223a2248347a65336e7177572b753174663956343945506167454e343872774f766b6952676244566e47587a38493d227d',
                            },
                            {
                              name: 'Address',
                              value: '0xD1F5279BE4B4dD94133A23deE1B23F5bfC0Db1d0',
                            },
                          ],
                          result: { name: 'eth_decryptExampleResult', value: 'Hello, Ethereum!' },
                        },
                      ],
                    },
                    {
                      name: 'eth_getEncryptionPublicKey',
                      tags: [
                        { $ref: '#/components/tags/MetaMask' },
                        { $ref: '#/components/tags/Restricted' },
                        { $ref: '#/components/tags/Deprecated' },
                      ],
                      summary: 'Gets a public key used for encryption.',
                      description:
                        'This method is deprecated and may be removed in the future.\n\n Requests that the user share their public encryption key.\n Returns a public encryption key, or rejects if the user denies the request.\n The public key is computed from entropy associated with the specified user account, using the NaCl implementation of the `X25519_XSalsa20_Poly1305` algorithm.',
                      params: [
                        {
                          name: 'Address',
                          required: !0,
                          description:
                            'The address of the Ethereum account that can decrypt the message.',
                          schema: { $ref: '#/components/schemas/address' },
                        },
                      ],
                      result: { name: 'EncryptionKey', schema: { type: 'string' } },
                      examples: [
                        {
                          name: 'eth_getEncryptionPublicKey',
                          params: [
                            {
                              name: 'Address',
                              value: '0x4B0897b0513FdBeEc7C469D9aF4fA6C0752aBea7',
                            },
                          ],
                          result: {
                            name: 'eth_getEncryptionPublicKeyExampleResult',
                            value:
                              '0x04bfcab3b7ca7e8b3f3b62b2f7f77e9e4b68080bbf8f0f4a1c8f890864d2c7c1d3c45d8b2e3f5f1c27dfeea4c2f5733e90bfc7484e2a690aa9b8ac4559d2e6a8d7',
                          },
                        },
                      ],
                    },
                    {
                      name: 'web3_clientVersion',
                      tags: [
                        { $ref: '#/components/tags/Ethereum' },
                        { $ref: '#/components/tags/Multichain' },
                      ],
                      description:
                        'Returns the current MetaMask client version. This differs slightly per client. For example, the browser extension returns a string like `MetaMask/v10.33.1`, while the mobile app returns a string like `MetaMask/8.1.2/Mobile`.',
                      summary: 'Current client version.',
                      params: [],
                      examples: [
                        {
                          name: 'MetaMaskClientVersionExample',
                          description: 'Example version response from MetaMask.',
                          params: [],
                          result: {
                            name: 'MetaMaskClientVersion',
                            description: 'The current client version.',
                            value: 'MetaMask/v10.33.1',
                          },
                        },
                        {
                          name: 'MetaMaskMobileClientVersionExample',
                          description: 'Example version response from MetaMask Mobile.',
                          params: [],
                          result: {
                            name: 'MetaMaskClientVersion',
                            description: 'The current client version.',
                            value: 'MetaMask/8.1.2/Mobile',
                          },
                        },
                      ],
                      result: {
                        name: 'CurrentVersion',
                        description: 'The current client version.',
                        schema: { title: 'CurrentClientVersion', type: 'string' },
                      },
                    },
                    {
                      name: 'eth_subscribe',
                      tags: [
                        { $ref: '#/components/tags/Ethereum' },
                        { $ref: '#/components/tags/Multichain' },
                      ],
                      summary:
                        'Subscribes to specific Ethereum events, returning a subscription ID used to receive notifications.',
                      description:
                        'Subscribes to specific events on the Ethereum network, such as new blocks, or logs. When an event occurs, a notification is sent to the client with the corresponding data. To stop receiving notifications, the client can unsubscribe using `eth_unsubscribe`.',
                      params: [
                        {
                          name: 'subscriptionType',
                          required: !0,
                          schema: {
                            title: 'subscriptionType',
                            type: 'string',
                            enum: ['newHeads', 'logs'],
                            description:
                              'The type of subscription to create. Must be one of the following:\n1. `newHeads` - New block headers.\n2. `logs` - Logs matching a filter object.',
                          },
                        },
                        {
                          name: 'filterOptions',
                          required: !1,
                          schema: {
                            title: 'filterOptions',
                            type: 'object',
                            description:
                              '(Optional) An object containing filter options specific to the subscription type. Only applicable for the `logs` subscription type.',
                            required: ['topics'],
                            properties: {
                              address: {
                                type: 'string',
                                description:
                                  '(Optional) A single address or an array of addresses to filter the logs by.',
                              },
                              topics: {
                                type: 'array',
                                description: 'An array of topics to filter the logs by.',
                                items: { type: 'string' },
                              },
                            },
                          },
                        },
                      ],
                      result: {
                        name: 'subscriptionId',
                        schema: { type: 'string' },
                        description:
                          'A unique subscription ID that can be used to unsubscribe or identify incoming notifications.',
                      },
                      examples: [
                        {
                          name: 'eth_subscribe example',
                          params: [{ name: 'subscriptionType', value: 'newHeads' }],
                          result: {
                            name: 'eth_subscribeExampleResult',
                            value: '0x1b84f2cdf29a204b79e450c1939b30c1',
                          },
                        },
                      ],
                    },
                    {
                      name: 'eth_unsubscribe',
                      tags: [
                        { $ref: '#/components/tags/Ethereum' },
                        { $ref: '#/components/tags/Multichain' },
                      ],
                      summary:
                        'Unsubscribes from a specific Ethereum event, using the subscription ID provided by `eth_subscribe`.',
                      description:
                        'Unsubscribes from specific events on the Ethereum network, to which the client has been previously subscribed using `eth_subscribe`. The client must provide the subscription ID obtained from `eth_subscribe` to stop receiving notifications for the corresponding event.',
                      params: [
                        {
                          name: 'subscriptionId',
                          required: !0,
                          schema: {
                            type: 'string',
                            description:
                              'The unique subscription ID obtained from `eth_subscribe`, used to identify the subscription to be unsubscribed.',
                          },
                        },
                      ],
                      result: {
                        name: 'unsubscribed',
                        schema: { type: 'boolean' },
                        description:
                          'A boolean value indicating whether the unsubscription was successful.',
                      },
                      examples: [
                        {
                          name: 'eth_unsubscribe example',
                          params: [
                            { name: 'subscriptionId', value: '0x1b84f2cdf29a204b79e450c1939b30c1' },
                          ],
                          result: { name: 'eth_unsubscribeExampleResult', value: !0 },
                        },
                      ],
                    },
                    {
                      name: 'wallet_swapAsset',
                      tags: [
                        { $ref: '#/components/tags/MetaMask' },
                        { $ref: '#/components/tags/Experimental' },
                      ],
                      summary:
                        'Allows dApps to request MetaMask to perform a token swap operation.',
                      description:
                        'This method enables dApps to initiate a token swap directly within MetaMask, improving the user experience by streamlining the process of swapping tokens. The method accepts parameters for the source and destination tokens and initiates a token swap operation.',
                      params: [
                        {
                          name: 'SwapAssetParameter',
                          required: !0,
                          schema: {
                            title: 'SwapAssetParameter',
                            type: 'object',
                            required: ['fromToken', 'toToken', 'userAddress'],
                            properties: {
                              fromToken: {
                                type: 'array',
                                items: {
                                  type: 'object',
                                  required: ['address'],
                                  properties: {
                                    address: {
                                      type: 'string',
                                      description:
                                        'The CAIP-10 formatted address of the source token.',
                                      $ref: '#/components/schemas/Caip10Address',
                                    },
                                    value: {
                                      type: 'string',
                                      description:
                                        '(Optional) The amount of the source token to be swapped, in wei, as a hexadecimal string, defaults to 0.',
                                      nullable: !0,
                                    },
                                  },
                                },
                              },
                              toToken: {
                                type: 'object',
                                required: ['address'],
                                properties: {
                                  address: {
                                    type: 'string',
                                    description:
                                      'The CAIP-10 formatted address of the destination token.',
                                    $ref: '#/components/schemas/Caip10Address',
                                  },
                                },
                              },
                              userAddress: {
                                type: 'string',
                                description:
                                  'The CAIP-10 formatted address of the user performing the swap.',
                                $ref: '#/components/schemas/Caip10Address',
                              },
                            },
                          },
                        },
                      ],
                      result: {
                        name: 'SwapAssetResult',
                        description: 'A boolean indicating if the swap was initiated successfully.',
                        schema: { type: 'boolean' },
                      },
                      errors: [
                        { code: 6e3, message: 'Swap is not available on this chain {{chainName}}' },
                        {
                          code: -32600,
                          message:
                            'Cross-chain swaps are currently not supported. Both fromToken and toToken must be on the same blockchain.',
                        },
                      ],
                      examples: [
                        {
                          name: 'wallet_swapAsset example',
                          params: [
                            {
                              name: 'SwapAssetParameter',
                              value: {
                                from: [
                                  {
                                    tokenAddress: '0x1234567890abcdefABCDEF1234567890ABCDEF',
                                    value: '0xDE0B6B3A7640000',
                                  },
                                ],
                                to: { tokenAddress: '0xabcdef1234567890ABCDEF1234567890abcdef' },
                                userAddress: '0x0000000000000000000000000000000000000000',
                              },
                            },
                          ],
                          result: { name: 'wallet_swapAssetExampleResult', value: !0 },
                        },
                      ],
                    },
                    {
                      name: 'eth_blockNumber',
                      summary: 'Returns the number of most recent block.',
                      params: [],
                      result: {
                        name: 'Block number',
                        schema: { $ref: '#/components/schemas/uint' },
                      },
                      examples: [
                        {
                          name: 'eth_blockNumber example',
                          params: [],
                          result: { name: 'Block number', value: '0x2377' },
                        },
                      ],
                      tags: [
                        { name: 'Ethereum API', description: 'Ethereum Node JSON-RPC method' },
                        { name: 'Multichain API', description: 'Multichain JSON-RPC method' },
                      ],
                    },
                    {
                      name: 'eth_call',
                      summary:
                        'Executes a new message call immediately without creating a transaction on the block chain.',
                      params: [
                        {
                          name: 'Transaction',
                          required: !0,
                          schema: { $ref: '#/components/schemas/GenericTransaction' },
                        },
                        {
                          name: 'Block',
                          required: !1,
                          schema: { $ref: '#/components/schemas/BlockNumberOrTagOrHash' },
                        },
                      ],
                      result: {
                        name: 'Return data',
                        schema: { $ref: '#/components/schemas/bytes' },
                      },
                      examples: [
                        {
                          name: 'eth_call example',
                          params: [
                            {
                              name: 'Transaction',
                              value: {
                                to: '0x69498dd54bd25aa0c886cf1f8b8ae0856d55ff13',
                                value: '0x1',
                              },
                            },
                            { name: 'Block', value: 'latest' },
                          ],
                          result: { name: 'Return data', value: '0x' },
                        },
                      ],
                      tags: [
                        { name: 'Ethereum API', description: 'Ethereum Node JSON-RPC method' },
                        { name: 'Multichain API', description: 'Multichain JSON-RPC method' },
                      ],
                    },
                    {
                      name: 'eth_chainId',
                      summary: 'Returns the chain ID of the current network.',
                      params: [],
                      result: { name: 'Chain ID', schema: { $ref: '#/components/schemas/uint' } },
                      examples: [
                        {
                          name: 'eth_chainId example',
                          params: [],
                          result: { name: 'Chain ID', value: '0x1' },
                        },
                      ],
                      tags: [
                        { name: 'Ethereum API', description: 'Ethereum Node JSON-RPC method' },
                        { name: 'Multichain API', description: 'Multichain JSON-RPC method' },
                      ],
                    },
                    {
                      name: 'eth_coinbase',
                      summary: 'Returns the client coinbase address.',
                      params: [],
                      result: {
                        name: 'Coinbase address',
                        schema: { $ref: '#/components/schemas/address' },
                      },
                      examples: [
                        {
                          name: 'eth_coinbase example',
                          params: [],
                          result: {
                            name: 'Coinbase address',
                            value: '0xfe3b557e8fb62b89f4916b721be55ceb828dbd73',
                          },
                        },
                      ],
                      tags: [
                        { name: 'Ethereum API', description: 'Ethereum Node JSON-RPC method' },
                        { name: 'Multichain API', description: 'Multichain JSON-RPC method' },
                      ],
                    },
                    {
                      name: 'eth_estimateGas',
                      summary:
                        'Generates and returns an estimate of how much gas is necessary to allow the transaction to complete.',
                      params: [
                        {
                          name: 'Transaction',
                          required: !0,
                          schema: { $ref: '#/components/schemas/GenericTransaction' },
                        },
                        {
                          name: 'Block',
                          required: !1,
                          schema: { $ref: '#/components/schemas/BlockNumberOrTag' },
                        },
                      ],
                      result: { name: 'Gas used', schema: { $ref: '#/components/schemas/uint' } },
                      examples: [
                        {
                          name: 'eth_estimateGas example',
                          params: [
                            {
                              name: 'Transaction',
                              value: {
                                from: '0xfe3b557e8fb62b89f4916b721be55ceb828dbd73',
                                to: '0x44aa93095d6749a706051658b970b941c72c1d53',
                                value: '0x1',
                              },
                            },
                          ],
                          result: { name: 'Gas used', value: '0x5208' },
                        },
                      ],
                      tags: [
                        { name: 'Ethereum API', description: 'Ethereum Node JSON-RPC method' },
                        { name: 'Multichain API', description: 'Multichain JSON-RPC method' },
                      ],
                    },
                    {
                      name: 'eth_feeHistory',
                      summary: 'Transaction fee history',
                      description:
                        'Returns transaction base fee per gas and effective priority fee per gas for the requested/supported block range.',
                      params: [
                        {
                          name: 'blockCount',
                          description:
                            'Requested range of blocks. Clients will return less than the requested range if not all blocks are available.',
                          required: !0,
                          schema: { $ref: '#/components/schemas/uint' },
                        },
                        {
                          name: 'newestBlock',
                          description: 'Highest block of the requested range.',
                          required: !0,
                          schema: { $ref: '#/components/schemas/BlockNumberOrTag' },
                        },
                        {
                          name: 'rewardPercentiles',
                          description:
                            'A monotonically increasing list of percentile values. For each block in the requested range, the transactions will be sorted in ascending order by effective tip per gas and the coresponding effective tip for the percentile will be determined, accounting for gas consumed.',
                          required: !0,
                          schema: {
                            title: 'rewardPercentiles',
                            type: 'array',
                            items: {
                              title: 'rewardPercentile',
                              description: 'Floating point value between 0 and 100.',
                              type: 'number',
                            },
                          },
                        },
                      ],
                      result: {
                        name: 'Fee history result',
                        description:
                          'Fee history for the returned block range. This can be a subsection of the requested range if not all blocks are available.',
                        schema: {
                          title: 'feeHistoryResults',
                          description: 'Fee history results.',
                          type: 'object',
                          required: ['oldestBlock', 'baseFeePerGas', 'gasUsedRatio'],
                          additionalProperties: !1,
                          properties: {
                            oldestBlock: {
                              title: 'oldestBlock',
                              description: 'Lowest number block of returned range.',
                              $ref: '#/components/schemas/uint',
                            },
                            baseFeePerGas: {
                              title: 'baseFeePerGasArray',
                              description:
                                'An array of block base fees per gas. This includes the next block after the newest of the returned range, because this value can be derived from the newest block. Zeroes are returned for pre-EIP-1559 blocks.',
                              type: 'array',
                              items: { $ref: '#/components/schemas/uint' },
                            },
                            baseFeePerBlobGas: {
                              title: 'baseFeePerBlobGasArray',
                              description:
                                'An array of block base fees per blob gas. This includes the next block after the newest of the returned range, because this value can be derived from the newest block. Zeroes are returned for pre-EIP-4844 blocks.',
                              type: 'array',
                              items: { $ref: '#/components/schemas/uint' },
                            },
                            gasUsedRatio: {
                              title: 'gasUsedRatio',
                              description:
                                'An array of block gas used ratios. These are calculated as the ratio of gasUsed and gasLimit.',
                              type: 'array',
                              items: { $ref: '#/components/schemas/ratio' },
                            },
                            blobGasUsedRatio: {
                              title: 'blobGasUsedRatio',
                              description:
                                'An array of block blob gas used ratios. These are calculated as the ratio of blobGasUsed and the max blob gas per block.',
                              type: 'array',
                              items: { $ref: '#/components/schemas/ratio' },
                            },
                            reward: {
                              title: 'rewardArray',
                              description:
                                'A two-dimensional array of effective priority fees per gas at the requested block percentiles.',
                              type: 'array',
                              items: {
                                title: 'rewardPercentile',
                                description:
                                  'An array of effective priority fee per gas data points from a single block. All zeroes are returned if the block is empty.',
                                type: 'array',
                                items: {
                                  title: 'rewardPercentile',
                                  description:
                                    'A given percentile sample of effective priority fees per gas from a single block in ascending order, weighted by gas used. Zeroes are returned if the block is empty.',
                                  $ref: '#/components/schemas/uint',
                                },
                              },
                            },
                          },
                        },
                      },
                      examples: [
                        {
                          name: 'eth_feeHistory example',
                          params: [
                            { name: 'blockCount', value: '0x5' },
                            { name: 'newestblock', value: 'latest' },
                            { name: 'rewardPercentiles', value: [20, 30] },
                          ],
                          result: {
                            name: 'Fee history result',
                            value: {
                              oldestblock: '0x10b52f',
                              baseFeePerGas: [
                                '0x3fa63a3f',
                                '0x37f999ee',
                                '0x3e36f20a',
                                '0x4099f79a',
                                '0x430d532d',
                                '0x46fcd4a4',
                              ],
                              baseFeePerBlobGas: [
                                '0x7b7609c19',
                                '0x6dbe41789',
                                '0x7223341d4',
                                '0x6574a002c',
                                '0x7223341d4',
                                '0x6574a002c',
                              ],
                              gasUsedRatio: [
                                0.017712333333333333, 0.9458865666666667, 0.6534561,
                                0.6517375666666667, 0.7347769666666667,
                              ],
                              blobGasUsedRatio: [0, 0.6666666666666666, 0, 1, 0],
                              reward: [
                                ['0x3b9aca00', '0x59682f00'],
                                ['0x3a13012', '0x3a13012'],
                                ['0x3a13012', '0x3a13012'],
                                ['0xf4240', '0xf4240'],
                                ['0xf4240', '0xf4240'],
                              ],
                            },
                          },
                        },
                      ],
                      tags: [
                        { name: 'Ethereum API', description: 'Ethereum Node JSON-RPC method' },
                        { name: 'Multichain API', description: 'Multichain JSON-RPC method' },
                      ],
                    },
                    {
                      name: 'eth_gasPrice',
                      summary: 'Returns the current price per gas in wei.',
                      params: [],
                      result: {
                        name: 'Gas price',
                        schema: { title: 'Gas price', $ref: '#/components/schemas/uint' },
                      },
                      examples: [
                        {
                          name: 'eth_gasPrice example',
                          params: [],
                          result: { name: 'Gas price', value: '0x3e8' },
                        },
                      ],
                      tags: [
                        { name: 'Ethereum API', description: 'Ethereum Node JSON-RPC method' },
                        { name: 'Multichain API', description: 'Multichain JSON-RPC method' },
                      ],
                    },
                    {
                      name: 'eth_getBalance',
                      summary: 'Returns the balance of the account of given address.',
                      params: [
                        {
                          name: 'Address',
                          required: !0,
                          schema: { $ref: '#/components/schemas/address' },
                        },
                        {
                          name: 'Block',
                          required: !0,
                          schema: { $ref: '#/components/schemas/BlockNumberOrTagOrHash' },
                        },
                      ],
                      result: { name: 'Balance', schema: { $ref: '#/components/schemas/uint' } },
                      examples: [
                        {
                          name: 'eth_getBalance example',
                          params: [
                            {
                              name: 'Address',
                              value: '0xfe3b557e8fb62b89f4916b721be55ceb828dbd73',
                            },
                            { name: 'Block', value: 'latest' },
                          ],
                          result: { name: 'Balance', value: '0x1cfe56f3795885980000' },
                        },
                      ],
                      tags: [
                        { name: 'Ethereum API', description: 'Ethereum Node JSON-RPC method' },
                        { name: 'Multichain API', description: 'Multichain JSON-RPC method' },
                      ],
                    },
                    {
                      name: 'eth_getBlockByHash',
                      summary: 'Returns information about a block by hash.',
                      params: [
                        {
                          name: 'Block hash',
                          required: !0,
                          schema: { $ref: '#/components/schemas/hash32' },
                        },
                        {
                          name: 'Hydrated transactions',
                          required: !0,
                          schema: { title: 'hydrated', type: 'boolean' },
                        },
                      ],
                      result: {
                        name: 'Block information',
                        schema: {
                          oneOf: [
                            { $ref: '#/components/schemas/notFound' },
                            { $ref: '#/components/schemas/Block' },
                          ],
                        },
                      },
                      examples: [
                        {
                          name: 'eth_getBlockByHash example',
                          params: [
                            {
                              name: 'Block hash',
                              value:
                                '0xd5f1812548be429cbdc6376b29611fc49e06f1359758c4ceaaa3b393e2239f9c',
                            },
                            { name: 'Hydrated transactions', value: !1 },
                          ],
                          result: {
                            name: 'Block information',
                            value: {
                              number: '0x68b3',
                              hash: '0xd5f1812548be429cbdc6376b29611fc49e06f1359758c4ceaaa3b393e2239f9c',
                              mixHash:
                                '0x24900fb3da77674a861c428429dce0762707ecb6052325bbd9b3c64e74b5af9d',
                              parentHash:
                                '0x1f68ac259155e2f38211ddad0f0a15394d55417b185a93923e2abe71bb7a4d6d',
                              nonce: '0x378da40ff335b070',
                              sha3Uncles:
                                '0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347',
                              logsBloom:
                                '0x00000000000000100000004080000000000500000000000000020000100000000800001000000004000001000000000000000800040010000020100000000400000010000000000000000040000000000000040000000000000000000000000000000400002400000000000000000000000000000004000004000000000000840000000800000080010004000000001000000800000000000000000000000000000000000800000000000040000000020000000000000000000800000400000000000000000000000600000400000000002000000000000000000000004000000000000000100000000000000000000000000000000000040000900010000000',
                              transactionsRoot:
                                '0x4d0c8e91e16bdff538c03211c5c73632ed054d00a7e210c0eb25146c20048126',
                              stateRoot:
                                '0x91309efa7e42c1f137f31fe9edbe88ae087e6620d0d59031324da3e2f4f93233',
                              receiptsRoot:
                                '0x68461ab700003503a305083630a8fb8d14927238f0bc8b6b3d246c0c64f21f4a',
                              miner: '0xb42b6c4a95406c78ff892d270ad20b22642e102d',
                              difficulty: '0x66e619a',
                              totalDifficulty: '0x1e875d746ae',
                              extraData: '0xd583010502846765746885676f312e37856c696e7578',
                              size: '0x334',
                              gasLimit: '0x47e7c4',
                              gasUsed: '0x37993',
                              timestamp: '0x5835c54d',
                              uncles: [],
                              transactions: [
                                '0xa0807e117a8dd124ab949f460f08c36c72b710188f01609595223b325e58e0fc',
                                '0xeae6d797af50cb62a596ec3939114d63967c374fa57de9bc0f4e2b576ed6639d',
                              ],
                              baseFeePerGas: '0x7',
                              withdrawalsRoot:
                                '0x7a4ecf19774d15cf9c15adf0dd8e8a250c128b26c9e2ab2a08d6c9c8ffbd104f',
                              withdrawals: [
                                {
                                  index: '0x0',
                                  validatorIndex: '0x9d8c0',
                                  address: '0xb9d7934878b5fb9610b3fe8a5e441e8fad7e293f',
                                  amount: '0x11a33e3760',
                                },
                              ],
                              blobGasUsed: '0x0',
                              excessBlobGas: '0x0',
                              parentBeaconBlockRoot:
                                '0x95c4dbd5b19f6fe3cbc3183be85ff4e85ebe75c5b4fc911f1c91e5b7a554a685',
                            },
                          },
                        },
                      ],
                      tags: [
                        { name: 'Ethereum API', description: 'Ethereum Node JSON-RPC method' },
                        { name: 'Multichain API', description: 'Multichain JSON-RPC method' },
                      ],
                    },
                    {
                      name: 'eth_getBlockByNumber',
                      summary: 'Returns information about a block by number.',
                      params: [
                        {
                          name: 'Block',
                          required: !0,
                          schema: { $ref: '#/components/schemas/BlockNumberOrTag' },
                        },
                        {
                          name: 'Hydrated transactions',
                          required: !0,
                          schema: { title: 'hydrated', type: 'boolean' },
                        },
                      ],
                      result: {
                        name: 'Block information',
                        schema: {
                          oneOf: [
                            { $ref: '#/components/schemas/notFound' },
                            { $ref: '#/components/schemas/Block' },
                          ],
                        },
                      },
                      examples: [
                        {
                          name: 'eth_getBlockByNumber example',
                          params: [
                            { name: 'block', value: '0x68b3' },
                            { name: 'Hydrated transactions', value: !1 },
                          ],
                          result: {
                            name: 'Block information',
                            value: {
                              number: '0x68b3',
                              hash: '0xd5f1812548be429cbdc6376b29611fc49e06f1359758c4ceaaa3b393e2239f9c',
                              mixHash:
                                '0x24900fb3da77674a861c428429dce0762707ecb6052325bbd9b3c64e74b5af9d',
                              parentHash:
                                '0x1f68ac259155e2f38211ddad0f0a15394d55417b185a93923e2abe71bb7a4d6d',
                              nonce: '0x378da40ff335b070',
                              sha3Uncles:
                                '0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347',
                              logsBloom:
                                '0x00000000000000100000004080000000000500000000000000020000100000000800001000000004000001000000000000000800040010000020100000000400000010000000000000000040000000000000040000000000000000000000000000000400002400000000000000000000000000000004000004000000000000840000000800000080010004000000001000000800000000000000000000000000000000000800000000000040000000020000000000000000000800000400000000000000000000000600000400000000002000000000000000000000004000000000000000100000000000000000000000000000000000040000900010000000',
                              transactionsRoot:
                                '0x4d0c8e91e16bdff538c03211c5c73632ed054d00a7e210c0eb25146c20048126',
                              stateRoot:
                                '0x91309efa7e42c1f137f31fe9edbe88ae087e6620d0d59031324da3e2f4f93233',
                              receiptsRoot:
                                '0x68461ab700003503a305083630a8fb8d14927238f0bc8b6b3d246c0c64f21f4a',
                              miner: '0xb42b6c4a95406c78ff892d270ad20b22642e102d',
                              difficulty: '0x66e619a',
                              totalDifficulty: '0x1e875d746ae',
                              extraData: '0xd583010502846765746885676f312e37856c696e7578',
                              size: '0x334',
                              gasLimit: '0x47e7c4',
                              gasUsed: '0x37993',
                              timestamp: '0x5835c54d',
                              uncles: [],
                              transactions: [
                                '0xa0807e117a8dd124ab949f460f08c36c72b710188f01609595223b325e58e0fc',
                                '0xeae6d797af50cb62a596ec3939114d63967c374fa57de9bc0f4e2b576ed6639d',
                              ],
                              baseFeePerGas: '0x7',
                              withdrawalsRoot:
                                '0x7a4ecf19774d15cf9c15adf0dd8e8a250c128b26c9e2ab2a08d6c9c8ffbd104f',
                              withdrawals: [
                                {
                                  index: '0x0',
                                  validatorIndex: '0x9d8c0',
                                  address: '0xb9d7934878b5fb9610b3fe8a5e441e8fad7e293f',
                                  amount: '0x11a33e3760',
                                },
                              ],
                              blobGasUsed: '0x0',
                              excessBlobGas: '0x0',
                              parentBeaconBlockRoot:
                                '0x95c4dbd5b19f6fe3cbc3183be85ff4e85ebe75c5b4fc911f1c91e5b7a554a685',
                            },
                          },
                        },
                      ],
                      tags: [
                        { name: 'Ethereum API', description: 'Ethereum Node JSON-RPC method' },
                        { name: 'Multichain API', description: 'Multichain JSON-RPC method' },
                      ],
                    },
                    {
                      name: 'eth_getBlockTransactionCountByHash',
                      summary:
                        'Returns the number of transactions in a block from a block matching the given block hash.',
                      params: [
                        { name: 'Block hash', schema: { $ref: '#/components/schemas/hash32' } },
                      ],
                      result: {
                        name: 'Transaction count',
                        schema: {
                          oneOf: [
                            { $ref: '#/components/schemas/notFound' },
                            { title: 'Transaction count', $ref: '#/components/schemas/uint' },
                          ],
                        },
                      },
                      examples: [
                        {
                          name: 'eth_getBlockTransactionCountByHash example',
                          params: [
                            {
                              name: 'Block hash',
                              value:
                                '0xb903239f8543d04b5dc1ba6579132b143087c68db1b2168786408fcbce568238',
                            },
                          ],
                          result: { name: 'Transaction count', value: '0x8' },
                        },
                      ],
                      tags: [
                        { name: 'Ethereum API', description: 'Ethereum Node JSON-RPC method' },
                        { name: 'Multichain API', description: 'Multichain JSON-RPC method' },
                      ],
                    },
                    {
                      name: 'eth_getBlockTransactionCountByNumber',
                      summary:
                        'Returns the number of transactions in a block matching the given block number.',
                      params: [
                        {
                          name: 'Block',
                          schema: { $ref: '#/components/schemas/BlockNumberOrTag' },
                        },
                      ],
                      result: {
                        name: 'Transaction count',
                        schema: {
                          oneOf: [
                            { $ref: '#/components/schemas/notFound' },
                            { title: 'Transaction count', $ref: '#/components/schemas/uint' },
                          ],
                        },
                      },
                      examples: [
                        {
                          name: 'eth_getBlockTransactionCountByNumber example',
                          params: [{ name: 'Block', value: '0xe8' }],
                          result: { name: 'Transaction count', value: '0x8' },
                        },
                      ],
                      tags: [
                        { name: 'Ethereum API', description: 'Ethereum Node JSON-RPC method' },
                        { name: 'Multichain API', description: 'Multichain JSON-RPC method' },
                      ],
                    },
                    {
                      name: 'eth_getCode',
                      summary: 'Returns code at a given address.',
                      params: [
                        {
                          name: 'Address',
                          required: !0,
                          schema: { $ref: '#/components/schemas/address' },
                        },
                        {
                          name: 'Block',
                          required: !0,
                          schema: { $ref: '#/components/schemas/BlockNumberOrTagOrHash' },
                        },
                      ],
                      result: { name: 'Bytecode', schema: { $ref: '#/components/schemas/bytes' } },
                      examples: [
                        {
                          name: 'eth_getCode example',
                          params: [
                            {
                              name: 'Address',
                              value: '0xa50a51c09a5c451c52bb714527e1974b686d8e77',
                            },
                            { name: 'Block', value: 'latest' },
                          ],
                          result: {
                            name: 'Bytecode',
                            value:
                              '0x60806040526004361060485763ffffffff7c01000000000000000000000000000000000000000000000000000000006000350416633fa4f2458114604d57806355241077146071575b600080fd5b348015605857600080fd5b50605f6088565b60408051918252519081900360200190f35b348015607c57600080fd5b506086600435608e565b005b60005481565b60008190556040805182815290517f199cd93e851e4c78c437891155e2112093f8f15394aa89dab09e38d6ca0727879181900360200190a1505600a165627a7a723058209d8929142720a69bde2ab3bfa2da6217674b984899b62753979743c0470a2ea70029',
                          },
                        },
                      ],
                      tags: [
                        { name: 'Ethereum API', description: 'Ethereum Node JSON-RPC method' },
                        { name: 'Multichain API', description: 'Multichain JSON-RPC method' },
                      ],
                    },
                    {
                      name: 'eth_getFilterChanges',
                      summary:
                        'Polling method for the filter with the given ID (created using `eth_newFilter`). Returns an array of logs which occurred since last poll.',
                      params: [
                        {
                          name: 'Filter identifier',
                          schema: { $ref: '#/components/schemas/uint' },
                        },
                      ],
                      result: {
                        name: 'Log objects',
                        schema: { $ref: '#/components/schemas/FilterResults' },
                      },
                      examples: [
                        {
                          name: 'eth_getFilterChanges example',
                          params: [{ name: 'Filter identifier', value: '0x01' }],
                          result: {
                            name: 'Log objects',
                            value: [
                              {
                                logIndex: '0x0',
                                removed: !1,
                                blockNumber: '0x233',
                                blockHash:
                                  '0xfc139f5e2edee9e9c888d8df9a2d2226133a9bd87c88ccbd9c930d3d4c9f9ef5',
                                transactionHash:
                                  '0x66e7a140c8fa27fe98fde923defea7562c3ca2d6bb89798aabec65782c08f63d',
                                transactionIndex: '0x0',
                                address: '0x42699a7612a82f1d9c36148af9c77354759b210b',
                                data: '0x0000000000000000000000000000000000000000000000000000000000000004',
                                topics: [
                                  '0x04474795f5b996ff80cb47c148d4c5ccdbe09ef27551820caa9c2f8ed149cce3',
                                ],
                              },
                              {
                                logIndex: '0x0',
                                removed: !1,
                                blockNumber: '0x238',
                                blockHash:
                                  '0x98b0ec0f9fea0018a644959accbe69cd046a8582e89402e1ab0ada91cad644ed',
                                transactionHash:
                                  '0xdb17aa1c2ce609132f599155d384c0bc5334c988a6c368056d7e167e23eee058',
                                transactionIndex: '0x0',
                                address: '0x42699a7612a82f1d9c36148af9c77354759b210b',
                                data: '0x0000000000000000000000000000000000000000000000000000000000000007',
                                topics: [
                                  '0x04474795f5b996ff80cb47c148d4c5ccdbe09ef27551820caa9c2f8ed149cce3',
                                ],
                              },
                            ],
                          },
                        },
                      ],
                      tags: [
                        { name: 'Ethereum API', description: 'Ethereum Node JSON-RPC method' },
                        { name: 'Multichain API', description: 'Multichain JSON-RPC method' },
                      ],
                    },
                    {
                      name: 'eth_getFilterLogs',
                      summary:
                        'Returns an array of all logs matching the filter with the given ID (created using `eth_newFilter`).',
                      params: [
                        {
                          name: 'Filter identifier',
                          schema: { $ref: '#/components/schemas/uint' },
                        },
                      ],
                      result: {
                        name: 'Log objects',
                        schema: { $ref: '#/components/schemas/FilterResults' },
                      },
                      examples: [
                        {
                          name: 'eth_getFilterLogs example',
                          params: [{ name: 'Filter identifier', value: '0x01' }],
                          result: {
                            name: 'Log objects',
                            value: [
                              {
                                logIndex: '0x0',
                                removed: !1,
                                blockNumber: '0x233',
                                blockHash:
                                  '0xfc139f5e2edee9e9c888d8df9a2d2226133a9bd87c88ccbd9c930d3d4c9f9ef5',
                                transactionHash:
                                  '0x66e7a140c8fa27fe98fde923defea7562c3ca2d6bb89798aabec65782c08f63d',
                                transactionIndex: '0x0',
                                address: '0x42699a7612a82f1d9c36148af9c77354759b210b',
                                data: '0x0000000000000000000000000000000000000000000000000000000000000004',
                                topics: [
                                  '0x04474795f5b996ff80cb47c148d4c5ccdbe09ef27551820caa9c2f8ed149cce3',
                                ],
                              },
                              {
                                logIndex: '0x0',
                                removed: !1,
                                blockNumber: '0x238',
                                blockHash:
                                  '0x98b0ec0f9fea0018a644959accbe69cd046a8582e89402e1ab0ada91cad644ed',
                                transactionHash:
                                  '0xdb17aa1c2ce609132f599155d384c0bc5334c988a6c368056d7e167e23eee058',
                                transactionIndex: '0x0',
                                address: '0x42699a7612a82f1d9c36148af9c77354759b210b',
                                data: '0x0000000000000000000000000000000000000000000000000000000000000007',
                                topics: [
                                  '0x04474795f5b996ff80cb47c148d4c5ccdbe09ef27551820caa9c2f8ed149cce3',
                                ],
                              },
                            ],
                          },
                        },
                      ],
                      tags: [
                        { name: 'Ethereum API', description: 'Ethereum Node JSON-RPC method' },
                        { name: 'Multichain API', description: 'Multichain JSON-RPC method' },
                      ],
                    },
                    {
                      name: 'eth_getLogs',
                      summary: 'Returns an array of all logs matching the specified filter.',
                      params: [{ name: 'Filter', schema: { $ref: '#/components/schemas/Filter' } }],
                      result: {
                        name: 'Log objects',
                        schema: { $ref: '#/components/schemas/FilterResults' },
                      },
                      examples: [
                        {
                          name: 'eth_getLogs example',
                          params: [
                            {
                              name: 'Filter',
                              value: {
                                fromBlock: '0x137d3c2',
                                toBlock: '0x137d3c3',
                                address: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
                                topics: [],
                              },
                            },
                          ],
                          result: {
                            name: 'Log objects',
                            value: [
                              {
                                logIndex: '0x0',
                                removed: !1,
                                blockNumber: '0x233',
                                blockHash:
                                  '0xfc139f5e2edee9e9c888d8df9a2d2226133a9bd87c88ccbd9c930d3d4c9f9ef5',
                                transactionHash:
                                  '0x66e7a140c8fa27fe98fde923defea7562c3ca2d6bb89798aabec65782c08f63d',
                                transactionIndex: '0x0',
                                address: '0x42699a7612a82f1d9c36148af9c77354759b210b',
                                data: '0x0000000000000000000000000000000000000000000000000000000000000004',
                                topics: [
                                  '0x04474795f5b996ff80cb47c148d4c5ccdbe09ef27551820caa9c2f8ed149cce3',
                                ],
                              },
                              {
                                logIndex: '0x0',
                                removed: !1,
                                blockNumber: '0x238',
                                blockHash:
                                  '0x98b0ec0f9fea0018a644959accbe69cd046a8582e89402e1ab0ada91cad644ed',
                                transactionHash:
                                  '0xdb17aa1c2ce609132f599155d384c0bc5334c988a6c368056d7e167e23eee058',
                                transactionIndex: '0x0',
                                address: '0x42699a7612a82f1d9c36148af9c77354759b210b',
                                data: '0x0000000000000000000000000000000000000000000000000000000000000007',
                                topics: [
                                  '0x04474795f5b996ff80cb47c148d4c5ccdbe09ef27551820caa9c2f8ed149cce3',
                                ],
                              },
                            ],
                          },
                        },
                      ],
                      tags: [
                        { name: 'Ethereum API', description: 'Ethereum Node JSON-RPC method' },
                        { name: 'Multichain API', description: 'Multichain JSON-RPC method' },
                      ],
                    },
                    {
                      name: 'eth_getProof',
                      summary:
                        'Returns the merkle proof for a given account and optionally some storage keys.',
                      params: [
                        {
                          name: 'Address',
                          required: !0,
                          schema: { $ref: '#/components/schemas/address' },
                        },
                        {
                          name: 'StorageKeys',
                          required: !0,
                          schema: {
                            title: 'Storage keys',
                            type: 'array',
                            items: { $ref: '#/components/schemas/bytesMax32' },
                          },
                        },
                        {
                          name: 'Block',
                          required: !0,
                          schema: { $ref: '#/components/schemas/BlockNumberOrTagOrHash' },
                        },
                      ],
                      result: {
                        name: 'Account',
                        schema: { $ref: '#/components/schemas/AccountProof' },
                      },
                      examples: [
                        {
                          name: 'eth_getProof example',
                          params: [
                            {
                              name: 'Address',
                              value: '0xe5cB067E90D5Cd1F8052B83562Ae670bA4A211a8',
                            },
                            {
                              name: 'StorageKeys',
                              value: [
                                '0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421',
                                '0x283s34c8e2b1456f09832c71e5d6a0b4f8c9e1d3a2b5c7f0e6d4a8b2c1f3e5d7',
                              ],
                            },
                            { name: 'Block', value: 'latest' },
                          ],
                          result: {
                            name: 'Account',
                            value: {
                              accountProof: [
                                '0xf90211a06a718c2c9da77c253b12d7b2569657901e37bb691718f5dda1b86157ab1dd5eda0e7f19ed5e21bccc8d3260236b24f80ad88b3634f5d005f37b838881f0e12f1bda0abb301291704e4d92686c0f5f8ebb1734185321559b8d717ffdca95c99591976a0d0c2026bfab65c3b95276bfa82af9dec860b485f8857f293c148d63a2182128fa0c98044ec9a1273a218bed58b478277dd39173ad7b8edb95c200423a6bc8fc25fa056e5a55d9ddccdbf49362857200bbb1f042d61187c9f5f9ddcff5d2f1fc984a2a02a5b7200af424114f99a4b5f0a21c19aac82209e431ed80bfde177adb1004bdfa0026e4374f0518ff44a80fa374838ecb86cc64ac93bb710fea6dff4198f947b27a03fea341d87984673ad523177ed52f278bf4d8f97e6531c8ece932aeede4802f4a0bfe2f4a7fcb78f7e9f080dea7b6977fb1d88c441696e4456dad92b9d34ff0f43a02a3eb5c0edb14626c9c629601027bd60178bb2b688a67cea4d179fc432436615a0747355b8e02f3b884b4ffe5cea1619e32515fea064cca98208591af8c744e894a0874253737bae37f020ad3bb7e3292c7c4a63cdc158af6b33aaa4deaef016dccba03d8192bc1fc6aa1548912e763a0b5013a94399cefad7b47cf388873b2b794068a09b67f9737c6028d796bfd1c5da57a6f45824dc891f848ea0e1f8019d1fb5fba8a0aa871f9de8da85960fcd8a22cdf21c27f11e3966c14a6737ffd414b98dda00b280',
                                '0xf90211a0d360be1e1da1a0c32bc4c105833bd531e59d110684007b7c50fb2709002973eca0cf6dd1e350a7031b4e2ab49c899fd8bd47551c8565d8fd8d1d7796c83820c3b1a0eb0a88c29bb33989a589156f7bf07d9efc74034dd9d3f5b73385c3b45c3249bea02783c25f97a6ddb8dc07adf4b176991836d39184b1f678adeda832fff15e3664a00a4e288060045e587774d8a64993a7add73068b16863145e1e8eeb4602e18e19a0340851f4046ad1298962d6e47d05c66329549c839c158748aaad7ae00b943aefa085b127bc2a3bd17604283de21b2b3c9aa8f1d4b7b85c94d8105a46fe32c77688a00f531d62b3c5435324c01009c284fe31277e8d38302b75ea01be89f09e205969a00011c8351c0e3d639ac54b9d3a59de630b16a67de8270d7d6064d0a67e93f9cca048780d32b7f2db88650b51c46f46fd0a68795edee1fd5ecee6eb3595741d9669a0c91afd74eaf8e08a997061a62b354e2516fdc494e8e26cc50ceeb8f4a175608ba0e2c07f1b48fab80eecb340f5882e8c7b32ee416e4045c61f1df646a133487303a01a1eff78435a7a29a29463bdc3486ae81364b00bea82ba0fdf67a110770f2261a04f2eb440ba71c72da5fd7f0e439018d6671dc809f747213a1ea755848124e994a074ff9f37fce99daa3ed01dd763076450022996fc729be2cc43c61ec5182c2366a0b80b36b7b621112592f52390b89748d422e9b1517c4b0203b8176a53f89d4a6680',
                                '0xf90211a0b25f283bd01a8c8b2418049f9585bc37ff2c1e2e12eab4b7f64ae1f26647389aa02ad96c150d7c3c9c194d30315456852cf6a0a940e0191ae5d04007454823d4e9a0b220cf7a855e2dbcc0b973134e2e119b982d7d40dbb1b27d99816c41f40e829aa049224431da84cbf1b7ae813abcc9ef4c1dfc1760f6ddc5d57f7354bf3cbf6cc4a015191f879ac115b362f0257fd3eedb789537e836574a5b1abf1c9982ebe3bdfea07913c1b6e7282569d2d421e9fa2257f5d1698e93303bc49b941704287d7aaefea0a526576981ce6fd9f2bd48dd2ca6d5272f2fbdc85f0ee35a295f6ccd97ae8765a0313fad407f0c737c29024c02a890c4ecc12d7771c05ab7b435e5087a7cdef4d9a0d2044603cba9d4afdaf6fd2470e729ef3a65242de71276f20d59accfa6b53a7ca0457caacb9370c09b15f7d904adefd2308be94e23669ba5f43241ffff5f438a0aa09fb2dd45a383a0cc088a72b14117e1e9b7d6889218f3ac7631e8de644c5cb76da0c675dcd4d3fb692b514851c6106e2b09e6f5661d56a0a32ae02e2efc1515c235a074949a59ff1bdba87548510d6e404ec4532f4456dfdec8e753d92fda11a3088ba0a328c6ab1ab8f70db4d23e95bb163c13ba0c508f063a5b1393a4efd7ff375f05a0c722fe3ce796998269373cbb2fc229b2bdf2c43c6c2df003309422e043ce6c03a024e69343286eec44fa4744f6907209116e5383cff3fa98fe81ba06e7e8d4366680',
                                '0xf90211a00e99ba2198124b8241ea304551fe973215829e2fbc0438d67922707a2a847432a0bb9ce24fd527879c5fe6dbbec1ef5a05ed9d1ca88e921d140bafbec1112f6a6aa099787fd6c7a1989229c4291ef5267335e66152ce417daea46e66d19cb6f81d1ca0e430ff4b8d5621baa5978673344e78b4d8b4df51431b6e63785267c98a24ce18a0bb3e91a825fe3d42ed270a93e9ad1aabd566c40cb28e622f7f1d7ee967c8afd6a0aa364b0056870c6507bc3262a5f851ecb13684088bdb13996d3cb2db401ce3ffa0a3732eba4c7a6e062665ab5be08acb986c3db87556fb138548cc900ff1e56995a026b088e90c9738b8ce16e853107a937a50d52726a24f9f6ce60f587762eb45a2a006c9d5bc3c064b5c1fb565bff91cace9161c64ae653a329610c1dcf34d434429a06c16df2edc70656d322d0c2403bad7d45bc790ffc3e7adeef856d98ea6afc91ba0ae05ed5d6c34b5da29c2e94d7880aeba0906f95f4ec10b132a1d4766a0701c98a01470a86aa350d1ada0c082eac75de828a851f9c8c7c4aa49b1556fe3a5574966a0334eef025100a6da1033710dd98e0475f29d3d7e397caf618ca71c336c5f4f49a0ef0b3abbebcff34d6a8a8f5cdbfbd154ab3452b58dcb09de58ec983644963675a041857e865ec38e200a13bc1a3cb71c7d69aeef7ffdee8be515c9a5b691ce091fa059edd0eb3bbec36bbf38a19802d4646c00ba821ab55fdeea12e15bab62c4e1e580',
                                '0xf90211a0af0c7fa65ffcb84c31e68c1cf00e1a20bf8bb497c39883e19b66a99975b03431a0c492cab3623eb7926069794c3c718733e16c5fd0d4a13fb7c752ee9809aac7ada05003cea7132aa70d6f36731d60640a90bcd8f4fd493e4540d5ab1b4943679c0ca0fd700683405b1d2306b586dd3b5b2f92f1692fae20d17cd8b8e59d09b9c6670da01db8683910e46e56e8afeb9fe2b7c35382e5a0914d7b0dd8f0e8cb9981ba7435a0fa7f75d73aa73c35824387bec81388315caa4aee3f4f5562f971beb256c62d49a0ee478e420d83f413e8568dacfd5d83f83a5dd7c45f494b504828e5dc962f0e3ea094b95444a917ac94a675681f6bf851172ad0969801a783a63a71edafed45e7a7a0a0c46586e109abe80fe50361dd582e3f143cb416828239faa43bb2b890869501a0ae051d5d43634c68bf9c97823256cc68580f194dfdbd0c301140c7ca5853430ca0660b9365bb77ec9cdc6eb95516c162dca20727c6f828dbbeb1ae110dde4d3134a09feb1b75e84ff6722e4d837bfb6d207b6ee3b21b86844a01140ce293813b49a1a0ed58a70b04efa3bdc0babe2abfa20824a75d61d52291bfdb5cf08597800764d6a020a2d5d3a83f9e35ad9fd1c448626d90af0eb3efefaa4f2f93207b4096ef5507a0fc8efc4484dcf0a54f0574de9aaade0dcff6ec3599edb9f82efb26b6566dcaeaa032f7e79856db3fd984f72bb2c93d4dab328198d355a61c975fab1f08bdb2046580',
                              ],
                              balance: '0x0',
                              codeHash:
                                '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470',
                              nonce: '0x0',
                              storageHash:
                                '0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421',
                              storageProof: [
                                {
                                  key: '0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421',
                                  proof: [
                                    '0xf90211a0c87222cccea2bf32759fcee9dbaacbe3ea4165dd6184af6773651c5e00e34a8ba0be90e6e5d1a67ab5587779c60ac136d6a96db62b84c04998a5f03a367346abd6a05344aa1c9ca2e3e56bf98fd718ec43728578d148e1967fbaf8bf17a2a073a0bda011a2f9312c3308640a0d6ceeae218747290f23806067456da1d444c65abae437a0b3097a108bfce79af6699da4ae3003cd4929f0b4576aad655c31cb725bde84c7a0c133d3c637e174f36a73c22b1039eb003da6374bc0929321241badb3efa3c4a9a0f13059f2301ad9862ce02e3f7f3f2c9ab78eb30583764d73654f7f1f8b1e86fda06544e3915748b18204e09df75ff20d2fa6bd8121e2e669699012d54590383d6fa070e3a8e093691581d58fadb560b510262a758037632cd8670d3a36df828976b7a062a88a2900544dc76a32255a6b2b2a2eef8fa68279700c00adc7508286702552a0a474aeebd5603dfce46a6ecd1ecd519068dc034a544fde03ac42d4018e60a334a0b7d528fc41c8fdc8ea18c6e7d0099270c777ec1403cf879d1f5134bdc12a6c6ca04440f1242e42c5bfa7c536591ab89c8e84bea417435871c32eef1e25295b20daa06a5dcfe3cc84cff9d3e3c3ae868cfba8f0dd111a90c3f85869dab5b893f96643a026b2fb9dd7d08b0ed2f1c44fbf875011412a384f86f751c92e1013248d4aa371a0c75597b2b789fc4e939b71937390ce9d7d53159431328ac52180eef08ef200f280',
                                    '0xf90191a0f0c5b800b542001597f2b7a8e106ac0e2849d2cc1df1727ac35c4ea3965f1c9180a08537f2e248702a6ae2a57e9110a5740f5772c876389739ac90debd6a0692713ea00b3a26a05b5494fb3ff6f0b3897688a5581066b20b07ebab9252d169d928717fa0a9a54d84976d134d6dba06a65064c7f3a964a75947d452db6f6bb4b6c47b43aaa01e2a1ed3d1572b872bbf09ee44d2ed737da31f01de3c0f4b4e1f046740066461a076f251d160b9a02eb0b5c1d83b61c9cdd4f37361705e79a45529bf49801fb824a0774a01a624cb14a50d17f2fe4b7ae6af8a67bbb029177ccc3dd729a734484d3ea05921b8a19aebe4fff5a36071e311778f9b93459183fdf7f6d870b401fa25dcbba0c8d71dd13d2806e2865a5c2cfa447f626471bf0b66182a8fd07230434e1cad2680a0e9864fdfaf3693b2602f56cd938ccd494b8634b1f91800ef02203a3609ca4c21a0c69d174ad6b6e58b0bd05914352839ec60915cd066dd2bee2a48016139687f21a0513dd5514fd6bad56871711441d38de2821cc6913cb192416b0385f025650731808080',
                                  ],
                                  value: '0x1',
                                },
                              ],
                            },
                          },
                        },
                      ],
                      tags: [
                        { name: 'Ethereum API', description: 'Ethereum Node JSON-RPC method' },
                        { name: 'Multichain API', description: 'Multichain JSON-RPC method' },
                      ],
                    },
                    {
                      name: 'eth_getStorageAt',
                      summary: 'Returns the value from a storage position at a given address.',
                      params: [
                        {
                          name: 'Address',
                          required: !0,
                          schema: { $ref: '#/components/schemas/address' },
                        },
                        {
                          name: 'Storage slot',
                          required: !0,
                          schema: { $ref: '#/components/schemas/uint256' },
                        },
                        {
                          name: 'Block',
                          required: !0,
                          schema: { $ref: '#/components/schemas/BlockNumberOrTagOrHash' },
                        },
                      ],
                      result: { name: 'Value', schema: { $ref: '#/components/schemas/bytes' } },
                      examples: [
                        {
                          name: 'eth_getStorageAt example',
                          params: [
                            {
                              name: 'Address',
                              value: '0xfe3b557e8fb62b89f4916b721be55ceb828dbd73',
                            },
                            { name: 'Storage slot', value: '0x0' },
                            { name: 'Block', value: 'latest' },
                          ],
                          result: {
                            name: 'Value',
                            value:
                              '0x0000000000000000000000000000000000000000000000000000000000000000',
                          },
                        },
                      ],
                      tags: [
                        { name: 'Ethereum API', description: 'Ethereum Node JSON-RPC method' },
                        { name: 'Multichain API', description: 'Multichain JSON-RPC method' },
                      ],
                    },
                    {
                      name: 'eth_getTransactionByBlockHashAndIndex',
                      summary:
                        'Returns information about a transaction by block hash and transaction index position.',
                      params: [
                        {
                          name: 'Block hash',
                          required: !0,
                          schema: { $ref: '#/components/schemas/hash32' },
                        },
                        {
                          name: 'Transaction index',
                          required: !0,
                          schema: { $ref: '#/components/schemas/uint' },
                        },
                      ],
                      result: {
                        name: 'Transaction information',
                        schema: {
                          oneOf: [
                            { $ref: '#/components/schemas/notFound' },
                            { $ref: '#/components/schemas/TransactionInfo' },
                          ],
                        },
                      },
                      examples: [
                        {
                          name: 'eth_getTransactionByBlockHashAndIndex example',
                          params: [
                            {
                              name: 'Block hash',
                              value:
                                '0xbf137c3a7a1ebdfac21252765e5d7f40d115c2757e4a4abee929be88c624fdb7',
                            },
                            { name: 'Transaction index', value: '0x2' },
                          ],
                          result: {
                            name: 'Transaction information',
                            value: {
                              blockHash:
                                '0x510efccf44a192e6e34bcb439a1947e24b86244280762cbb006858c237093fda',
                              blockNumber: '0x422',
                              chainId: 2018,
                              from: '0xfe3b557e8fb62b89f4916b721be55ceb828dbd73',
                              gas: '0x5208',
                              gasPrice: '0x3b9aca00',
                              hash: '0xa52be92809541220ee0aaaede6047d9a6c5d0cd96a517c854d944ee70a0ebb44',
                              input: '0x',
                              nonce: '0x1',
                              to: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
                              transactionIndex: '0x0',
                              value: '0x4e1003b28d9280000',
                              v: '0xfe7',
                              r: '0x84caf09aefbd5e539295acc67217563438a4efb224879b6855f56857fa2037d3',
                              s: '0x5e863be3829812c81439f0ae9d8ecb832b531d651fb234c848d1bf45e62be8b9',
                            },
                          },
                        },
                      ],
                      tags: [
                        { name: 'Ethereum API', description: 'Ethereum Node JSON-RPC method' },
                        { name: 'Multichain API', description: 'Multichain JSON-RPC method' },
                      ],
                    },
                    {
                      name: 'eth_getTransactionByBlockNumberAndIndex',
                      summary:
                        'Returns information about a transaction by block number and transaction index position.',
                      params: [
                        {
                          name: 'Block',
                          required: !0,
                          schema: { $ref: '#/components/schemas/BlockNumberOrTag' },
                        },
                        {
                          name: 'Transaction index',
                          required: !0,
                          schema: { $ref: '#/components/schemas/uint' },
                        },
                      ],
                      result: {
                        name: 'Transaction information',
                        schema: {
                          oneOf: [
                            { $ref: '#/components/schemas/notFound' },
                            { $ref: '#/components/schemas/TransactionInfo' },
                          ],
                        },
                      },
                      examples: [
                        {
                          name: 'eth_getTransactionByBlockNumberAndIndex example',
                          params: [
                            { name: 'Block', value: '0x1442e' },
                            { name: 'Transaction index', value: '0x2' },
                          ],
                          result: {
                            name: 'Transaction information',
                            value: {
                              blockHash:
                                '0x510efccf44a192e6e34bcb439a1947e24b86244280762cbb006858c237093fda',
                              blockNumber: '0x422',
                              chainId: 2018,
                              from: '0xfe3b557e8fb62b89f4916b721be55ceb828dbd73',
                              gas: '0x5208',
                              gasPrice: '0x3b9aca00',
                              hash: '0xa52be92809541220ee0aaaede6047d9a6c5d0cd96a517c854d944ee70a0ebb44',
                              input: '0x',
                              nonce: '0x1',
                              to: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
                              transactionIndex: '0x0',
                              value: '0x4e1003b28d9280000',
                              v: '0xfe7',
                              r: '0x84caf09aefbd5e539295acc67217563438a4efb224879b6855f56857fa2037d3',
                              s: '0x5e863be3829812c81439f0ae9d8ecb832b531d651fb234c848d1bf45e62be8b9',
                            },
                          },
                        },
                      ],
                      tags: [
                        { name: 'Ethereum API', description: 'Ethereum Node JSON-RPC method' },
                        { name: 'Multichain API', description: 'Multichain JSON-RPC method' },
                      ],
                    },
                    {
                      name: 'eth_getTransactionByHash',
                      summary:
                        'Returns the information about a transaction requested by transaction hash.',
                      params: [
                        {
                          name: 'Transaction hash',
                          required: !0,
                          schema: { $ref: '#/components/schemas/hash32' },
                        },
                      ],
                      result: {
                        name: 'Transaction information',
                        schema: {
                          oneOf: [
                            { $ref: '#/components/schemas/notFound' },
                            { $ref: '#/components/schemas/TransactionInfo' },
                          ],
                        },
                      },
                      examples: [
                        {
                          name: 'eth_getTransactionByHash example',
                          params: [
                            {
                              name: 'Transaction hash',
                              value:
                                '0xa52be92809541220ee0aaaede6047d9a6c5d0cd96a517c854d944ee70a0ebb44',
                            },
                          ],
                          result: {
                            name: 'Transaction information',
                            value: {
                              blockHash:
                                '0x510efccf44a192e6e34bcb439a1947e24b86244280762cbb006858c237093fda',
                              blockNumber: '0x422',
                              chainId: 2018,
                              from: '0xfe3b557e8fb62b89f4916b721be55ceb828dbd73',
                              gas: '0x5208',
                              gasPrice: '0x3b9aca00',
                              hash: '0xa52be92809541220ee0aaaede6047d9a6c5d0cd96a517c854d944ee70a0ebb44',
                              input: '0x',
                              nonce: '0x1',
                              to: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
                              transactionIndex: '0x0',
                              value: '0x4e1003b28d9280000',
                              v: '0xfe7',
                              r: '0x84caf09aefbd5e539295acc67217563438a4efb224879b6855f56857fa2037d3',
                              s: '0x5e863be3829812c81439f0ae9d8ecb832b531d651fb234c848d1bf45e62be8b9',
                            },
                          },
                        },
                      ],
                      tags: [
                        { name: 'Ethereum API', description: 'Ethereum Node JSON-RPC method' },
                        { name: 'Multichain API', description: 'Multichain JSON-RPC method' },
                      ],
                    },
                    {
                      name: 'eth_getTransactionCount',
                      summary: 'Returns the number of transactions sent from an address.',
                      params: [
                        {
                          name: 'Address',
                          required: !0,
                          schema: { $ref: '#/components/schemas/address' },
                        },
                        {
                          name: 'Block',
                          required: !0,
                          schema: { $ref: '#/components/schemas/BlockNumberOrTagOrHash' },
                        },
                      ],
                      result: {
                        name: 'Transaction count',
                        schema: { $ref: '#/components/schemas/uint' },
                      },
                      examples: [
                        {
                          name: 'eth_getTransactionCount example',
                          params: [
                            {
                              name: 'Address',
                              value: '0xc94770007dda54cF92009BFF0dE90c06F603a09f',
                            },
                            { name: 'Block', value: 'latest' },
                          ],
                          result: { name: 'Transaction count', value: '0x1' },
                        },
                      ],
                      tags: [
                        { name: 'Ethereum API', description: 'Ethereum Node JSON-RPC method' },
                        { name: 'Multichain API', description: 'Multichain JSON-RPC method' },
                      ],
                    },
                    {
                      name: 'eth_getTransactionReceipt',
                      summary: 'Returns the receipt of a transaction by transaction hash.',
                      params: [
                        {
                          name: 'Transaction hash',
                          required: !0,
                          schema: { $ref: '#/components/schemas/hash32' },
                        },
                      ],
                      result: {
                        name: 'Receipt information',
                        schema: {
                          oneOf: [
                            { $ref: '#/components/schemas/notFound' },
                            { $ref: '#/components/schemas/ReceiptInfo' },
                          ],
                        },
                      },
                      examples: [
                        {
                          name: 'eth_getTransactionReceipt example',
                          params: [
                            {
                              name: 'Transaction hash',
                              value:
                                '0x504ce587a65bdbdb6414a0c6c16d86a04dd79bfcc4f2950eec9634b30ce5370f',
                            },
                          ],
                          result: {
                            name: 'Receipt information',
                            value: {
                              blockHash:
                                '0xe7212a92cfb9b06addc80dec2a0dfae9ea94fd344efeb157c41e12994fcad60a',
                              blockNumber: '0x50',
                              contractAddress: null,
                              cumulativeGasUsed: '0x5208',
                              from: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
                              gasUsed: '0x5208',
                              blobGasUsed: '0x20000',
                              effectiveGasPrice: '0x1',
                              blobGasPrice: '0x3',
                              logs: [],
                              logsBloom:
                                '0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000',
                              status: '0x1',
                              to: '0xf17f52151ebef6c7334fad080c5704d77216b732',
                              transactionHash:
                                '0xc00e97af59c6f88de163306935f7682af1a34c67245e414537d02e422815efc3',
                              transactionIndex: '0x0',
                            },
                          },
                        },
                      ],
                      tags: [
                        { name: 'Ethereum API', description: 'Ethereum Node JSON-RPC method' },
                        { name: 'Multichain API', description: 'Multichain JSON-RPC method' },
                      ],
                    },
                    {
                      name: 'eth_getUncleCountByBlockHash',
                      summary:
                        'Returns the number of uncles in a block from a block matching the given block hash.',
                      params: [
                        { name: 'Block hash', schema: { $ref: '#/components/schemas/hash32' } },
                      ],
                      result: {
                        name: 'Uncle count',
                        schema: {
                          oneOf: [
                            { $ref: '#/components/schemas/notFound' },
                            { title: 'Uncle count', $ref: '#/components/schemas/uint' },
                          ],
                        },
                      },
                      examples: [
                        {
                          name: 'eth_getUncleCountByBlockHash example',
                          params: [
                            {
                              name: 'Block hash',
                              value:
                                '0xb3b20624f8f0f86eb50dd04688409e5cea4bd02d700bf6e79e9384d47d6a5a35',
                            },
                          ],
                          result: { name: 'Uncle count', value: '0x1' },
                        },
                      ],
                      tags: [
                        { name: 'Ethereum API', description: 'Ethereum Node JSON-RPC method' },
                        { name: 'Multichain API', description: 'Multichain JSON-RPC method' },
                      ],
                    },
                    {
                      name: 'eth_getUncleCountByBlockNumber',
                      summary:
                        'Returns the number of transactions in a block matching the given block number.',
                      params: [
                        {
                          name: 'Block',
                          schema: { $ref: '#/components/schemas/BlockNumberOrTag' },
                        },
                      ],
                      result: {
                        name: 'Uncle count',
                        schema: {
                          oneOf: [
                            { $ref: '#/components/schemas/notFound' },
                            { title: 'Uncle count', $ref: '#/components/schemas/uint' },
                          ],
                        },
                      },
                      examples: [
                        {
                          name: 'eth_getUncleCountByBlockNumber example',
                          params: [{ name: 'Block', value: '0xe8' }],
                          result: { name: 'Uncle count', value: '0x1' },
                        },
                      ],
                      tags: [
                        { name: 'Ethereum API', description: 'Ethereum Node JSON-RPC method' },
                        { name: 'Multichain API', description: 'Multichain JSON-RPC method' },
                      ],
                    },
                    {
                      name: 'eth_newBlockFilter',
                      summary: 'Creates a filter in the node, to notify when a new block arrives.',
                      params: [],
                      result: {
                        name: 'Filter identifier',
                        schema: { $ref: '#/components/schemas/uint' },
                      },
                      examples: [
                        {
                          name: 'eth_newBlockFilter example',
                          params: [],
                          result: { name: 'Filter identifier', value: '0x01' },
                        },
                      ],
                      tags: [
                        { name: 'Ethereum API', description: 'Ethereum Node JSON-RPC method' },
                        { name: 'Multichain API', description: 'Multichain JSON-RPC method' },
                      ],
                    },
                    {
                      name: 'eth_newFilter',
                      summary:
                        'Creates a filter object, based on filter options, to notify when the state changes (logs).',
                      params: [{ name: 'Filter', schema: { $ref: '#/components/schemas/Filter' } }],
                      result: {
                        name: 'Filter identifier',
                        schema: { $ref: '#/components/schemas/uint' },
                      },
                      examples: [
                        {
                          name: 'eth_newFilter example',
                          params: [
                            {
                              name: 'Filter',
                              value: {
                                fromBlock: '0x137d3c2',
                                toBlock: '0x137d3c3',
                                address: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
                                topics: [],
                              },
                            },
                          ],
                          result: { name: 'Filter identifier', value: '0x01' },
                        },
                      ],
                      tags: [
                        { name: 'Ethereum API', description: 'Ethereum Node JSON-RPC method' },
                        { name: 'Multichain API', description: 'Multichain JSON-RPC method' },
                      ],
                    },
                    {
                      name: 'eth_newPendingTransactionFilter',
                      summary:
                        'Creates a filter in the node, to notify when new pending transactions arrive.',
                      params: [],
                      result: {
                        name: 'Filter identifier',
                        schema: { $ref: '#/components/schemas/uint' },
                      },
                      examples: [
                        {
                          name: 'eth_newPendingTransactionFilter example',
                          params: [],
                          result: { name: 'Filter identifier', value: '0x01' },
                        },
                      ],
                      tags: [
                        { name: 'Ethereum API', description: 'Ethereum Node JSON-RPC method' },
                        { name: 'Multichain API', description: 'Multichain JSON-RPC method' },
                      ],
                    },
                    {
                      name: 'eth_sendRawTransaction',
                      summary:
                        'Submits a raw transaction. You can create and sign a transaction externally using a library such as [web3.js](https://web3js.readthedocs.io/) or [ethers.js](https://docs.ethers.org/). For [EIP-4844](https://eips.ethereum.org/EIPS/eip-4844) transactions, the raw form must be the network form. This means it includes the blobs, KZG commitments, and KZG proofs.',
                      params: [
                        {
                          name: 'Transaction',
                          required: !0,
                          schema: { $ref: '#/components/schemas/bytes' },
                        },
                      ],
                      result: {
                        name: 'Transaction hash',
                        schema: { $ref: '#/components/schemas/hash32' },
                      },
                      examples: [
                        {
                          name: 'eth_sendRawTransaction example',
                          params: [
                            {
                              name: 'Transaction',
                              value:
                                '0xf869018203e882520894f17f52151ebef6c7334fad080c5704d77216b732881bc16d674ec80000801ba02da1c48b670996dcb1f447ef9ef00b33033c48a4fe938f420bec3e56bfd24071a062e0aa78a81bf0290afbc3a9d8e9a068e6d74caa66c5e0fa8a46deaae96b0833',
                            },
                          ],
                          result: {
                            name: 'Transaction hash',
                            value:
                              '0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331',
                          },
                        },
                      ],
                      tags: [
                        { name: 'Ethereum API', description: 'Ethereum Node JSON-RPC method' },
                        { name: 'Multichain API', description: 'Multichain JSON-RPC method' },
                      ],
                    },
                    {
                      name: 'eth_syncing',
                      summary: 'Returns an object with data about the sync status or false.',
                      params: [],
                      result: {
                        name: 'Syncing status',
                        schema: { $ref: '#/components/schemas/SyncingStatus' },
                      },
                      examples: [
                        {
                          name: 'eth_syncing example',
                          params: [],
                          result: {
                            name: 'Syncing status',
                            value: {
                              startingBlock: '0x0',
                              currentBlock: '0x1518',
                              highestBlock: '0x9567a3',
                            },
                          },
                        },
                      ],
                      tags: [
                        { name: 'Ethereum API', description: 'Ethereum Node JSON-RPC method' },
                        { name: 'Multichain API', description: 'Multichain JSON-RPC method' },
                      ],
                    },
                    {
                      name: 'eth_uninstallFilter',
                      summary: 'Uninstalls a filter with given id.',
                      params: [
                        {
                          name: 'Filter identifier',
                          schema: { $ref: '#/components/schemas/uint' },
                        },
                      ],
                      result: { name: 'Success', schema: { type: 'boolean' } },
                      examples: [
                        {
                          name: 'eth_uninstallFilter example',
                          params: [{ name: 'Filter identifier', value: '0x01' }],
                          result: { name: 'Success', value: !0 },
                        },
                      ],
                      tags: [
                        { name: 'Ethereum API', description: 'Ethereum Node JSON-RPC method' },
                        { name: 'Multichain API', description: 'Multichain JSON-RPC method' },
                      ],
                    },
                  ],
                  components: {
                    errors: { UserRejected: { code: 4001, message: 'User rejected the request.' } },
                    schemas: {
                      TypedData: {
                        title: 'TypedData',
                        type: 'object',
                        required: ['types', 'primaryType', 'domain', 'message'],
                        properties: {
                          types: {
                            type: 'object',
                            required: ['EIP712Domain'],
                            properties: {
                              EIP712Domain: {
                                type: 'array',
                                items: {
                                  type: 'object',
                                  properties: {
                                    name: { type: 'string' },
                                    type: { type: 'string' },
                                  },
                                },
                                description:
                                  'An array specifying one or more of the following domain separator values: 1) `name` - The user-readable name of the signing domain, that is, the name of the dapp or the protocol. 2) `version` - The current major version of the signing domain. 3) `chainId` - The chain ID of the network. 4) `verifyingContract` - The address of the contract that will verify the signature. 5) `salt` - A disambiguating salt for the protocol.',
                              },
                            },
                            additionalProperties: {
                              type: 'array',
                              required: ['name', 'type'],
                              items: {
                                type: 'object',
                                properties: { name: { type: 'string' }, type: { type: 'string' } },
                              },
                            },
                          },
                          domain: {
                            type: 'object',
                            description:
                              'Contains the domain separator values specified in the `EIP712Domain` type.',
                          },
                          primaryType: { type: 'string' },
                          message: {
                            type: 'object',
                            description: "The message you're proposing the user to sign.",
                          },
                        },
                      },
                      AddEthereumChainParameter: {
                        title: 'Chain',
                        description: 'Object containing information about the chain to add.',
                        type: 'object',
                        required: ['chainId', 'chainName', 'nativeCurrency', 'rpcUrls'],
                        properties: {
                          chainId: {
                            description:
                              "The chain ID as a `0x`-prefixed hexadecimal string, per the `eth_chainId` method. MetaMask compares this chain ID value with the `eth_chainId` return value. If these values aren't identical, MetaMask rejects the request.",
                            type: 'string',
                          },
                          blockExplorerUrls: {
                            description:
                              '(Optional) An array of one or more URLs pointing to block explorer sites for the chain.',
                            type: 'array',
                            items: { type: 'string', description: 'Block explorer URL.' },
                          },
                          chainName: {
                            description: 'A human-readable name for the chain.',
                            type: 'string',
                          },
                          iconUrls: {
                            description:
                              '(Optional) An array of one or more URLs pointing to icons that can be used to visually identify the chain. Note: MetaMask will not currently display these icons. You can still include icon URLs so they are used if MetaMask incorporates them into the display of custom networks in the future.',
                            type: 'array',
                            items: { format: 'uri', type: 'string', description: 'Icon URL.' },
                          },
                          nativeCurrency: { $ref: '#/components/schemas/NativeCurrency' },
                          rpcUrls: {
                            description:
                              'An array of one or more URLs pointing to RPC endpoints that can be used to communicate with the chain. At least one item is required, and only the first item is used.',
                            type: 'array',
                            minItems: 1,
                            items: { format: 'uri', type: 'string', description: 'RPC URL.' },
                          },
                        },
                      },
                      NativeCurrency: {
                        title: 'NativeCurrency',
                        type: 'object',
                        description:
                          'An object containing information about the native currency of the chain.',
                        required: ['decimals', 'symbol'],
                        properties: {
                          decimals: {
                            description:
                              'A non-negative integer representing the number of decimals the native currency uses.',
                            minimum: 0,
                            type: 'integer',
                          },
                          name: {
                            description: 'A human-readable name of the native currency.',
                            type: 'string',
                          },
                          symbol: {
                            description: 'A human-readable symbol of the native currency.',
                            type: 'string',
                          },
                        },
                      },
                      Caveats: {
                        title: 'Caveats',
                        description:
                          'An array of caveats that specify restrictions on the permission.',
                        type: 'array',
                        items: {
                          title: 'Caveat',
                          description: 'Object containing information about the caveat.',
                          type: 'object',
                          properties: {
                            type: { title: 'Type', type: 'string', description: 'Type of caveat.' },
                            value: { title: 'CaveatValue', description: 'Value of the caveat.' },
                            name: {
                              title: 'Name',
                              type: 'string',
                              description: 'Name of the caveat.',
                            },
                          },
                        },
                      },
                      Permission: {
                        title: 'Permission',
                        description: 'Object containing information about the permission.',
                        type: 'object',
                        properties: {
                          id: { description: 'The permission ID.', type: 'string' },
                          parentCapability: {
                            description:
                              'The name of the permission being granted. For example, `eth_accounts` or `endowment:permitted-chains`.',
                            type: 'string',
                          },
                          invoker: {
                            description: 'The URI of the dapp being granted this permission.',
                            type: 'string',
                          },
                          caveats: { $ref: '#/components/schemas/Caveats' },
                          date: {
                            description: 'The timestamp of the permission request.',
                            type: 'number',
                          },
                        },
                      },
                      PermissionsList: {
                        title: 'Permissions list',
                        description: "An array of the user's permissions.",
                        type: 'array',
                        items: { $ref: '#/components/schemas/Permission' },
                      },
                      Caip10Address: {
                        title: 'Caip10Address',
                        type: 'string',
                        description:
                          'CAIP-10 defines a way to identify an account/address in any blockchain.',
                      },
                      address: {
                        title: 'hex encoded address',
                        type: 'string',
                        pattern: '^0x[0-9a-fA-F]{40}$',
                      },
                      addresses: {
                        title: 'hex encoded address',
                        type: 'array',
                        items: { $ref: '#/components/schemas/address' },
                      },
                      byte: {
                        title: 'hex encoded byte',
                        type: 'string',
                        pattern: '^0x([0-9a-fA-F]?){1,2}$',
                      },
                      bytes: {
                        title: 'hex encoded bytes',
                        type: 'string',
                        pattern: '^0x[0-9a-f]*$',
                      },
                      bytesMax32: {
                        title: '32 hex encoded bytes',
                        type: 'string',
                        pattern: '^0x[0-9a-f]{0,64}$',
                      },
                      bytes8: {
                        title: '8 hex encoded bytes',
                        type: 'string',
                        pattern: '^0x[0-9a-f]{16}$',
                      },
                      bytes32: {
                        title: '32 hex encoded bytes',
                        type: 'string',
                        pattern: '^0x[0-9a-f]{64}$',
                      },
                      bytes48: {
                        title: '48 hex encoded bytes',
                        type: 'string',
                        pattern: '^0x[0-9a-f]{96}$',
                      },
                      bytes96: {
                        title: '96 hex encoded bytes',
                        type: 'string',
                        pattern: '^0x[0-9a-f]{192}$',
                      },
                      bytes256: {
                        title: '256 hex encoded bytes',
                        type: 'string',
                        pattern: '^0x[0-9a-f]{512}$',
                      },
                      bytes65: {
                        title: '65 hex encoded bytes',
                        type: 'string',
                        pattern: '^0x[0-9a-f]{130}$',
                      },
                      ratio: { title: 'normalized ratio', type: 'number', minimum: 0, maximum: 1 },
                      uint: {
                        title: 'hex encoded unsigned integer',
                        type: 'string',
                        pattern: '^0x([1-9a-f]+[0-9a-f]*|0)$',
                      },
                      uint64: {
                        title: 'hex encoded 64 bit unsigned integer',
                        type: 'string',
                        pattern: '^0x([1-9a-f]+[0-9a-f]{0,15})|0$',
                      },
                      uint256: {
                        title: 'hex encoded 256 bit unsigned integer',
                        type: 'string',
                        pattern: '^0x([1-9a-f]+[0-9a-f]{0,31})|0$',
                      },
                      hash32: {
                        title: '32 byte hex value',
                        type: 'string',
                        pattern: '^0x[0-9a-f]{64}$',
                      },
                      notFound: { title: 'Not Found (null)', type: 'null' },
                      Block: {
                        title: 'Block object',
                        type: 'object',
                        required: [
                          'hash',
                          'parentHash',
                          'sha3Uncles',
                          'miner',
                          'stateRoot',
                          'transactionsRoot',
                          'receiptsRoot',
                          'logsBloom',
                          'number',
                          'gasLimit',
                          'gasUsed',
                          'timestamp',
                          'extraData',
                          'mixHash',
                          'nonce',
                          'size',
                          'transactions',
                          'uncles',
                        ],
                        additionalProperties: !1,
                        properties: {
                          hash: { title: 'Hash', $ref: '#/components/schemas/hash32' },
                          parentHash: {
                            title: 'Parent block hash',
                            $ref: '#/components/schemas/hash32',
                          },
                          sha3Uncles: { title: 'Ommers hash', $ref: '#/components/schemas/hash32' },
                          miner: { title: 'Coinbase', $ref: '#/components/schemas/address' },
                          stateRoot: { title: 'State root', $ref: '#/components/schemas/hash32' },
                          transactionsRoot: {
                            title: 'Transactions root',
                            $ref: '#/components/schemas/hash32',
                          },
                          receiptsRoot: {
                            title: 'Receipts root',
                            $ref: '#/components/schemas/hash32',
                          },
                          logsBloom: {
                            title: 'Bloom filter',
                            $ref: '#/components/schemas/bytes256',
                          },
                          difficulty: { title: 'Difficulty', $ref: '#/components/schemas/uint' },
                          number: { title: 'Number', $ref: '#/components/schemas/uint' },
                          gasLimit: { title: 'Gas limit', $ref: '#/components/schemas/uint' },
                          gasUsed: { title: 'Gas used', $ref: '#/components/schemas/uint' },
                          timestamp: { title: 'Timestamp', $ref: '#/components/schemas/uint' },
                          extraData: { title: 'Extra data', $ref: '#/components/schemas/bytes' },
                          mixHash: { title: 'Mix hash', $ref: '#/components/schemas/hash32' },
                          nonce: { title: 'Nonce', $ref: '#/components/schemas/bytes8' },
                          baseFeePerGas: {
                            title: 'Base fee per gas',
                            $ref: '#/components/schemas/uint',
                          },
                          withdrawalsRoot: {
                            title: 'Withdrawals root',
                            $ref: '#/components/schemas/hash32',
                          },
                          blobGasUsed: {
                            title: 'Blob gas used',
                            $ref: '#/components/schemas/uint',
                          },
                          excessBlobGas: {
                            title: 'Excess blob gas',
                            $ref: '#/components/schemas/uint',
                          },
                          parentBeaconBlockRoot: {
                            title: 'Parent Beacon Block Root',
                            $ref: '#/components/schemas/hash32',
                          },
                          size: { title: 'Block size', $ref: '#/components/schemas/uint' },
                          transactions: {
                            anyOf: [
                              {
                                title: 'Transaction hashes',
                                type: 'array',
                                items: { $ref: '#/components/schemas/hash32' },
                              },
                              {
                                title: 'Full transactions',
                                type: 'array',
                                items: { $ref: '#/components/schemas/TransactionInfo' },
                              },
                            ],
                          },
                          withdrawals: {
                            title: 'Withdrawals',
                            type: 'array',
                            items: { $ref: '#/components/schemas/Withdrawal' },
                          },
                          uncles: {
                            title: 'Uncles',
                            type: 'array',
                            items: { $ref: '#/components/schemas/hash32' },
                          },
                        },
                      },
                      BlockTag: {
                        title: 'Block tag',
                        type: 'string',
                        enum: ['earliest', 'finalized', 'safe', 'latest', 'pending'],
                        description:
                          '`earliest`: The lowest numbered block the client has available; `finalized`: The most recent crypto-economically secure block, cannot be re-orged outside of manual intervention driven by community coordination; `safe`: The most recent block that is safe from re-orgs under honest majority and certain synchronicity assumptions; `latest`: The most recent block in the canonical chain observed by the client, this block may be re-orged out of the canonical chain even under healthy/normal conditions; `pending`: A sample next block built by the client on top of `latest` and containing the set of transactions usually taken from local mempool. Before the merge transition is finalized, any call querying for `finalized` or `safe` block MUST be responded to with `-39001: Unknown block` error',
                      },
                      BlockNumberOrTag: {
                        title: 'Block number or tag',
                        oneOf: [
                          { title: 'Block number', $ref: '#/components/schemas/uint' },
                          { title: 'Block tag', $ref: '#/components/schemas/BlockTag' },
                        ],
                      },
                      BlockNumberOrTagOrHash: {
                        title: 'Block number, tag, or block hash',
                        anyOf: [
                          { title: 'Block number', $ref: '#/components/schemas/uint' },
                          { title: 'Block tag', $ref: '#/components/schemas/BlockTag' },
                          { title: 'Block hash', $ref: '#/components/schemas/hash32' },
                        ],
                      },
                      BadBlock: {
                        title: 'Bad block',
                        type: 'object',
                        required: ['block', 'hash', 'rlp'],
                        additionalProperties: !1,
                        properties: {
                          block: { title: 'Block', $ref: '#/components/schemas/Block' },
                          hash: { title: 'Hash', $ref: '#/components/schemas/hash32' },
                          rlp: { title: 'RLP', $ref: '#/components/schemas/bytes' },
                        },
                      },
                      SyncingStatus: {
                        title: 'Syncing status',
                        oneOf: [
                          {
                            title: 'Syncing progress',
                            type: 'object',
                            additionalProperties: !1,
                            properties: {
                              startingBlock: {
                                title: 'Starting block',
                                $ref: '#/components/schemas/uint',
                              },
                              currentBlock: {
                                title: 'Current block',
                                $ref: '#/components/schemas/uint',
                              },
                              highestBlock: {
                                title: 'Highest block',
                                $ref: '#/components/schemas/uint',
                              },
                            },
                          },
                          {
                            title: 'Not syncing',
                            description: 'Should always return false if not syncing.',
                            type: 'boolean',
                          },
                        ],
                      },
                      FilterResults: {
                        title: 'Filter results',
                        oneOf: [
                          {
                            title: 'new block or transaction hashes',
                            type: 'array',
                            items: { $ref: '#/components/schemas/hash32' },
                          },
                          {
                            title: 'new logs',
                            type: 'array',
                            items: { $ref: '#/components/schemas/Log' },
                          },
                        ],
                      },
                      Filter: {
                        title: 'filter',
                        type: 'object',
                        additionalProperties: !1,
                        properties: {
                          fromBlock: { title: 'from block', $ref: '#/components/schemas/uint' },
                          toBlock: { title: 'to block', $ref: '#/components/schemas/uint' },
                          address: {
                            title: 'Address(es)',
                            oneOf: [
                              { title: 'Any Address', type: 'null' },
                              { title: 'Address', $ref: '#/components/schemas/address' },
                              { title: 'Addresses', $ref: '#/components/schemas/addresses' },
                            ],
                          },
                          topics: { title: 'Topics', $ref: '#/components/schemas/FilterTopics' },
                        },
                      },
                      FilterTopics: {
                        title: 'Filter Topics',
                        oneOf: [
                          { title: 'Any Topic Match', type: 'null' },
                          {
                            title: 'Specified Filter Topics',
                            type: 'array',
                            items: { $ref: '#/components/schemas/FilterTopic' },
                          },
                        ],
                      },
                      FilterTopic: {
                        title: 'Filter Topic List Entry',
                        oneOf: [
                          { title: 'Single Topic Match', $ref: '#/components/schemas/bytes32' },
                          {
                            title: 'Multiple Topic Match',
                            type: 'array',
                            items: { $ref: '#/components/schemas/bytes32' },
                          },
                        ],
                      },
                      Log: {
                        title: 'log',
                        type: 'object',
                        required: ['transactionHash'],
                        additionalProperties: !1,
                        properties: {
                          removed: { title: 'removed', type: 'boolean' },
                          logIndex: { title: 'log index', $ref: '#/components/schemas/uint' },
                          transactionIndex: {
                            title: 'transaction index',
                            $ref: '#/components/schemas/uint',
                          },
                          transactionHash: {
                            title: 'transaction hash',
                            $ref: '#/components/schemas/hash32',
                          },
                          blockHash: { title: 'block hash', $ref: '#/components/schemas/hash32' },
                          blockNumber: { title: 'block number', $ref: '#/components/schemas/uint' },
                          address: { title: 'address', $ref: '#/components/schemas/address' },
                          data: { title: 'data', $ref: '#/components/schemas/bytes' },
                          topics: {
                            title: 'topics',
                            type: 'array',
                            items: { $ref: '#/components/schemas/bytes32' },
                          },
                        },
                      },
                      ReceiptInfo: {
                        type: 'object',
                        title: 'Receipt information',
                        required: [
                          'blockHash',
                          'blockNumber',
                          'from',
                          'cumulativeGasUsed',
                          'gasUsed',
                          'logs',
                          'logsBloom',
                          'transactionHash',
                          'transactionIndex',
                          'effectiveGasPrice',
                        ],
                        additionalProperties: !1,
                        properties: {
                          type: { title: 'type', $ref: '#/components/schemas/byte' },
                          transactionHash: {
                            title: 'transaction hash',
                            $ref: '#/components/schemas/hash32',
                          },
                          transactionIndex: {
                            title: 'transaction index',
                            $ref: '#/components/schemas/uint',
                          },
                          blockHash: { title: 'block hash', $ref: '#/components/schemas/hash32' },
                          blockNumber: { title: 'block number', $ref: '#/components/schemas/uint' },
                          from: { title: 'from', $ref: '#/components/schemas/address' },
                          to: {
                            title: 'to',
                            description:
                              'Address of the receiver or null in a contract creation transaction.',
                            oneOf: [
                              { title: 'Contract Creation (null)', type: 'null' },
                              { title: 'Recipient Address', $ref: '#/components/schemas/address' },
                            ],
                          },
                          cumulativeGasUsed: {
                            title: 'cumulative gas used',
                            description:
                              'The sum of gas used by this transaction and all preceding transactions in the same block.',
                            $ref: '#/components/schemas/uint',
                          },
                          gasUsed: {
                            title: 'gas used',
                            description:
                              'The amount of gas used for this specific transaction alone.',
                            $ref: '#/components/schemas/uint',
                          },
                          blobGasUsed: {
                            title: 'blob gas used',
                            description:
                              'The amount of blob gas used for this specific transaction. Only specified for blob transactions as defined by EIP-4844.',
                            $ref: '#/components/schemas/uint',
                          },
                          contractAddress: {
                            title: 'contract address',
                            description:
                              'The contract address created, if the transaction was a contract creation, otherwise null.',
                            oneOf: [
                              { $ref: '#/components/schemas/address' },
                              { title: 'Null', type: 'null' },
                            ],
                          },
                          logs: {
                            title: 'logs',
                            type: 'array',
                            items: { $ref: '#/components/schemas/Log' },
                          },
                          logsBloom: { title: 'logs bloom', $ref: '#/components/schemas/bytes256' },
                          root: {
                            title: 'state root',
                            description:
                              'The post-transaction state root. Only specified for transactions included before the Byzantium upgrade.',
                            $ref: '#/components/schemas/hash32',
                          },
                          status: {
                            title: 'status',
                            description:
                              'Either 1 (success) or 0 (failure). Only specified for transactions included after the Byzantium upgrade.',
                            $ref: '#/components/schemas/uint',
                          },
                          effectiveGasPrice: {
                            title: 'effective gas price',
                            description:
                              "The actual value per gas deducted from the sender's account. Before EIP-1559, this is equal to the transaction's gas price. After, it is equal to baseFeePerGas + min(maxFeePerGas - baseFeePerGas, maxPriorityFeePerGas).",
                            $ref: '#/components/schemas/uint',
                          },
                          blobGasPrice: {
                            title: 'blob gas price',
                            description:
                              "The actual value per gas deducted from the sender's account for blob gas. Only specified for blob transactions as defined by EIP-4844.",
                            $ref: '#/components/schemas/uint',
                          },
                        },
                      },
                      AccountProof: {
                        title: 'Account proof',
                        type: 'object',
                        required: [
                          'address',
                          'accountProof',
                          'balance',
                          'codeHash',
                          'nonce',
                          'storageHash',
                          'storageProof',
                        ],
                        additionalProperties: !1,
                        properties: {
                          address: { title: 'address', $ref: '#/components/schemas/address' },
                          accountProof: {
                            title: 'accountProof',
                            type: 'array',
                            items: { $ref: '#/components/schemas/bytes' },
                          },
                          balance: { title: 'balance', $ref: '#/components/schemas/uint256' },
                          codeHash: { title: 'codeHash', $ref: '#/components/schemas/hash32' },
                          nonce: { title: 'nonce', $ref: '#/components/schemas/uint64' },
                          storageHash: {
                            title: 'storageHash',
                            $ref: '#/components/schemas/hash32',
                          },
                          storageProof: {
                            title: 'Storage proofs',
                            type: 'array',
                            items: { $ref: '#/components/schemas/StorageProof' },
                          },
                        },
                      },
                      StorageProof: {
                        title: 'Storage proof',
                        type: 'object',
                        required: ['key', 'value', 'proof'],
                        additionalProperties: !1,
                        properties: {
                          key: { title: 'key', $ref: '#/components/schemas/bytesMax32' },
                          value: { title: 'value', $ref: '#/components/schemas/uint256' },
                          proof: {
                            title: 'proof',
                            type: 'array',
                            items: { $ref: '#/components/schemas/bytes' },
                          },
                        },
                      },
                      Transaction4844Unsigned: {
                        type: 'object',
                        title: 'EIP-4844 transaction.',
                        required: [
                          'type',
                          'nonce',
                          'to',
                          'gas',
                          'value',
                          'input',
                          'maxPriorityFeePerGas',
                          'maxFeePerGas',
                          'maxFeePerBlobGas',
                          'accessList',
                          'blobVersionedHashes',
                          'chainId',
                        ],
                        properties: {
                          type: { title: 'type', $ref: '#/components/schemas/byte' },
                          nonce: { title: 'nonce', $ref: '#/components/schemas/uint' },
                          to: { title: 'to address', $ref: '#/components/schemas/address' },
                          gas: { title: 'gas limit', $ref: '#/components/schemas/uint' },
                          value: { title: 'value', $ref: '#/components/schemas/uint' },
                          input: { title: 'input data', $ref: '#/components/schemas/bytes' },
                          maxPriorityFeePerGas: {
                            title: 'max priority fee per gas',
                            description:
                              'Maximum fee per gas the sender is willing to pay to miners in wei',
                            $ref: '#/components/schemas/uint',
                          },
                          maxFeePerGas: {
                            title: 'max fee per gas',
                            description:
                              'The maximum total fee per gas the sender is willing to pay (includes the network / base fee and miner / priority fee) in wei',
                            $ref: '#/components/schemas/uint',
                          },
                          maxFeePerBlobGas: {
                            title: 'max fee per blob gas',
                            description:
                              'The maximum total fee per gas the sender is willing to pay for blob gas in wei',
                            $ref: '#/components/schemas/uint',
                          },
                          accessList: {
                            title: 'accessList',
                            description: 'EIP-2930 access list',
                            $ref: '#/components/schemas/AccessList',
                          },
                          blobVersionedHashes: {
                            title: 'blobVersionedHashes',
                            description:
                              "List of versioned blob hashes associated with the transaction's EIP-4844 data blobs.",
                            type: 'array',
                            items: { $ref: '#/components/schemas/hash32' },
                          },
                          chainId: {
                            title: 'chainId',
                            description: 'Chain ID that this transaction is valid on.',
                            $ref: '#/components/schemas/uint',
                          },
                        },
                      },
                      AccessListEntry: {
                        title: 'Access list entry',
                        type: 'object',
                        additionalProperties: !1,
                        properties: {
                          address: { $ref: '#/components/schemas/address' },
                          storageKeys: {
                            type: 'array',
                            items: { $ref: '#/components/schemas/hash32' },
                          },
                        },
                      },
                      AccessList: {
                        title: 'Access list',
                        type: 'array',
                        items: { $ref: '#/components/schemas/AccessListEntry' },
                      },
                      Transaction1559Unsigned: {
                        type: 'object',
                        title: 'EIP-1559 transaction.',
                        required: [
                          'type',
                          'nonce',
                          'gas',
                          'value',
                          'input',
                          'maxFeePerGas',
                          'maxPriorityFeePerGas',
                          'gasPrice',
                          'chainId',
                          'accessList',
                        ],
                        properties: {
                          type: { title: 'type', type: 'string', pattern: '^0x2$' },
                          nonce: { title: 'nonce', $ref: '#/components/schemas/uint' },
                          to: {
                            title: 'to address',
                            oneOf: [
                              { title: 'Contract Creation (null)', type: 'null' },
                              { title: 'Address', $ref: '#/components/schemas/address' },
                            ],
                          },
                          gas: { title: 'gas limit', $ref: '#/components/schemas/uint' },
                          value: { title: 'value', $ref: '#/components/schemas/uint' },
                          input: { title: 'input data', $ref: '#/components/schemas/bytes' },
                          maxPriorityFeePerGas: {
                            title: 'max priority fee per gas',
                            description:
                              'Maximum fee per gas the sender is willing to pay to miners in wei',
                            $ref: '#/components/schemas/uint',
                          },
                          maxFeePerGas: {
                            title: 'max fee per gas',
                            description:
                              'The maximum total fee per gas the sender is willing to pay (includes the network / base fee and miner / priority fee) in wei',
                            $ref: '#/components/schemas/uint',
                          },
                          gasPrice: {
                            title: 'gas price',
                            description:
                              'The effective gas price paid by the sender in wei. For transactions not yet included in a block, this value should be set equal to the max fee per gas. This field is DEPRECATED, please transition to using effectiveGasPrice in the receipt object going forward.',
                            $ref: '#/components/schemas/uint',
                          },
                          accessList: {
                            title: 'accessList',
                            description: 'EIP-2930 access list',
                            $ref: '#/components/schemas/AccessList',
                          },
                          chainId: {
                            title: 'chainId',
                            description: 'Chain ID that this transaction is valid on.',
                            $ref: '#/components/schemas/uint',
                          },
                        },
                      },
                      Transaction2930Unsigned: {
                        type: 'object',
                        title: 'EIP-2930 transaction.',
                        required: [
                          'type',
                          'nonce',
                          'gas',
                          'value',
                          'input',
                          'gasPrice',
                          'chainId',
                          'accessList',
                        ],
                        properties: {
                          type: { title: 'type', type: 'string', pattern: '^0x1$' },
                          nonce: { title: 'nonce', $ref: '#/components/schemas/uint' },
                          to: {
                            title: 'to address',
                            oneOf: [
                              { title: 'Contract Creation (null)', type: 'null' },
                              { title: 'Address', $ref: '#/components/schemas/address' },
                            ],
                          },
                          gas: { title: 'gas limit', $ref: '#/components/schemas/uint' },
                          value: { title: 'value', $ref: '#/components/schemas/uint' },
                          input: { title: 'input data', $ref: '#/components/schemas/bytes' },
                          gasPrice: {
                            title: 'gas price',
                            description: 'The gas price willing to be paid by the sender in wei',
                            $ref: '#/components/schemas/uint',
                          },
                          accessList: {
                            title: 'accessList',
                            description: 'EIP-2930 access list',
                            $ref: '#/components/schemas/AccessList',
                          },
                          chainId: {
                            title: 'chainId',
                            description: 'Chain ID that this transaction is valid on.',
                            $ref: '#/components/schemas/uint',
                          },
                        },
                      },
                      TransactionLegacyUnsigned: {
                        type: 'object',
                        title: 'Legacy transaction.',
                        required: ['type', 'nonce', 'gas', 'value', 'input', 'gasPrice'],
                        properties: {
                          type: { title: 'type', type: 'string', pattern: '^0x0$' },
                          nonce: { title: 'nonce', $ref: '#/components/schemas/uint' },
                          to: {
                            title: 'to address',
                            oneOf: [
                              { title: 'Contract Creation (null)', type: 'null' },
                              { title: 'Address', $ref: '#/components/schemas/address' },
                            ],
                          },
                          gas: { title: 'gas limit', $ref: '#/components/schemas/uint' },
                          value: { title: 'value', $ref: '#/components/schemas/uint' },
                          input: { title: 'input data', $ref: '#/components/schemas/bytes' },
                          gasPrice: {
                            title: 'gas price',
                            description: 'The gas price willing to be paid by the sender in wei',
                            $ref: '#/components/schemas/uint',
                          },
                          chainId: {
                            title: 'chainId',
                            description: 'Chain ID that this transaction is valid on.',
                            $ref: '#/components/schemas/uint',
                          },
                        },
                      },
                      TransactionUnsigned: {
                        oneOf: [
                          { $ref: '#/components/schemas/Transaction4844Unsigned' },
                          { $ref: '#/components/schemas/Transaction1559Unsigned' },
                          { $ref: '#/components/schemas/Transaction2930Unsigned' },
                          { $ref: '#/components/schemas/TransactionLegacyUnsigned' },
                        ],
                      },
                      Transaction4844Signed: {
                        title: 'Signed 4844 Transaction',
                        type: 'object',
                        allOf: [
                          { $ref: '#/components/schemas/Transaction4844Unsigned' },
                          {
                            title: 'EIP-4844 transaction signature properties.',
                            required: ['yParity', 'r', 's'],
                            properties: {
                              yParity: {
                                title: 'yParity',
                                description:
                                  'The parity (0 for even, 1 for odd) of the y-value of the secp256k1 signature.',
                                $ref: '#/components/schemas/uint',
                              },
                              r: { title: 'r', $ref: '#/components/schemas/uint' },
                              s: { title: 's', $ref: '#/components/schemas/uint' },
                            },
                          },
                        ],
                      },
                      Transaction1559Signed: {
                        title: 'Signed 1559 Transaction',
                        type: 'object',
                        allOf: [
                          { $ref: '#/components/schemas/Transaction1559Unsigned' },
                          {
                            title: 'EIP-1559 transaction signature properties.',
                            required: ['yParity', 'r', 's'],
                            properties: {
                              yParity: {
                                title: 'yParity',
                                description:
                                  'The parity (0 for even, 1 for odd) of the y-value of the secp256k1 signature.',
                                $ref: '#/components/schemas/uint',
                              },
                              v: {
                                title: 'v',
                                description:
                                  'For backwards compatibility, `v` is optionally provided as an alternative to `yParity`. This field is DEPRECATED and all use of it should migrate to `yParity`.',
                                $ref: '#/components/schemas/uint',
                              },
                              r: { title: 'r', $ref: '#/components/schemas/uint' },
                              s: { title: 's', $ref: '#/components/schemas/uint' },
                            },
                          },
                        ],
                      },
                      Transaction2930Signed: {
                        title: 'Signed 2930 Transaction',
                        type: 'object',
                        allOf: [
                          { $ref: '#/components/schemas/Transaction2930Unsigned' },
                          {
                            title: 'EIP-2930 transaction signature properties.',
                            required: ['yParity', 'r', 's'],
                            properties: {
                              yParity: {
                                title: 'yParity',
                                description:
                                  'The parity (0 for even, 1 for odd) of the y-value of the secp256k1 signature.',
                                $ref: '#/components/schemas/uint',
                              },
                              v: {
                                title: 'v',
                                description:
                                  'For backwards compatibility, `v` is optionally provided as an alternative to `yParity`. This field is DEPRECATED and all use of it should migrate to `yParity`.',
                                $ref: '#/components/schemas/uint',
                              },
                              r: { title: 'r', $ref: '#/components/schemas/uint' },
                              s: { title: 's', $ref: '#/components/schemas/uint' },
                            },
                          },
                        ],
                      },
                      TransactionLegacySigned: {
                        title: 'Signed Legacy Transaction',
                        type: 'object',
                        allOf: [
                          { $ref: '#/components/schemas/TransactionLegacyUnsigned' },
                          {
                            title: 'Legacy transaction signature properties.',
                            required: ['v', 'r', 's'],
                            properties: {
                              v: { title: 'v', $ref: '#/components/schemas/uint' },
                              r: { title: 'r', $ref: '#/components/schemas/uint' },
                              s: { title: 's', $ref: '#/components/schemas/uint' },
                            },
                          },
                        ],
                      },
                      TransactionSigned: {
                        oneOf: [
                          { $ref: '#/components/schemas/Transaction4844Signed' },
                          { $ref: '#/components/schemas/Transaction1559Signed' },
                          { $ref: '#/components/schemas/Transaction2930Signed' },
                          { $ref: '#/components/schemas/TransactionLegacySigned' },
                        ],
                      },
                      TransactionInfo: {
                        type: 'object',
                        title: 'Transaction information',
                        allOf: [
                          {
                            title: 'Contextual information',
                            required: [
                              'blockHash',
                              'blockNumber',
                              'from',
                              'hash',
                              'transactionIndex',
                            ],
                            unevaluatedProperties: !1,
                            properties: {
                              blockHash: {
                                title: 'block hash',
                                $ref: '#/components/schemas/hash32',
                              },
                              blockNumber: {
                                title: 'block number',
                                $ref: '#/components/schemas/uint',
                              },
                              from: { title: 'from address', $ref: '#/components/schemas/address' },
                              hash: {
                                title: 'transaction hash',
                                $ref: '#/components/schemas/hash32',
                              },
                              transactionIndex: {
                                title: 'transaction index',
                                $ref: '#/components/schemas/uint',
                              },
                            },
                          },
                          { $ref: '#/components/schemas/TransactionSigned' },
                        ],
                      },
                      GenericTransaction: {
                        type: 'object',
                        title: 'Transaction object generic to all types',
                        additionalProperties: !1,
                        properties: {
                          type: { title: 'type', $ref: '#/components/schemas/byte' },
                          nonce: { title: 'nonce', $ref: '#/components/schemas/uint' },
                          to: {
                            title: 'to address',
                            oneOf: [
                              { title: 'Contract Creation (null)', type: 'null' },
                              { title: 'Address', $ref: '#/components/schemas/address' },
                            ],
                          },
                          from: { title: 'from address', $ref: '#/components/schemas/address' },
                          gas: { title: 'gas limit', $ref: '#/components/schemas/uint' },
                          value: { title: 'value', $ref: '#/components/schemas/uint' },
                          input: { title: 'input data', $ref: '#/components/schemas/bytes' },
                          gasPrice: {
                            title: 'gas price',
                            description: 'The gas price willing to be paid by the sender in wei',
                            $ref: '#/components/schemas/uint',
                          },
                          maxPriorityFeePerGas: {
                            title: 'max priority fee per gas',
                            description:
                              'Maximum fee per gas the sender is willing to pay to miners in wei',
                            $ref: '#/components/schemas/uint',
                          },
                          maxFeePerGas: {
                            title: 'max fee per gas',
                            description:
                              'The maximum total fee per gas the sender is willing to pay (includes the network / base fee and miner / priority fee) in wei',
                            $ref: '#/components/schemas/uint',
                          },
                          maxFeePerBlobGas: {
                            title: 'max fee per blob gas',
                            description:
                              'The maximum total fee per gas the sender is willing to pay for blob gas in wei',
                            $ref: '#/components/schemas/uint',
                          },
                          accessList: {
                            title: 'accessList',
                            description: 'EIP-2930 access list',
                            $ref: '#/components/schemas/AccessList',
                          },
                          blobVersionedHashes: {
                            title: 'blobVersionedHashes',
                            description:
                              "List of versioned blob hashes associated with the transaction's EIP-4844 data blobs.",
                            type: 'array',
                            items: { $ref: '#/components/schemas/hash32' },
                          },
                          blobs: {
                            title: 'blobs',
                            description: 'Raw blob data.',
                            type: 'array',
                            items: { $ref: '#/components/schemas/bytes' },
                          },
                          chainId: {
                            title: 'chainId',
                            description: 'Chain ID that this transaction is valid on.',
                            $ref: '#/components/schemas/uint',
                          },
                        },
                      },
                      Withdrawal: {
                        type: 'object',
                        title: 'Validator withdrawal',
                        required: ['index', 'validatorIndex', 'address', 'amount'],
                        additionalProperties: !1,
                        properties: {
                          index: {
                            title: 'index of withdrawal',
                            $ref: '#/components/schemas/uint64',
                          },
                          validatorIndex: {
                            title: 'index of validator that generated withdrawal',
                            $ref: '#/components/schemas/uint64',
                          },
                          address: {
                            title: 'recipient address for withdrawal value',
                            $ref: '#/components/schemas/address',
                          },
                          amount: {
                            title: 'value contained in withdrawal',
                            $ref: '#/components/schemas/uint256',
                          },
                        },
                      },
                      ForkchoiceStateV1: {
                        title: 'Forkchoice state object V1',
                        type: 'object',
                        required: ['headBlockHash', 'safeBlockHash', 'finalizedBlockHash'],
                        properties: {
                          headBlockHash: {
                            title: 'Head block hash',
                            $ref: '#/components/schemas/hash32',
                          },
                          safeBlockHash: {
                            title: 'Safe block hash',
                            $ref: '#/components/schemas/hash32',
                          },
                          finalizedBlockHash: {
                            title: 'Finalized block hash',
                            $ref: '#/components/schemas/hash32',
                          },
                        },
                      },
                      ForkchoiceUpdatedResponseV1: {
                        title: 'Forkchoice updated response',
                        type: 'object',
                        required: ['payloadStatus'],
                        properties: {
                          payloadStatus: {
                            title: 'Payload status',
                            $ref: '#/components/schemas/RestrictedPayloadStatusV1',
                          },
                          payloadId: { title: 'Payload id', $ref: '#/components/schemas/bytes8' },
                        },
                      },
                      PayloadAttributesV1: {
                        title: 'Payload attributes object V1',
                        type: 'object',
                        required: ['timestamp', 'prevRandao', 'suggestedFeeRecipient'],
                        properties: {
                          timestamp: { title: 'Timestamp', $ref: '#/components/schemas/uint64' },
                          prevRandao: {
                            title: 'Previous randao value',
                            $ref: '#/components/schemas/bytes32',
                          },
                          suggestedFeeRecipient: {
                            title: 'Suggested fee recipient',
                            $ref: '#/components/schemas/address',
                          },
                        },
                      },
                      PayloadAttributesV2: {
                        title: 'Payload attributes object V2',
                        type: 'object',
                        required: [
                          'timestamp',
                          'prevRandao',
                          'suggestedFeeRecipient',
                          'withdrawals',
                        ],
                        properties: {
                          timestamp: {
                            $ref: '#/components/schemas/PayloadAttributesV1/properties/timestamp',
                          },
                          prevRandao: {
                            $ref: '#/components/schemas/PayloadAttributesV1/properties/prevRandao',
                          },
                          suggestedFeeRecipient: {
                            $ref: '#/components/schemas/PayloadAttributesV1/properties/suggestedFeeRecipient',
                          },
                          withdrawals: {
                            title: 'Withdrawals',
                            type: 'array',
                            items: { $ref: '#/components/schemas/WithdrawalV1' },
                          },
                        },
                      },
                      PayloadAttributesV3: {
                        title: 'Payload attributes object V3',
                        type: 'object',
                        required: [
                          'timestamp',
                          'prevRandao',
                          'suggestedFeeRecipient',
                          'withdrawals',
                          'parentBeaconBlockRoot',
                        ],
                        properties: {
                          timestamp: {
                            $ref: '#/components/schemas/PayloadAttributesV2/properties/timestamp',
                          },
                          prevRandao: {
                            $ref: '#/components/schemas/PayloadAttributesV2/properties/prevRandao',
                          },
                          suggestedFeeRecipient: {
                            $ref: '#/components/schemas/PayloadAttributesV2/properties/suggestedFeeRecipient',
                          },
                          withdrawals: {
                            $ref: '#/components/schemas/PayloadAttributesV2/properties/withdrawals',
                          },
                          parentBeaconBlockRoot: {
                            title: 'Parent beacon block root',
                            $ref: '#/components/schemas/hash32',
                          },
                        },
                      },
                      PayloadStatusV1: {
                        title: 'Payload status object V1',
                        type: 'object',
                        required: ['status'],
                        properties: {
                          status: {
                            title: 'Payload validation status',
                            type: 'string',
                            enum: ['VALID', 'INVALID', 'SYNCING', 'ACCEPTED', 'INVALID_BLOCK_HASH'],
                          },
                          latestValidHash: {
                            title: 'The hash of the most recent valid block',
                            $ref: '#/components/schemas/hash32',
                          },
                          validationError: { title: 'Validation error message', type: 'string' },
                        },
                      },
                      RestrictedPayloadStatusV1: {
                        $ref: '#/components/schemas/PayloadStatusV1',
                        properties: {
                          status: {
                            $ref: '#/components/schemas/PayloadStatusV1/properties/status',
                            description:
                              'Set of possible values is restricted to VALID, INVALID, SYNCING',
                            enum: ['VALID', 'INVALID', 'SYNCING'],
                          },
                          latestValidHash: {
                            $ref: '#/components/schemas/PayloadStatusV1/properties/latestValidHash',
                          },
                          validationError: {
                            $ref: '#/components/schemas/PayloadStatusV1/properties/validationError',
                          },
                        },
                      },
                      PayloadStatusNoInvalidBlockHash: {
                        $ref: '#/components/schemas/PayloadStatusV1',
                        title: 'Payload status object deprecating INVALID_BLOCK_HASH status',
                        properties: {
                          status: {
                            $ref: '#/components/schemas/PayloadStatusV1/properties/status',
                            enum: ['VALID', 'INVALID', 'SYNCING', 'ACCEPTED'],
                          },
                          latestValidHash: {
                            $ref: '#/components/schemas/PayloadStatusV1/properties/latestValidHash',
                          },
                          validationError: {
                            $ref: '#/components/schemas/PayloadStatusV1/properties/validationError',
                          },
                        },
                      },
                      ExecutionPayloadV1: {
                        title: 'Execution payload object V1',
                        type: 'object',
                        required: [
                          'parentHash',
                          'feeRecipient',
                          'stateRoot',
                          'receiptsRoot',
                          'logsBloom',
                          'prevRandao',
                          'blockNumber',
                          'gasLimit',
                          'gasUsed',
                          'timestamp',
                          'extraData',
                          'baseFeePerGas',
                          'blockHash',
                          'transactions',
                        ],
                        properties: {
                          parentHash: {
                            title: 'Parent block hash',
                            $ref: '#/components/schemas/hash32',
                          },
                          feeRecipient: {
                            title: 'Recipient of transaction priority fees',
                            $ref: '#/components/schemas/address',
                          },
                          stateRoot: { title: 'State root', $ref: '#/components/schemas/hash32' },
                          receiptsRoot: {
                            title: 'Receipts root',
                            $ref: '#/components/schemas/hash32',
                          },
                          logsBloom: {
                            title: 'Bloom filter',
                            $ref: '#/components/schemas/bytes256',
                          },
                          prevRandao: {
                            title: 'Previous randao value',
                            $ref: '#/components/schemas/bytes32',
                          },
                          blockNumber: {
                            title: 'Block number',
                            $ref: '#/components/schemas/uint64',
                          },
                          gasLimit: { title: 'Gas limit', $ref: '#/components/schemas/uint64' },
                          gasUsed: { title: 'Gas used', $ref: '#/components/schemas/uint64' },
                          timestamp: { title: 'Timestamp', $ref: '#/components/schemas/uint64' },
                          extraData: {
                            title: 'Extra data',
                            $ref: '#/components/schemas/bytesMax32',
                          },
                          baseFeePerGas: {
                            title: 'Base fee per gas',
                            $ref: '#/components/schemas/uint256',
                          },
                          blockHash: { title: 'Block hash', $ref: '#/components/schemas/hash32' },
                          transactions: {
                            title: 'Transactions',
                            type: 'array',
                            items: { $ref: '#/components/schemas/bytes' },
                          },
                        },
                      },
                      WithdrawalV1: {
                        title: 'Withdrawal object V1',
                        type: 'object',
                        required: ['index', 'validatorIndex', 'address', 'amount'],
                        properties: {
                          index: { title: 'Withdrawal index', $ref: '#/components/schemas/uint64' },
                          validatorIndex: {
                            title: 'Validator index',
                            $ref: '#/components/schemas/uint64',
                          },
                          address: {
                            title: 'Withdrawal address',
                            $ref: '#/components/schemas/address',
                          },
                          amount: {
                            title: 'Withdrawal amount',
                            $ref: '#/components/schemas/uint64',
                          },
                        },
                      },
                      ExecutionPayloadV2: {
                        title: 'Execution payload object V2',
                        type: 'object',
                        required: [
                          'parentHash',
                          'feeRecipient',
                          'stateRoot',
                          'receiptsRoot',
                          'logsBloom',
                          'prevRandao',
                          'blockNumber',
                          'gasLimit',
                          'gasUsed',
                          'timestamp',
                          'extraData',
                          'baseFeePerGas',
                          'blockHash',
                          'transactions',
                          'withdrawals',
                        ],
                        properties: {
                          parentHash: {
                            $ref: '#/components/schemas/ExecutionPayloadV1/properties/parentHash',
                          },
                          feeRecipient: {
                            $ref: '#/components/schemas/ExecutionPayloadV1/properties/feeRecipient',
                          },
                          stateRoot: {
                            $ref: '#/components/schemas/ExecutionPayloadV1/properties/stateRoot',
                          },
                          receiptsRoot: {
                            $ref: '#/components/schemas/ExecutionPayloadV1/properties/receiptsRoot',
                          },
                          logsBloom: {
                            $ref: '#/components/schemas/ExecutionPayloadV1/properties/logsBloom',
                          },
                          prevRandao: {
                            $ref: '#/components/schemas/ExecutionPayloadV1/properties/prevRandao',
                          },
                          blockNumber: {
                            $ref: '#/components/schemas/ExecutionPayloadV1/properties/blockNumber',
                          },
                          gasLimit: {
                            $ref: '#/components/schemas/ExecutionPayloadV1/properties/gasLimit',
                          },
                          gasUsed: {
                            $ref: '#/components/schemas/ExecutionPayloadV1/properties/gasUsed',
                          },
                          timestamp: {
                            $ref: '#/components/schemas/ExecutionPayloadV1/properties/timestamp',
                          },
                          extraData: {
                            $ref: '#/components/schemas/ExecutionPayloadV1/properties/extraData',
                          },
                          baseFeePerGas: {
                            $ref: '#/components/schemas/ExecutionPayloadV1/properties/baseFeePerGas',
                          },
                          blockHash: {
                            $ref: '#/components/schemas/ExecutionPayloadV1/properties/blockHash',
                          },
                          transactions: {
                            $ref: '#/components/schemas/ExecutionPayloadV1/properties/transactions',
                          },
                          withdrawals: {
                            title: 'Withdrawals',
                            type: 'array',
                            items: { $ref: '#/components/schemas/WithdrawalV1' },
                          },
                        },
                      },
                      ExecutionPayloadV3: {
                        title: 'Execution payload object V3',
                        type: 'object',
                        required: [
                          'parentHash',
                          'feeRecipient',
                          'stateRoot',
                          'receiptsRoot',
                          'logsBloom',
                          'prevRandao',
                          'blockNumber',
                          'gasLimit',
                          'gasUsed',
                          'timestamp',
                          'extraData',
                          'baseFeePerGas',
                          'blockHash',
                          'transactions',
                          'withdrawals',
                          'blobGasUsed',
                          'excessBlobGas',
                        ],
                        properties: {
                          parentHash: {
                            $ref: '#/components/schemas/ExecutionPayloadV2/properties/parentHash',
                          },
                          feeRecipient: {
                            $ref: '#/components/schemas/ExecutionPayloadV2/properties/feeRecipient',
                          },
                          stateRoot: {
                            $ref: '#/components/schemas/ExecutionPayloadV2/properties/stateRoot',
                          },
                          receiptsRoot: {
                            $ref: '#/components/schemas/ExecutionPayloadV2/properties/receiptsRoot',
                          },
                          logsBloom: {
                            $ref: '#/components/schemas/ExecutionPayloadV2/properties/logsBloom',
                          },
                          prevRandao: {
                            $ref: '#/components/schemas/ExecutionPayloadV2/properties/prevRandao',
                          },
                          blockNumber: {
                            $ref: '#/components/schemas/ExecutionPayloadV2/properties/blockNumber',
                          },
                          gasLimit: {
                            $ref: '#/components/schemas/ExecutionPayloadV2/properties/gasLimit',
                          },
                          gasUsed: {
                            $ref: '#/components/schemas/ExecutionPayloadV2/properties/gasUsed',
                          },
                          timestamp: {
                            $ref: '#/components/schemas/ExecutionPayloadV2/properties/timestamp',
                          },
                          extraData: {
                            $ref: '#/components/schemas/ExecutionPayloadV2/properties/extraData',
                          },
                          baseFeePerGas: {
                            $ref: '#/components/schemas/ExecutionPayloadV2/properties/baseFeePerGas',
                          },
                          blockHash: {
                            $ref: '#/components/schemas/ExecutionPayloadV2/properties/blockHash',
                          },
                          transactions: {
                            $ref: '#/components/schemas/ExecutionPayloadV2/properties/transactions',
                          },
                          withdrawals: {
                            $ref: '#/components/schemas/ExecutionPayloadV2/properties/withdrawals',
                          },
                          blobGasUsed: {
                            title: 'Blob gas used',
                            $ref: '#/components/schemas/uint64',
                          },
                          excessBlobGas: {
                            title: 'Excess blob gas',
                            $ref: '#/components/schemas/uint64',
                          },
                        },
                      },
                      ExecutionPayloadV4: {
                        title: 'Execution payload object V4',
                        type: 'object',
                        required: [
                          'parentHash',
                          'feeRecipient',
                          'stateRoot',
                          'receiptsRoot',
                          'logsBloom',
                          'prevRandao',
                          'blockNumber',
                          'gasLimit',
                          'gasUsed',
                          'timestamp',
                          'extraData',
                          'baseFeePerGas',
                          'blockHash',
                          'transactions',
                          'withdrawals',
                          'blobGasUsed',
                          'excessBlobGas',
                          'depositRequests',
                          'withdrawalRequests',
                          'consolidationRequests',
                        ],
                        properties: {
                          parentHash: {
                            $ref: '#/components/schemas/ExecutionPayloadV3/properties/parentHash',
                          },
                          feeRecipient: {
                            $ref: '#/components/schemas/ExecutionPayloadV3/properties/feeRecipient',
                          },
                          stateRoot: {
                            $ref: '#/components/schemas/ExecutionPayloadV3/properties/stateRoot',
                          },
                          receiptsRoot: {
                            $ref: '#/components/schemas/ExecutionPayloadV3/properties/receiptsRoot',
                          },
                          logsBloom: {
                            $ref: '#/components/schemas/ExecutionPayloadV3/properties/logsBloom',
                          },
                          prevRandao: {
                            $ref: '#/components/schemas/ExecutionPayloadV3/properties/prevRandao',
                          },
                          blockNumber: {
                            $ref: '#/components/schemas/ExecutionPayloadV3/properties/blockNumber',
                          },
                          gasLimit: {
                            $ref: '#/components/schemas/ExecutionPayloadV3/properties/gasLimit',
                          },
                          gasUsed: {
                            $ref: '#/components/schemas/ExecutionPayloadV3/properties/gasUsed',
                          },
                          timestamp: {
                            $ref: '#/components/schemas/ExecutionPayloadV3/properties/timestamp',
                          },
                          extraData: {
                            $ref: '#/components/schemas/ExecutionPayloadV3/properties/extraData',
                          },
                          baseFeePerGas: {
                            $ref: '#/components/schemas/ExecutionPayloadV3/properties/baseFeePerGas',
                          },
                          blockHash: {
                            $ref: '#/components/schemas/ExecutionPayloadV3/properties/blockHash',
                          },
                          transactions: {
                            $ref: '#/components/schemas/ExecutionPayloadV3/properties/transactions',
                          },
                          withdrawals: {
                            $ref: '#/components/schemas/ExecutionPayloadV3/properties/withdrawals',
                          },
                          blobGasUsed: {
                            $ref: '#/components/schemas/ExecutionPayloadV3/properties/blobGasUsed',
                          },
                          excessBlobGas: {
                            $ref: '#/components/schemas/ExecutionPayloadV3/properties/excessBlobGas',
                          },
                          depositRequests: {
                            title: 'Deposit requests',
                            type: 'array',
                            items: { $ref: '#/components/schemas/DepositRequestV1' },
                          },
                          withdrawalRequests: {
                            title: 'Withdrawals requests',
                            type: 'array',
                            items: { $ref: '#/components/schemas/WithdrawalRequestV1' },
                          },
                          consolidationRequests: {
                            title: 'Consolidation requests',
                            type: 'array',
                            items: { $ref: '#/components/schemas/ConsolidationRequestV1' },
                          },
                        },
                      },
                      ExecutionPayloadBodyV1: {
                        title: 'Execution payload body object V1',
                        type: 'object',
                        required: ['transactions'],
                        properties: {
                          transactions: {
                            $ref: '#/components/schemas/ExecutionPayloadV1/properties/transactions',
                          },
                          withdrawals: {
                            title: 'Withdrawals',
                            type: ['array', 'null'],
                            items: { $ref: '#/components/schemas/WithdrawalV1' },
                          },
                        },
                      },
                      ExecutionPayloadBodyV2: {
                        title: 'Execution payload body object V2',
                        type: 'object',
                        required: ['transactions'],
                        properties: {
                          transactions: {
                            title: 'Transactions',
                            type: 'array',
                            items: { $ref: '#/components/schemas/bytes' },
                          },
                          withdrawals: {
                            title: 'Withdrawals',
                            type: ['array', 'null'],
                            items: { $ref: '#/components/schemas/WithdrawalV1' },
                          },
                          depositRequests: {
                            title: 'Deposit requests',
                            type: ['array', 'null'],
                            items: { $ref: '#/components/schemas/DepositRequestV1' },
                          },
                          withdrawalRequests: {
                            title: 'Withdrawals requests',
                            type: ['array', 'null'],
                            items: { $ref: '#/components/schemas/WithdrawalRequestV1' },
                          },
                          consolidationRequests: {
                            title: "Consolidation requests - array - 'null'",
                            items: { $ref: '#/components/schemas/ConsolidationRequestV1' },
                          },
                        },
                      },
                      BlobsBundleV1: {
                        title: 'Blobs bundle object V1',
                        type: 'object',
                        required: ['commitments', 'proofs', 'blobs'],
                        properties: {
                          commitments: {
                            title: 'Commitments',
                            type: 'array',
                            items: { $ref: '#/components/schemas/bytes48' },
                          },
                          proofs: {
                            title: 'Proofs',
                            type: 'array',
                            items: { $ref: '#/components/schemas/bytes48' },
                          },
                          blobs: {
                            title: 'Blobs',
                            type: 'array',
                            items: { $ref: '#/components/schemas/bytes' },
                          },
                        },
                      },
                      DepositRequestV1: {
                        title: 'Deposit request object V1',
                        type: 'object',
                        required: [
                          'pubkey',
                          'withdrawalCredentials',
                          'amount',
                          'signature',
                          'index',
                        ],
                        properties: {
                          pubkey: { title: 'Public key', $ref: '#/components/schemas/bytes48' },
                          withdrawalCredentials: {
                            title: 'Withdrawal credentials',
                            $ref: '#/components/schemas/bytes32',
                          },
                          amount: { title: 'Deposit amount', $ref: '#/components/schemas/uint64' },
                          signature: {
                            title: 'Deposit signature',
                            $ref: '#/components/schemas/bytes96',
                          },
                          index: { title: 'Deposit index', $ref: '#/components/schemas/uint64' },
                        },
                      },
                      WithdrawalRequestV1: {
                        title: 'Withdrawal request object V1',
                        type: 'object',
                        required: ['sourceAddress', 'validatorPubkey', 'amount'],
                        properties: {
                          sourceAddress: {
                            title: 'Source address',
                            $ref: '#/components/schemas/address',
                          },
                          validatorPubkey: {
                            title: 'Validator public key',
                            $ref: '#/components/schemas/bytes48',
                          },
                          amount: { title: 'Withdraw amount', $ref: '#/components/schemas/uint64' },
                        },
                      },
                      ConsolidationRequestV1: {
                        title: 'Consolidation request object V1',
                        type: 'object',
                        required: ['sourceAddress', 'sourcePubkey', 'targetPubkey'],
                        properties: {
                          sourceAddress: {
                            title: 'Source address',
                            $ref: '#/components/schemas/address',
                          },
                          sourcePubkey: {
                            title: 'Source validator public key',
                            $ref: '#/components/schemas/bytes48',
                          },
                          targetPubkey: {
                            title: 'Target validator public key',
                            $ref: '#/components/schemas/bytes48',
                          },
                        },
                      },
                      TransitionConfigurationV1: {
                        title: 'Transition configuration object',
                        type: 'object',
                        required: [
                          'terminalTotalDifficulty',
                          'terminalBlockHash',
                          'terminalBlockNumber',
                        ],
                        properties: {
                          terminalTotalDifficulty: {
                            title: 'Terminal total difficulty',
                            $ref: '#/components/schemas/uint256',
                          },
                          terminalBlockHash: {
                            title: 'Terminal block hash',
                            $ref: '#/components/schemas/hash32',
                          },
                          terminalBlockNumber: {
                            title: 'Terminal block number',
                            $ref: '#/components/schemas/uint64',
                          },
                        },
                      },
                    },
                    tags: {
                      MetaMask: { name: 'MetaMask', description: 'MetaMask-specific methods.' },
                      Restricted: {
                        name: 'Restricted',
                        description:
                          'Restricted methods. If a method is restricted, the caller must have the corresponding permission via `wallet_requestPermissions` in order to call it.',
                      },
                      Mobile: { name: 'Mobile', description: 'Mobile-specific methods.' },
                      Experimental: { name: 'Experimental', description: 'Experimental methods.' },
                      Deprecated: { name: 'Deprecated', description: 'Deprecated methods.' },
                      Ethereum: {
                        name: 'Ethereum API',
                        description: 'Ethereum execution API methods.',
                      },
                      Multichain: {
                        name: 'Multichain API',
                        description: 'Multichain API methods.',
                      },
                    },
                    contentDescriptors: {},
                    examplePairings: {},
                    links: {},
                    examples: {},
                  },
                };
              };
            };
      },
      {
        package: '@metamask/multichain-api-middleware>@metamask/api-specs',
        file: 'node_modules/@metamask/multichain-api-middleware/node_modules/@metamask/api-specs/dist/build/openrpc.json',
      },
    ],
    [
      2124,
      { './build/multichain-openrpc.json': 2122, './build/openrpc.json': 2123 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                var r =
                  (this && this.__importDefault) ||
                  function (e) {
                    return e && e.__esModule ? e : { default: e };
                  };
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.MultiChainOpenRPCDocument = n.MetaMaskOpenRPCDocument = void 0);
                const s = r(e('./build/openrpc.json'));
                n.MetaMaskOpenRPCDocument = s.default;
                const a = r(e('./build/multichain-openrpc.json'));
                (n.MultiChainOpenRPCDocument = a.default), (n.default = s.default);
              };
            };
      },
      {
        package: '@metamask/multichain-api-middleware>@metamask/api-specs',
        file: 'node_modules/@metamask/multichain-api-middleware/node_modules/@metamask/api-specs/dist/index.js',
      },
    ],
    [
      2125,
      {
        '../scope/constants.cjs': 2132,
        '../scope/transform.cjs': 2136,
        '../scope/types.cjs': 2137,
        '@metamask/utils': 2995,
      },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.setEthAccounts = n.getEthAccounts = void 0);
                const r = e('@metamask/utils'),
                  s = e('../scope/constants.cjs'),
                  a = e('../scope/transform.cjs'),
                  o = e('../scope/types.cjs'),
                  i = e => {
                    const { namespace: t } = (0, o.parseScopeString)(e);
                    return (
                      t === r.KnownCaipNamespace.Eip155 || e === s.KnownWalletScopeString.Eip155
                    );
                  },
                  c = e => {
                    const t = [];
                    return (
                      Object.entries(e).forEach(([e, { accounts: n }]) => {
                        n?.forEach(e => {
                          const { address: n, chainId: s } = (0, r.parseCaipAccountId)(e);
                          i(s) && ((0, r.assertIsStrictHexString)(n), t.push(n));
                        });
                      }),
                      t
                    );
                  };
                n.getEthAccounts = e => {
                  const { requiredScopes: t, optionalScopes: n } = e,
                    r = [...c(t), ...c(n)];
                  return (0, a.getUniqueArrayItems)(r);
                };
                const l = (e, t) => {
                  const n = {};
                  return (
                    Object.entries(e).forEach(([e, s]) => {
                      const a = e,
                        c = a === r.KnownCaipNamespace.Wallet,
                        { namespace: l, reference: d } = (0, o.parseScopeString)(a);
                      if (!i(a) && !c) return void (n[a] = s);
                      let u = [];
                      l && d && (u = t.map(e => `${l}:${d}:${e}`)), (n[a] = { ...s, accounts: u });
                    }),
                    n
                  );
                };
                n.setEthAccounts = (e, t) => ({
                  ...e,
                  requiredScopes: l(e.requiredScopes, t),
                  optionalScopes: l(e.optionalScopes, t),
                });
              };
            };
      },
      {
        package: '@metamask/multichain-api-middleware>@metamask/chain-agnostic-permission',
        file: 'node_modules/@metamask/multichain-api-middleware/node_modules/@metamask/chain-agnostic-permission/dist/adapters/caip-permission-adapter-eth-accounts.cjs',
      },
    ],
    [
      2126,
      {
        '../scope/transform.cjs': 2136,
        '../scope/types.cjs': 2137,
        '@metamask/controller-utils': 1515,
        '@metamask/utils': 2995,
      },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.setPermittedEthChainIds =
                    n.addPermittedEthChainId =
                    n.getPermittedEthChainIds =
                      void 0);
                const r = e('@metamask/controller-utils'),
                  s = e('@metamask/utils'),
                  a = e('../scope/transform.cjs'),
                  o = e('../scope/types.cjs'),
                  i = e => {
                    const t = [];
                    return (
                      Object.keys(e).forEach(e => {
                        const { namespace: n, reference: a } = (0, o.parseScopeString)(e);
                        n === s.KnownCaipNamespace.Eip155 && a && t.push((0, r.toHex)(a));
                      }),
                      t
                    );
                  };
                n.getPermittedEthChainIds = e => {
                  const { requiredScopes: t, optionalScopes: n } = e,
                    r = [...i(t), ...i(n)];
                  return (0, a.getUniqueArrayItems)(r);
                };
                n.addPermittedEthChainId = (e, t) => {
                  const n = `eip155:${(0, s.hexToBigInt)(t).toString(10)}`;
                  return Object.keys(e.requiredScopes).includes(n) ||
                    Object.keys(e.optionalScopes).includes(n)
                    ? e
                    : { ...e, optionalScopes: { ...e.optionalScopes, [n]: { accounts: [] } } };
                };
                const c = (e, t) => {
                  const n = {};
                  return (
                    Object.entries(e).forEach(([e, a]) => {
                      const i = e,
                        { namespace: c, reference: l } = (0, o.parseScopeString)(i);
                      if (l)
                        if (c === s.KnownCaipNamespace.Eip155) {
                          const e = (0, r.toHex)(l);
                          t.includes(e) && (n[i] = a);
                        } else n[i] = a;
                      else n[i] = a;
                    }),
                    n
                  );
                };
                n.setPermittedEthChainIds = (e, t) => {
                  let r = {
                    ...e,
                    requiredScopes: c(e.requiredScopes, t),
                    optionalScopes: c(e.optionalScopes, t),
                  };
                  return (
                    t.forEach(e => {
                      r = (0, n.addPermittedEthChainId)(r, e);
                    }),
                    r
                  );
                };
              };
            };
      },
      {
        package: '@metamask/multichain-api-middleware>@metamask/chain-agnostic-permission',
        file: 'node_modules/@metamask/multichain-api-middleware/node_modules/@metamask/chain-agnostic-permission/dist/adapters/caip-permission-adapter-permittedChains.cjs',
      },
    ],
    [
      2127,
      {
        '../scope/constants.cjs': 2132,
        '../scope/transform.cjs': 2136,
        '../scope/types.cjs': 2137,
        '@metamask/utils': 2995,
      },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.getPermittedAccountsForScopes =
                    n.getSessionScopes =
                    n.getInternalScopesObject =
                      void 0);
                const r = e('@metamask/utils'),
                  s = e('../scope/constants.cjs'),
                  a = e('../scope/transform.cjs'),
                  o = e('../scope/types.cjs');
                n.getInternalScopesObject = e => {
                  const t = {};
                  return (
                    Object.entries(e).forEach(([e, { accounts: n }]) => {
                      t[e] = { accounts: n };
                    }),
                    t
                  );
                };
                const i = (e, { getNonEvmSupportedMethods: t }) => {
                  const n = {};
                  return (
                    Object.entries(e).forEach(([e, { accounts: a }]) => {
                      const i = e,
                        { namespace: c, reference: l } = (0, o.parseScopeString)(i);
                      let d = [],
                        u = [];
                      i === r.KnownCaipNamespace.Wallet || c === r.KnownCaipNamespace.Wallet
                        ? (d =
                            l === r.KnownCaipNamespace.Eip155
                              ? s.KnownWalletNamespaceRpcMethods[l]
                              : (0, r.isCaipChainId)(i)
                                ? t(i)
                                : s.KnownWalletRpcMethods)
                        : c === r.KnownCaipNamespace.Eip155
                          ? ((d = s.KnownRpcMethods[c]), (u = s.KnownNotifications[c]))
                          : ((d = t(i)), (u = [])),
                        (n[i] = { methods: d, notifications: u, accounts: a });
                    }),
                    n
                  );
                };
                n.getSessionScopes = (e, { getNonEvmSupportedMethods: t }) =>
                  (0, a.mergeNormalizedScopes)(
                    i(e.requiredScopes, { getNonEvmSupportedMethods: t }),
                    i(e.optionalScopes, { getNonEvmSupportedMethods: t })
                  );
                n.getPermittedAccountsForScopes = (e, t) => {
                  const n = [];
                  return (
                    t.forEach(t => {
                      const r = e.requiredScopes[t],
                        s = e.optionalScopes[t];
                      r && n.push(...r.accounts), s && n.push(...s.accounts);
                    }),
                    [...new Set(n)]
                  );
                };
              };
            };
      },
      {
        package: '@metamask/multichain-api-middleware>@metamask/chain-agnostic-permission',
        file: 'node_modules/@metamask/multichain-api-middleware/node_modules/@metamask/chain-agnostic-permission/dist/adapters/caip-permission-adapter-session-scopes.cjs',
      },
    ],
    [
      2128,
      {
        './scope/assert.cjs': 2130,
        './scope/supported.cjs': 2135,
        './scope/transform.cjs': 2136,
        './scope/types.cjs': 2137,
        '@metamask/permission-controller': 2421,
        '@metamask/utils': 2995,
        lodash: 4921,
      },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.Caip25CaveatMutators =
                    n.caip25EndowmentBuilder =
                    n.caip25CaveatBuilder =
                    n.diffScopesForCaip25CaveatValue =
                    n.createCaip25Caveat =
                    n.Caip25EndowmentPermissionName =
                    n.Caip25CaveatType =
                      void 0);
                const r = e('@metamask/permission-controller'),
                  s = e('@metamask/utils'),
                  a = e('lodash'),
                  o = e('./scope/assert.cjs'),
                  i = e('./scope/supported.cjs'),
                  c = e('./scope/transform.cjs'),
                  l = e('./scope/types.cjs');
                (n.Caip25CaveatType = 'authorizedScopes'),
                  (n.Caip25EndowmentPermissionName = 'endowment:caip25');
                function d(e, t, n) {
                  const r = (0, a.cloneDeep)(e),
                    s = t[n];
                  for (const [e, t] of Object.entries(s)) {
                    const s = e,
                      a = r[n][s];
                    if (a) {
                      const e = t.accounts.filter(e => !a?.accounts.includes(e));
                      if (e.length > 0) {
                        r[n][s] = { accounts: e };
                        continue;
                      }
                      delete r[n][s];
                    } else r[n][s] = t;
                  }
                  return r;
                }
                function u(e, t, n) {
                  return Object.values(e).every(e =>
                    e.accounts.every(e =>
                      (0, i.isSupportedAccount)(e, {
                        getEvmInternalAccounts: t,
                        getNonEvmAccountAddresses: n,
                      })
                    )
                  );
                }
                (n.createCaip25Caveat = e => ({ type: n.Caip25CaveatType, value: e })),
                  (n.diffScopesForCaip25CaveatValue = d);
                n.caip25CaveatBuilder = ({
                  findNetworkClientIdByChainId: e,
                  listAccounts: t,
                  isNonEvmScopeSupported: r,
                  getNonEvmAccountAddresses: a,
                }) => ({
                  type: n.Caip25CaveatType,
                  validator: (c, l, d) => {
                    if (
                      !(
                        c.value &&
                        (0, s.hasProperty)(c.value, 'requiredScopes') &&
                        (0, s.hasProperty)(c.value, 'optionalScopes') &&
                        (0, s.hasProperty)(c.value, 'isMultichainOrigin') &&
                        (0, s.hasProperty)(c.value, 'sessionProperties') &&
                        'boolean' == typeof c.value.isMultichainOrigin &&
                        (0, s.isObject)(c.value.sessionProperties)
                      )
                    )
                      throw new Error(
                        `${n.Caip25EndowmentPermissionName} error: Received invalid value for caveat of type "${n.Caip25CaveatType}".`
                      );
                    const { requiredScopes: h, optionalScopes: p, sessionProperties: m } = c.value;
                    if (!Object.keys(m).every(e => (0, i.isSupportedSessionProperty)(e)))
                      throw new Error(
                        `${n.Caip25EndowmentPermissionName} error: Received unknown session property(s) for caveat of type "${n.Caip25CaveatType}".`
                      );
                    (0, o.assertIsInternalScopesObject)(h), (0, o.assertIsInternalScopesObject)(p);
                    const f = t => {
                        try {
                          return e(t), !0;
                        } catch {
                          return !1;
                        }
                      },
                      g = Object.keys(h).every(e =>
                        (0, i.isSupportedScopeString)(e, {
                          isEvmChainIdSupported: f,
                          isNonEvmScopeSupported: r,
                        })
                      ),
                      b = Object.keys(p).every(e =>
                        (0, i.isSupportedScopeString)(e, {
                          isEvmChainIdSupported: f,
                          isNonEvmScopeSupported: r,
                        })
                      );
                    if (!g || !b)
                      throw new Error(
                        `${n.Caip25EndowmentPermissionName} error: Received scopeString value(s) for caveat of type "${n.Caip25CaveatType}" that are not supported by the wallet.`
                      );
                    const y = u(h, t, a),
                      w = u(p, t, a);
                    if (!y || !w)
                      throw new Error(
                        `${n.Caip25EndowmentPermissionName} error: Received account value(s) for caveat of type "${n.Caip25CaveatType}" that are not supported by the wallet.`
                      );
                  },
                  merger: (e, t) => {
                    const n = {
                        requiredScopes: (0, c.mergeInternalScopes)(
                          e.requiredScopes,
                          t.requiredScopes
                        ),
                        optionalScopes: (0, c.mergeInternalScopes)(
                          e.optionalScopes,
                          t.optionalScopes
                        ),
                        sessionProperties: { ...e.sessionProperties, ...t.sessionProperties },
                        isMultichainOrigin: e.isMultichainOrigin,
                      },
                      r = d(e, n, 'requiredScopes');
                    return [n, d(r, n, 'optionalScopes')];
                  },
                });
                (n.caip25EndowmentBuilder = Object.freeze({
                  targetName: n.Caip25EndowmentPermissionName,
                  specificationBuilder: () => ({
                    permissionType: r.PermissionType.Endowment,
                    targetName: n.Caip25EndowmentPermissionName,
                    allowedCaveats: [n.Caip25CaveatType],
                    endowmentGetter: e => null,
                    validator: e => {
                      if (1 !== e.caveats?.length || e.caveats?.[0]?.type !== n.Caip25CaveatType)
                        throw new Error(
                          `${n.Caip25EndowmentPermissionName} error: Invalid caveats. There must be a single caveat of type "${n.Caip25CaveatType}".`
                        );
                    },
                  }),
                })),
                  (n.Caip25CaveatMutators = {
                    [n.Caip25CaveatType]: {
                      removeScope: function (e, t) {
                        const n = Object.entries(e.requiredScopes).filter(([e]) => e !== t),
                          a = Object.entries(e.optionalScopes).filter(([e]) => e !== t),
                          o = n.length !== Object.keys(e.requiredScopes).length,
                          i = a.length !== Object.keys(e.optionalScopes).length;
                        if (!o && !i) return { operation: r.CaveatMutatorOperation.Noop };
                        const c = {
                          ...e,
                          requiredScopes: Object.fromEntries(n),
                          optionalScopes: Object.fromEntries(a),
                        };
                        if (
                          [...n, ...a].some(([e]) => {
                            const { namespace: t } = (0, l.parseScopeString)(e);
                            return t !== s.KnownCaipNamespace.Wallet;
                          })
                        )
                          return { operation: r.CaveatMutatorOperation.UpdateValue, value: c };
                        return { operation: r.CaveatMutatorOperation.RevokePermission };
                      },
                      removeAccount: function (e, t) {
                        const n = (0, a.cloneDeep)(e);
                        [n.requiredScopes, n.optionalScopes].forEach(e => {
                          Object.entries(e).forEach(([, e]) => {
                            !(function (e, t) {
                              e.accounts &&
                                (e.accounts = e.accounts.filter(
                                  (function (e) {
                                    return t => (0, s.parseCaipAccountId)(t).address !== e;
                                  })(t)
                                ));
                            })(e, t);
                          });
                        });
                        if ((0, a.isEqual)(n, e))
                          return { operation: r.CaveatMutatorOperation.Noop };
                        if (
                          [
                            ...Object.values(n.requiredScopes),
                            ...Object.values(n.optionalScopes),
                          ].some(({ accounts: e }) => e.length > 0)
                        )
                          return { operation: r.CaveatMutatorOperation.UpdateValue, value: n };
                        return { operation: r.CaveatMutatorOperation.RevokePermission };
                      },
                    },
                  });
              };
            };
      },
      {
        package: '@metamask/multichain-api-middleware>@metamask/chain-agnostic-permission',
        file: 'node_modules/@metamask/multichain-api-middleware/node_modules/@metamask/chain-agnostic-permission/dist/caip25Permission.cjs',
      },
    ],
    [
      2129,
      {
        './adapters/caip-permission-adapter-eth-accounts.cjs': 2125,
        './adapters/caip-permission-adapter-permittedChains.cjs': 2126,
        './adapters/caip-permission-adapter-session-scopes.cjs': 2127,
        './caip25Permission.cjs': 2128,
        './scope/assert.cjs': 2130,
        './scope/authorization.cjs': 2131,
        './scope/constants.cjs': 2132,
        './scope/filter.cjs': 2134,
        './scope/transform.cjs': 2136,
        './scope/types.cjs': 2137,
      },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.Caip25CaveatMutators =
                    n.caip25EndowmentBuilder =
                    n.Caip25EndowmentPermissionName =
                    n.createCaip25Caveat =
                    n.Caip25CaveatType =
                    n.caip25CaveatBuilder =
                    n.normalizeAndMergeScopes =
                    n.mergeInternalScopes =
                    n.mergeNormalizedScopes =
                    n.mergeScopeObject =
                    n.normalizeScope =
                    n.getUniqueArrayItems =
                    n.parseScopeString =
                    n.getSupportedScopeObjects =
                    n.KnownWalletScopeString =
                    n.KnownNotifications =
                    n.KnownWalletNamespaceRpcMethods =
                    n.KnownRpcMethods =
                    n.KnownWalletRpcMethods =
                    n.assertIsInternalScopeString =
                    n.bucketScopes =
                    n.validateAndNormalizeScopes =
                    n.getPermittedAccountsForScopes =
                    n.getSessionScopes =
                    n.getInternalScopesObject =
                    n.setPermittedEthChainIds =
                    n.addPermittedEthChainId =
                    n.getPermittedEthChainIds =
                    n.setEthAccounts =
                    n.getEthAccounts =
                      void 0);
                var r = e('./adapters/caip-permission-adapter-eth-accounts.cjs');
                Object.defineProperty(n, 'getEthAccounts', {
                  enumerable: !0,
                  get: function () {
                    return r.getEthAccounts;
                  },
                }),
                  Object.defineProperty(n, 'setEthAccounts', {
                    enumerable: !0,
                    get: function () {
                      return r.setEthAccounts;
                    },
                  });
                var s = e('./adapters/caip-permission-adapter-permittedChains.cjs');
                Object.defineProperty(n, 'getPermittedEthChainIds', {
                  enumerable: !0,
                  get: function () {
                    return s.getPermittedEthChainIds;
                  },
                }),
                  Object.defineProperty(n, 'addPermittedEthChainId', {
                    enumerable: !0,
                    get: function () {
                      return s.addPermittedEthChainId;
                    },
                  }),
                  Object.defineProperty(n, 'setPermittedEthChainIds', {
                    enumerable: !0,
                    get: function () {
                      return s.setPermittedEthChainIds;
                    },
                  });
                var a = e('./adapters/caip-permission-adapter-session-scopes.cjs');
                Object.defineProperty(n, 'getInternalScopesObject', {
                  enumerable: !0,
                  get: function () {
                    return a.getInternalScopesObject;
                  },
                }),
                  Object.defineProperty(n, 'getSessionScopes', {
                    enumerable: !0,
                    get: function () {
                      return a.getSessionScopes;
                    },
                  }),
                  Object.defineProperty(n, 'getPermittedAccountsForScopes', {
                    enumerable: !0,
                    get: function () {
                      return a.getPermittedAccountsForScopes;
                    },
                  });
                var o = e('./scope/authorization.cjs');
                Object.defineProperty(n, 'validateAndNormalizeScopes', {
                  enumerable: !0,
                  get: function () {
                    return o.validateAndNormalizeScopes;
                  },
                }),
                  Object.defineProperty(n, 'bucketScopes', {
                    enumerable: !0,
                    get: function () {
                      return o.bucketScopes;
                    },
                  });
                var i = e('./scope/assert.cjs');
                Object.defineProperty(n, 'assertIsInternalScopeString', {
                  enumerable: !0,
                  get: function () {
                    return i.assertIsInternalScopeString;
                  },
                });
                var c = e('./scope/constants.cjs');
                Object.defineProperty(n, 'KnownWalletRpcMethods', {
                  enumerable: !0,
                  get: function () {
                    return c.KnownWalletRpcMethods;
                  },
                }),
                  Object.defineProperty(n, 'KnownRpcMethods', {
                    enumerable: !0,
                    get: function () {
                      return c.KnownRpcMethods;
                    },
                  }),
                  Object.defineProperty(n, 'KnownWalletNamespaceRpcMethods', {
                    enumerable: !0,
                    get: function () {
                      return c.KnownWalletNamespaceRpcMethods;
                    },
                  }),
                  Object.defineProperty(n, 'KnownNotifications', {
                    enumerable: !0,
                    get: function () {
                      return c.KnownNotifications;
                    },
                  }),
                  Object.defineProperty(n, 'KnownWalletScopeString', {
                    enumerable: !0,
                    get: function () {
                      return c.KnownWalletScopeString;
                    },
                  });
                var l = e('./scope/filter.cjs');
                Object.defineProperty(n, 'getSupportedScopeObjects', {
                  enumerable: !0,
                  get: function () {
                    return l.getSupportedScopeObjects;
                  },
                });
                var d = e('./scope/types.cjs');
                Object.defineProperty(n, 'parseScopeString', {
                  enumerable: !0,
                  get: function () {
                    return d.parseScopeString;
                  },
                });
                var u = e('./scope/transform.cjs');
                Object.defineProperty(n, 'getUniqueArrayItems', {
                  enumerable: !0,
                  get: function () {
                    return u.getUniqueArrayItems;
                  },
                }),
                  Object.defineProperty(n, 'normalizeScope', {
                    enumerable: !0,
                    get: function () {
                      return u.normalizeScope;
                    },
                  }),
                  Object.defineProperty(n, 'mergeScopeObject', {
                    enumerable: !0,
                    get: function () {
                      return u.mergeScopeObject;
                    },
                  }),
                  Object.defineProperty(n, 'mergeNormalizedScopes', {
                    enumerable: !0,
                    get: function () {
                      return u.mergeNormalizedScopes;
                    },
                  }),
                  Object.defineProperty(n, 'mergeInternalScopes', {
                    enumerable: !0,
                    get: function () {
                      return u.mergeInternalScopes;
                    },
                  }),
                  Object.defineProperty(n, 'normalizeAndMergeScopes', {
                    enumerable: !0,
                    get: function () {
                      return u.normalizeAndMergeScopes;
                    },
                  });
                var h = e('./caip25Permission.cjs');
                Object.defineProperty(n, 'caip25CaveatBuilder', {
                  enumerable: !0,
                  get: function () {
                    return h.caip25CaveatBuilder;
                  },
                }),
                  Object.defineProperty(n, 'Caip25CaveatType', {
                    enumerable: !0,
                    get: function () {
                      return h.Caip25CaveatType;
                    },
                  }),
                  Object.defineProperty(n, 'createCaip25Caveat', {
                    enumerable: !0,
                    get: function () {
                      return h.createCaip25Caveat;
                    },
                  }),
                  Object.defineProperty(n, 'Caip25EndowmentPermissionName', {
                    enumerable: !0,
                    get: function () {
                      return h.Caip25EndowmentPermissionName;
                    },
                  }),
                  Object.defineProperty(n, 'caip25EndowmentBuilder', {
                    enumerable: !0,
                    get: function () {
                      return h.caip25EndowmentBuilder;
                    },
                  }),
                  Object.defineProperty(n, 'Caip25CaveatMutators', {
                    enumerable: !0,
                    get: function () {
                      return h.Caip25CaveatMutators;
                    },
                  });
              };
            };
      },
      {
        package: '@metamask/multichain-api-middleware>@metamask/chain-agnostic-permission',
        file: 'node_modules/@metamask/multichain-api-middleware/node_modules/@metamask/chain-agnostic-permission/dist/index.cjs',
      },
    ],
    [
      213,
      { lodash: 4921 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = void 0);
                var r = e('lodash');
                n.default = {
                  version: 9,
                  migrate(e) {
                    const t = (0, r.cloneDeep)(e);
                    t.meta.version = 9;
                    try {
                      const e = (function (e) {
                        const t = (0, r.merge)({}, e, {
                          CurrencyController: {
                            currentCurrency: e.currentFiat || e.fiatCurrency || 'USD',
                            conversionRate: e.conversionRate,
                            conversionDate: e.conversionDate,
                          },
                        });
                        return (
                          delete t.currentFiat,
                          delete t.fiatCurrency,
                          delete t.conversionRate,
                          delete t.conversionDate,
                          t
                        );
                      })(t.data);
                      t.data = e;
                    } catch (e) {
                      console.warn(`MetaMask Migration #9${e.stack}`);
                    }
                    return Promise.resolve(t);
                  },
                };
              };
            };
      },
      { package: '$root$', file: 'app/scripts/migrations/009.js' },
    ],
    [
      2130,
      { './errors.cjs': 2133, './supported.cjs': 2135, '@metamask/utils': 2995 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.assertIsInternalScopesObject =
                    n.assertIsInternalScopeString =
                    n.assertIsExternalScopesObject =
                    n.assertScopesSupported =
                    n.assertScopeSupported =
                      void 0);
                const r = e('@metamask/utils'),
                  s = e('./errors.cjs'),
                  a = e('./supported.cjs');
                n.assertScopeSupported = (
                  e,
                  t,
                  {
                    isEvmChainIdSupported: n,
                    isNonEvmScopeSupported: r,
                    getNonEvmSupportedMethods: o,
                  }
                ) => {
                  const { methods: i, notifications: c } = t;
                  if (
                    !(0, a.isSupportedScopeString)(e, {
                      isEvmChainIdSupported: n,
                      isNonEvmScopeSupported: r,
                    })
                  )
                    throw s.Caip25Errors.requestedChainsNotSupportedError();
                  if (
                    !i.every(t => (0, a.isSupportedMethod)(e, t, { getNonEvmSupportedMethods: o }))
                  )
                    throw s.Caip25Errors.requestedMethodsNotSupportedError();
                  if (c && !c.every(t => (0, a.isSupportedNotification)(e, t)))
                    throw s.Caip25Errors.requestedNotificationsNotSupportedError();
                };
                function o(e) {
                  if ('object' != typeof e || null === e)
                    throw new Error('ExternalScopeObject must be an object');
                  if (
                    (0, r.hasProperty)(e, 'references') &&
                    (!Array.isArray(e.references) || !e.references.every(r.isCaipReference))
                  )
                    throw new Error(
                      'ExternalScopeObject.references must be an array of CaipReference'
                    );
                  if (
                    (0, r.hasProperty)(e, 'accounts') &&
                    (!Array.isArray(e.accounts) || !e.accounts.every(r.isCaipAccountId))
                  )
                    throw new Error(
                      'ExternalScopeObject.accounts must be an array of CaipAccountId'
                    );
                  if (
                    (0, r.hasProperty)(e, 'methods') &&
                    (!Array.isArray(e.methods) || !e.methods.every(e => 'string' == typeof e))
                  )
                    throw new Error('ExternalScopeObject.methods must be an array of strings');
                  if (
                    (0, r.hasProperty)(e, 'notifications') &&
                    (!Array.isArray(e.notifications) ||
                      !e.notifications.every(e => 'string' == typeof e))
                  )
                    throw new Error(
                      'ExternalScopeObject.notifications must be an array of strings'
                    );
                  if (
                    (0, r.hasProperty)(e, 'rpcDocuments') &&
                    (!Array.isArray(e.rpcDocuments) ||
                      !e.rpcDocuments.every(e => 'string' == typeof e))
                  )
                    throw new Error('ExternalScopeObject.rpcDocuments must be an array of strings');
                  if (
                    (0, r.hasProperty)(e, 'rpcEndpoints') &&
                    (!Array.isArray(e.rpcEndpoints) ||
                      !e.rpcEndpoints.every(e => 'string' == typeof e))
                  )
                    throw new Error('ExternalScopeObject.rpcEndpoints must be an array of strings');
                }
                function i(e) {
                  if (
                    'string' != typeof e ||
                    (!(0, r.isCaipNamespace)(e) && !(0, r.isCaipChainId)(e))
                  )
                    throw new Error('scopeString is not a valid ExternalScopeString');
                }
                function c(e) {
                  if ('object' != typeof e || null === e)
                    throw new Error('InternalScopeObject must be an object');
                  if (
                    !(0, r.hasProperty)(e, 'accounts') ||
                    !Array.isArray(e.accounts) ||
                    !e.accounts.every(r.isCaipAccountId)
                  )
                    throw new Error(
                      'InternalScopeObject.accounts must be an array of CaipAccountId'
                    );
                }
                function l(e) {
                  if (
                    'string' != typeof e ||
                    (e !== r.KnownCaipNamespace.Wallet && !(0, r.isCaipChainId)(e))
                  )
                    throw new Error('scopeString is not a valid InternalScopeString');
                }
                (n.assertScopesSupported = (
                  e,
                  {
                    isEvmChainIdSupported: t,
                    isNonEvmScopeSupported: r,
                    getNonEvmSupportedMethods: s,
                  }
                ) => {
                  for (const [a, o] of Object.entries(e))
                    (0, n.assertScopeSupported)(a, o, {
                      isEvmChainIdSupported: t,
                      isNonEvmScopeSupported: r,
                      getNonEvmSupportedMethods: s,
                    });
                }),
                  (n.assertIsExternalScopesObject = function (e) {
                    if ('object' != typeof e || null === e)
                      throw new Error('ExternalScopesObject must be an object');
                    for (const [t, n] of Object.entries(e)) i(t), o(n);
                  }),
                  (n.assertIsInternalScopeString = l),
                  (n.assertIsInternalScopesObject = function (e) {
                    if ('object' != typeof e || null === e)
                      throw new Error('InternalScopesObject must be an object');
                    for (const [t, n] of Object.entries(e)) l(t), c(n);
                  });
              };
            };
      },
      {
        package: '@metamask/multichain-api-middleware>@metamask/chain-agnostic-permission',
        file: 'node_modules/@metamask/multichain-api-middleware/node_modules/@metamask/chain-agnostic-permission/dist/scope/assert.cjs',
      },
    ],
    [
      2131,
      { './filter.cjs': 2134, './transform.cjs': 2136, './validation.cjs': 2138 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.bucketScopes = n.validateAndNormalizeScopes = void 0);
                const r = e('./filter.cjs'),
                  s = e('./transform.cjs'),
                  a = e('./validation.cjs');
                n.validateAndNormalizeScopes = (e, t) => {
                  const { validRequiredScopes: n, validOptionalScopes: r } = (0, a.getValidScopes)(
                    e,
                    t
                  );
                  return {
                    normalizedRequiredScopes: (0, s.normalizeAndMergeScopes)(n),
                    normalizedOptionalScopes: (0, s.normalizeAndMergeScopes)(r),
                  };
                };
                n.bucketScopes = (
                  e,
                  {
                    isEvmChainIdSupported: t,
                    isEvmChainIdSupportable: n,
                    isNonEvmScopeSupported: s,
                    getNonEvmSupportedMethods: a,
                  }
                ) => {
                  const { supportedScopes: o, unsupportedScopes: i } = (0, r.bucketScopesBySupport)(
                      e,
                      {
                        isEvmChainIdSupported: t,
                        isNonEvmScopeSupported: s,
                        getNonEvmSupportedMethods: a,
                      }
                    ),
                    { supportedScopes: c, unsupportedScopes: l } = (0, r.bucketScopesBySupport)(i, {
                      isEvmChainIdSupported: n,
                      isNonEvmScopeSupported: s,
                      getNonEvmSupportedMethods: a,
                    });
                  return { supportedScopes: o, supportableScopes: c, unsupportableScopes: l };
                };
              };
            };
      },
      {
        package: '@metamask/multichain-api-middleware>@metamask/chain-agnostic-permission',
        file: 'node_modules/@metamask/multichain-api-middleware/node_modules/@metamask/chain-agnostic-permission/dist/scope/authorization.cjs',
      },
    ],
    [
      2132,
      { '@metamask/api-specs': 2124 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                var r =
                  (this && this.__importDefault) ||
                  function (e) {
                    return e && e.__esModule ? e : { default: e };
                  };
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.KnownSessionProperties =
                    n.KnownNotifications =
                    n.KnownWalletNamespaceRpcMethods =
                    n.KnownRpcMethods =
                    n.Eip1193OnlyMethods =
                    n.KnownWalletRpcMethods =
                    n.CaipReferenceRegexes =
                    n.KnownWalletScopeString =
                      void 0);
                const s = r(e('@metamask/api-specs'));
                var a;
                !(function (e) {
                  e.Eip155 = 'wallet:eip155';
                })(a || (n.KnownWalletScopeString = a = {})),
                  (n.CaipReferenceRegexes = {
                    eip155: /^(0|[1-9][0-9]*)$/u,
                    bip122: /.*/u,
                    solana: /.*/u,
                  }),
                  (n.KnownWalletRpcMethods = ['wallet_registerOnboarding', 'wallet_scanQRCode']);
                const o = ['wallet_addEthereumChain'];
                n.Eip1193OnlyMethods = [
                  'wallet_switchEthereumChain',
                  'wallet_getPermissions',
                  'wallet_requestPermissions',
                  'wallet_revokePermissions',
                  'eth_requestAccounts',
                  'eth_accounts',
                  'eth_coinbase',
                  'net_version',
                  'metamask_logWeb3ShimUsage',
                  'metamask_getProviderState',
                  'metamask_sendDomainMetadata',
                  'wallet_registerOnboarding',
                ];
                const i = s.default.methods
                  .map(({ name: e }) => e)
                  .filter(e => !o.includes(e))
                  .filter(e => !n.KnownWalletRpcMethods.includes(e))
                  .filter(e => !n.Eip1193OnlyMethods.includes(e));
                var c;
                (n.KnownRpcMethods = { eip155: i, bip122: [], solana: [] }),
                  (n.KnownWalletNamespaceRpcMethods = { eip155: o, bip122: [], solana: [] }),
                  (n.KnownNotifications = { eip155: ['eth_subscription'], bip122: [], solana: [] }),
                  (function (e) {
                    e.SolanaAccountChangedNotifications = 'solana_accountChanged_notifications';
                  })(c || (n.KnownSessionProperties = c = {}));
              };
            };
      },
      {
        package: '@metamask/multichain-api-middleware>@metamask/chain-agnostic-permission',
        file: 'node_modules/@metamask/multichain-api-middleware/node_modules/@metamask/chain-agnostic-permission/dist/scope/constants.cjs',
      },
    ],
    [
      2133,
      { '@metamask/rpc-errors': 2585 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.Caip25Errors = void 0);
                const r = e('@metamask/rpc-errors');
                n.Caip25Errors = {
                  requestedChainsNotSupportedError: () =>
                    new r.JsonRpcError(5100, 'Requested chains are not supported'),
                  requestedMethodsNotSupportedError: () =>
                    new r.JsonRpcError(5101, 'Requested methods are not supported'),
                  requestedNotificationsNotSupportedError: () =>
                    new r.JsonRpcError(5102, 'Requested notifications are not supported'),
                  unknownMethodsRequestedError: () =>
                    new r.JsonRpcError(5201, 'Unknown method(s) requested'),
                  unknownNotificationsRequestedError: () =>
                    new r.JsonRpcError(5202, 'Unknown notification(s) requested'),
                };
              };
            };
      },
      {
        package: '@metamask/multichain-api-middleware>@metamask/chain-agnostic-permission',
        file: 'node_modules/@metamask/multichain-api-middleware/node_modules/@metamask/chain-agnostic-permission/dist/scope/errors.cjs',
      },
    ],
    [
      2134,
      { './assert.cjs': 2130, './supported.cjs': 2135 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.getSupportedScopeObjects = n.bucketScopesBySupport = void 0);
                const r = e('./assert.cjs'),
                  s = e('./supported.cjs');
                n.bucketScopesBySupport = (
                  e,
                  {
                    isEvmChainIdSupported: t,
                    isNonEvmScopeSupported: n,
                    getNonEvmSupportedMethods: s,
                  }
                ) => {
                  const a = {},
                    o = {};
                  for (const [i, c] of Object.entries(e)) {
                    (0, r.assertIsInternalScopeString)(i);
                    try {
                      (0, r.assertScopeSupported)(i, c, {
                        isEvmChainIdSupported: t,
                        isNonEvmScopeSupported: n,
                        getNonEvmSupportedMethods: s,
                      }),
                        (a[i] = c);
                    } catch {
                      o[i] = c;
                    }
                  }
                  return { supportedScopes: a, unsupportedScopes: o };
                };
                const a = (e, t, { getNonEvmSupportedMethods: n }) => {
                  const { methods: r, notifications: a } = t,
                    o = r.filter(t =>
                      (0, s.isSupportedMethod)(e, t, { getNonEvmSupportedMethods: n })
                    ),
                    i = a.filter(t => (0, s.isSupportedNotification)(e, t));
                  return { ...t, methods: o, notifications: i };
                };
                n.getSupportedScopeObjects = (e, { getNonEvmSupportedMethods: t }) => {
                  const n = {};
                  for (const [s, o] of Object.entries(e))
                    (0, r.assertIsInternalScopeString)(s),
                      (n[s] = a(s, o, { getNonEvmSupportedMethods: t }));
                  return n;
                };
              };
            };
      },
      {
        package: '@metamask/multichain-api-middleware>@metamask/chain-agnostic-permission',
        file: 'node_modules/@metamask/multichain-api-middleware/node_modules/@metamask/chain-agnostic-permission/dist/scope/filter.cjs',
      },
    ],
    [
      2135,
      {
        './constants.cjs': 2132,
        './types.cjs': 2137,
        '@metamask/controller-utils': 1515,
        '@metamask/utils': 2995,
      },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.isSupportedSessionProperty =
                    n.isSupportedNotification =
                    n.isSupportedMethod =
                    n.isSupportedAccount =
                    n.isSupportedScopeString =
                      void 0);
                const r = e('@metamask/controller-utils'),
                  s = e('@metamask/utils'),
                  a = e('./constants.cjs'),
                  o = e('./types.cjs');
                n.isSupportedScopeString = (
                  e,
                  { isEvmChainIdSupported: t, isNonEvmScopeSupported: n }
                ) => {
                  const { namespace: i, reference: c } = (0, o.parseScopeString)(e);
                  switch (i) {
                    case s.KnownCaipNamespace.Wallet:
                      return !(0, s.isCaipChainId)(e) || c === s.KnownCaipNamespace.Eip155 || n(e);
                    case s.KnownCaipNamespace.Eip155:
                      return !c || (a.CaipReferenceRegexes.eip155.test(c) && t((0, r.toHex)(c)));
                    default:
                      return !!(0, s.isCaipChainId)(e) && n(e);
                  }
                };
                n.isSupportedAccount = (
                  e,
                  { getEvmInternalAccounts: t, getNonEvmAccountAddresses: n }
                ) => {
                  const {
                      address: a,
                      chainId: o,
                      chain: { namespace: i, reference: c },
                    } = (0, s.parseCaipAccountId)(e),
                    l = () =>
                      t().some(
                        e =>
                          ['eip155:eoa', 'eip155:erc4337'].includes(e.type) &&
                          (0, r.isEqualCaseInsensitive)(a, e.address)
                      ),
                    d = () => n(o).includes(e);
                  switch (i) {
                    case s.KnownCaipNamespace.Wallet:
                      return c === s.KnownCaipNamespace.Eip155 ? l() : d();
                    case s.KnownCaipNamespace.Eip155:
                      return l();
                    default:
                      return d();
                  }
                };
                n.isSupportedMethod = (e, t, { getNonEvmSupportedMethods: n }) => {
                  const { namespace: r, reference: i } = (0, o.parseScopeString)(e);
                  if (!r) return !1;
                  const c = () => (0, s.isCaipChainId)(e) && n(e).includes(t);
                  return r === s.KnownCaipNamespace.Wallet
                    ? i
                      ? i === s.KnownCaipNamespace.Eip155
                        ? a.KnownWalletNamespaceRpcMethods[i].includes(t)
                        : c()
                      : a.KnownWalletRpcMethods.includes(t)
                    : r === s.KnownCaipNamespace.Eip155
                      ? a.KnownRpcMethods[r].includes(t)
                      : c();
                };
                n.isSupportedNotification = (e, t) => {
                  const { namespace: n } = (0, o.parseScopeString)(e);
                  return n === s.KnownCaipNamespace.Eip155 && a.KnownNotifications[n].includes(t);
                };
                n.isSupportedSessionProperty = e =>
                  Object.values(a.KnownSessionProperties).includes(e);
              };
            };
      },
      {
        package: '@metamask/multichain-api-middleware>@metamask/chain-agnostic-permission',
        file: 'node_modules/@metamask/multichain-api-middleware/node_modules/@metamask/chain-agnostic-permission/dist/scope/supported.cjs',
      },
    ],
    [
      2136,
      { './types.cjs': 2137, lodash: 4921 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.normalizeAndMergeScopes =
                    n.mergeInternalScopes =
                    n.mergeNormalizedScopes =
                    n.mergeScopeObject =
                    n.normalizeScope =
                    n.getUniqueArrayItems =
                      void 0);
                const r = e('lodash'),
                  s = e('./types.cjs');
                n.getUniqueArrayItems = e => Array.from(new Set(e));
                n.normalizeScope = (e, t) => {
                  const { references: n, ...a } = t,
                    { namespace: o, reference: i } = (0, s.parseScopeString)(e),
                    c = { accounts: [], ...a };
                  return o && !i && n !== undefined && n.length > 0
                    ? Object.fromEntries(n.map(e => [`${o}:${e}`, (0, r.cloneDeep)(c)]))
                    : { [e]: c };
                };
                n.mergeScopeObject = (e, t) => {
                  const r = {
                    methods: (0, n.getUniqueArrayItems)([...e.methods, ...t.methods]),
                    notifications: (0, n.getUniqueArrayItems)([
                      ...e.notifications,
                      ...t.notifications,
                    ]),
                    accounts: (0, n.getUniqueArrayItems)([...e.accounts, ...t.accounts]),
                  };
                  return (
                    (e.rpcDocuments || t.rpcDocuments) &&
                      (r.rpcDocuments = (0, n.getUniqueArrayItems)([
                        ...(e.rpcDocuments ?? []),
                        ...(t.rpcDocuments ?? []),
                      ])),
                    (e.rpcEndpoints || t.rpcEndpoints) &&
                      (r.rpcEndpoints = (0, n.getUniqueArrayItems)([
                        ...(e.rpcEndpoints ?? []),
                        ...(t.rpcEndpoints ?? []),
                      ])),
                    r
                  );
                };
                n.mergeNormalizedScopes = (e, t) => {
                  const r = {};
                  return (
                    Object.entries(e).forEach(([e, s]) => {
                      const a = e,
                        o = t[a];
                      r[a] = o ? (0, n.mergeScopeObject)(s, o) : s;
                    }),
                    Object.entries(t).forEach(([t, n]) => {
                      const s = t;
                      e[s] || (r[s] = n);
                    }),
                    r
                  );
                };
                n.mergeInternalScopes = (e, t) => {
                  const s = (0, r.cloneDeep)(e);
                  return (
                    Object.entries(t).forEach(([e, t]) => {
                      const r = e,
                        a = s[r];
                      s[r] = a
                        ? { accounts: (0, n.getUniqueArrayItems)([...a.accounts, ...t.accounts]) }
                        : t;
                    }),
                    s
                  );
                };
                n.normalizeAndMergeScopes = e => {
                  let t = {};
                  return (
                    Object.keys(e).forEach(r => {
                      const s = (0, n.normalizeScope)(r, e[r]);
                      t = (0, n.mergeNormalizedScopes)(t, s);
                    }),
                    t
                  );
                };
              };
            };
      },
      {
        package: '@metamask/multichain-api-middleware>@metamask/chain-agnostic-permission',
        file: 'node_modules/@metamask/multichain-api-middleware/node_modules/@metamask/chain-agnostic-permission/dist/scope/transform.cjs',
      },
    ],
    [
      2137,
      { '@metamask/utils': 2995 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.parseScopeString = void 0);
                const r = e('@metamask/utils');
                n.parseScopeString = e =>
                  (0, r.isCaipNamespace)(e)
                    ? { namespace: e }
                    : (0, r.isCaipChainId)(e)
                      ? (0, r.parseCaipChainId)(e)
                      : {};
              };
            };
      },
      {
        package: '@metamask/multichain-api-middleware>@metamask/chain-agnostic-permission',
        file: 'node_modules/@metamask/multichain-api-middleware/node_modules/@metamask/chain-agnostic-permission/dist/scope/types.cjs',
      },
    ],
    [
      2138,
      { './types.cjs': 2137, '@metamask/utils': 2995 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.getValidScopes = n.isValidScope = void 0);
                const r = e('@metamask/utils'),
                  s = e('./types.cjs');
                n.isValidScope = (e, t) => {
                  const { namespace: n, reference: a } = (0, s.parseScopeString)(e);
                  if (!n) return !1;
                  const {
                    references: o,
                    methods: i,
                    notifications: c,
                    accounts: l,
                    rpcDocuments: d,
                    rpcEndpoints: u,
                    ...h
                  } = t;
                  if (!i || !c) return !1;
                  if (!('wallet' === n || a || (o && 0 !== o.length))) return !1;
                  if (o) {
                    if (a) return !1;
                    if (!o.every(e => (0, r.isCaipReference)(e))) return !1;
                  }
                  if (!i.every(e => 'string' == typeof e && '' !== e.trim())) return !1;
                  return (
                    !!c.every(e => 'string' == typeof e && '' !== e.trim()) &&
                    !(Object.keys(h).length > 0)
                  );
                };
                n.getValidScopes = (e, t) => {
                  const r = {};
                  for (const [t, s] of Object.entries(e || {}))
                    (0, n.isValidScope)(t, s) && (r[t] = { accounts: [], ...s });
                  const s = {};
                  for (const [e, r] of Object.entries(t || {}))
                    (0, n.isValidScope)(e, r) && (s[e] = { accounts: [], ...r });
                  return { validRequiredScopes: r, validOptionalScopes: s };
                };
              };
            };
      },
      {
        package: '@metamask/multichain-api-middleware>@metamask/chain-agnostic-permission',
        file: 'node_modules/@metamask/multichain-api-middleware/node_modules/@metamask/chain-agnostic-permission/dist/scope/validation.cjs',
      },
    ],
    [
      214,
      { lodash: 4921 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = void 0);
                var r = e('lodash');
                n.default = {
                  version: 10,
                  migrate(e) {
                    const t = (0, r.cloneDeep)(e);
                    t.meta.version = 10;
                    try {
                      const e = (function (e) {
                        const t = (0, r.merge)({}, e, {
                          ShapeShiftController: { shapeShiftTxList: e.shapeShiftTxList || [] },
                        });
                        return delete t.shapeShiftTxList, t;
                      })(t.data);
                      t.data = e;
                    } catch (e) {
                      console.warn(`MetaMask Migration #10${e.stack}`);
                    }
                    return Promise.resolve(t);
                  },
                };
              };
            };
      },
      { package: '$root$', file: 'app/scripts/migrations/010.js' },
    ],
    [
      215,
      { lodash: 4921 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = void 0);
                var r = e('lodash');
                n.default = {
                  version: 11,
                  migrate(e) {
                    const t = (0, r.cloneDeep)(e);
                    t.meta.version = 11;
                    try {
                      const e = (function (e) {
                        const t = e;
                        return delete t.TOSHash, delete t.isDisclaimerConfirmed, t;
                      })(t.data);
                      t.data = e;
                    } catch (e) {
                      console.warn(`MetaMask Migration #11${e.stack}`);
                    }
                    return Promise.resolve(t);
                  },
                };
              };
            };
      },
      { package: '$root$', file: 'app/scripts/migrations/011.js' },
    ],
    [
      216,
      { lodash: 4921 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = void 0);
                var r = e('lodash');
                n.default = {
                  version: 12,
                  migrate(e) {
                    const t = (0, r.cloneDeep)(e);
                    t.meta.version = 12;
                    try {
                      const e = (function (e) {
                        const t = e;
                        return (
                          t.NoticeController.noticesList.forEach(e => {
                            e.read && (e.body = '');
                          }),
                          t
                        );
                      })(t.data);
                      t.data = e;
                    } catch (e) {
                      console.warn(`MetaMask Migration #12${e.stack}`);
                    }
                    return Promise.resolve(t);
                  },
                };
              };
            };
      },
      { package: '$root$', file: 'app/scripts/migrations/012.js' },
    ],
    [
      217,
      { lodash: 4921 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = void 0);
                var r = e('lodash');
                n.default = {
                  version: 13,
                  migrate(e) {
                    const t = (0, r.cloneDeep)(e);
                    t.meta.version = 13;
                    try {
                      const e = (function (e) {
                        const t = e,
                          { config: n } = t;
                        n &&
                          n.provider &&
                          'testnet' === n.provider.type &&
                          (t.config.provider.type = 'ropsten');
                        return t;
                      })(t.data);
                      t.data = e;
                    } catch (e) {
                      console.warn(`MetaMask Migration #13${e.stack}`);
                    }
                    return Promise.resolve(t);
                  },
                };
              };
            };
      },
      { package: '$root$', file: 'app/scripts/migrations/013.js' },
    ],
    [
      218,
      { lodash: 4921 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = void 0);
                var r = e('lodash');
                n.default = {
                  version: 14,
                  migrate(e) {
                    const t = (0, r.cloneDeep)(e);
                    t.meta.version = 14;
                    try {
                      const e = (function (e) {
                        const t = e;
                        return (
                          (t.NetworkController = {}),
                          (t.NetworkController.provider = t.config.provider),
                          delete t.config.provider,
                          t
                        );
                      })(t.data);
                      t.data = e;
                    } catch (e) {
                      console.warn(`MetaMask Migration #14${e.stack}`);
                    }
                    return Promise.resolve(t);
                  },
                };
              };
            };
      },
      { package: '$root$', file: 'app/scripts/migrations/014.js' },
    ],
    [
      219,
      { '@metamask/transaction-controller': 2946, lodash: 4921 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = void 0);
                var r = e('@metamask/transaction-controller'),
                  s = e('lodash');
                n.default = {
                  version: 15,
                  migrate(e) {
                    const t = (0, s.cloneDeep)(e);
                    t.meta.version = 15;
                    try {
                      const e = (function (e) {
                        const t = e,
                          { TransactionController: n } = t;
                        if (n && n.transactions) {
                          const { transactions: e } = n;
                          t.TransactionController.transactions = e.map(e =>
                            e.err
                              ? ('Gave up submitting tx.' === e.err.message &&
                                  (e.status = r.TransactionStatus.failed),
                                e)
                              : e
                          );
                        }
                        return t;
                      })(t.data);
                      t.data = e;
                    } catch (e) {
                      console.warn(`MetaMask Migration #15${e.stack}`);
                    }
                    return Promise.resolve(t);
                  },
                };
              };
            };
      },
      { package: '$root$', file: 'app/scripts/migrations/015.js' },
    ],
    [
      22,
      {
        './assets-contract-controller-messenger': 21,
        './nft-controller-messenger': 23,
        './nft-detection-controller-messenger': 24,
        './token-rates-controller-messenger': 25,
      },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  Object.defineProperty(n, 'getAssetsContractControllerMessenger', {
                    enumerable: !0,
                    get: function () {
                      return o.getAssetsContractControllerMessenger;
                    },
                  }),
                  Object.defineProperty(n, 'getNftControllerMessenger', {
                    enumerable: !0,
                    get: function () {
                      return s.getNftControllerMessenger;
                    },
                  }),
                  Object.defineProperty(n, 'getNftDetectionControllerMessenger', {
                    enumerable: !0,
                    get: function () {
                      return a.getNftDetectionControllerMessenger;
                    },
                  }),
                  Object.defineProperty(n, 'getTokenRatesControllerMessenger', {
                    enumerable: !0,
                    get: function () {
                      return r.getTokenRatesControllerMessenger;
                    },
                  });
                var r = e('./token-rates-controller-messenger'),
                  s = e('./nft-controller-messenger'),
                  a = e('./nft-detection-controller-messenger'),
                  o = e('./assets-contract-controller-messenger');
              };
            };
      },
      { package: '$root$', file: 'app/scripts/controller-init/messengers/assets/index.ts' },
    ],
    [
      220,
      { '@metamask/transaction-controller': 2946, lodash: 4921 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = void 0);
                var r = e('@metamask/transaction-controller'),
                  s = e('lodash');
                n.default = {
                  version: 16,
                  migrate(e) {
                    const t = (0, s.cloneDeep)(e);
                    t.meta.version = 16;
                    try {
                      const e = (function (e) {
                        const t = e,
                          { TransactionController: n } = t;
                        if (n && n.transactions) {
                          const { transactions: e } = t.TransactionController;
                          t.TransactionController.transactions = e.map(e =>
                            e.err
                              ? ('transaction with the same hash was already imported.' === e.err &&
                                  ((e.status = r.TransactionStatus.submitted), delete e.err),
                                e)
                              : e
                          );
                        }
                        return t;
                      })(t.data);
                      t.data = e;
                    } catch (e) {
                      console.warn(`MetaMask Migration #16${e.stack}`);
                    }
                    return Promise.resolve(t);
                  },
                };
              };
            };
      },
      { package: '$root$', file: 'app/scripts/migrations/016.js' },
    ],
    [
      221,
      { '@metamask/transaction-controller': 2946, lodash: 4921 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = void 0);
                var r = e('@metamask/transaction-controller'),
                  s = e('lodash');
                n.default = {
                  version: 17,
                  migrate(e) {
                    const t = (0, s.cloneDeep)(e);
                    t.meta.version = 17;
                    try {
                      const e = (function (e) {
                        const t = e,
                          { TransactionController: n } = t;
                        if (n && n.transactions) {
                          const { transactions: e } = t.TransactionController;
                          t.TransactionController.transactions = e.map(
                            e => (
                              !e.status === r.TransactionStatus.failed ||
                                (e.retryCount > 0 &&
                                  e.retryCount < 2 &&
                                  ((e.status = r.TransactionStatus.submitted), delete e.err)),
                              e
                            )
                          );
                        }
                        return t;
                      })(t.data);
                      t.data = e;
                    } catch (e) {
                      console.warn(`MetaMask Migration #17${e.stack}`);
                    }
                    return Promise.resolve(t);
                  },
                };
              };
            };
      },
      { package: '$root$', file: 'app/scripts/migrations/017.js' },
    ],
    [
      222,
      { 'fast-json-patch': 4500, lodash: 4921 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = void 0);
                var r,
                  s = (r = e('fast-json-patch')) && r.__esModule ? r : { default: r },
                  a = e('lodash');
                n.default = {
                  version: 18,
                  migrate(e) {
                    const t = (0, a.cloneDeep)(e);
                    t.meta.version = 18;
                    try {
                      const e = (function (e) {
                        const t = e,
                          { TransactionController: n } = t;
                        if (n && n.transactions) {
                          const { transactions: e } = t.TransactionController;
                          t.TransactionController.transactions = e.map(e => {
                            if (!e.history || 0 === e.history.length) {
                              const t = (function (e) {
                                const t = { ...e };
                                return delete t.history, (0, a.cloneDeep)(t);
                              })(e);
                              return (e.history = [t]), e;
                            }
                            const t = ((n = e.history),
                            n.map((e, t) =>
                              0 === t
                                ? e
                                : (function (e, t, n) {
                                    const r = s.default.compare(e, t);
                                    return (
                                      r[0] && (n && (r[0].note = n), (r[0].timestamp = Date.now())),
                                      r
                                    );
                                  })(n[t - 1], e)
                            )).filter(e => !Array.isArray(e) || e.length > 0);
                            var n;
                            return (e.history = t), e;
                          });
                        }
                        return t;
                      })(t.data);
                      t.data = e;
                    } catch (e) {
                      console.warn(`MetaMask Migration #18${e.stack}`);
                    }
                    return Promise.resolve(t);
                  },
                };
              };
            };
      },
      { package: '$root$', file: 'app/scripts/migrations/018.js' },
    ],
    [
      223,
      { '@metamask/transaction-controller': 2946, lodash: 4921 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = void 0);
                var r = e('@metamask/transaction-controller'),
                  s = e('lodash');
                n.default = {
                  version: 19,
                  migrate(e) {
                    const t = (0, s.cloneDeep)(e);
                    t.meta.version = 19;
                    try {
                      const e = (function (e) {
                        const t = e,
                          { TransactionController: n } = t;
                        if (n && n.transactions) {
                          const { transactions: e } = t.TransactionController;
                          t.TransactionController.transactions = e.map((e, t, n) => {
                            if (e.status !== r.TransactionStatus.submitted) return e;
                            const s = (function (e) {
                                const t = e.map(e => {
                                  const { nonce: t } = e.txParams;
                                  return parseInt(t || '0x0', 16);
                                });
                                return Math.max.apply(null, t);
                              })(
                                n
                                  .filter(e => e.status === r.TransactionStatus.confirmed)
                                  .filter(t => t.txParams.from === e.txParams.from)
                                  .filter(
                                    t => t.metamaskNetworkId.from === e.metamaskNetworkId.from
                                  )
                              ),
                              a = (function (e, t) {
                                const n = e.map(e => {
                                  const { nonce: t } = e.txParams;
                                  return parseInt(t, 16);
                                });
                                let r = t;
                                for (; n.includes(r); ) r += 1;
                                return r;
                              })(
                                n
                                  .filter(e => e.status === r.TransactionStatus.submitted)
                                  .filter(t => t.txParams.from === e.txParams.from)
                                  .filter(
                                    t => t.metamaskNetworkId.from === e.metamaskNetworkId.from
                                  ),
                                s
                              ),
                              o = Math.max(a, s);
                            return (
                              parseInt(e.txParams.nonce, 16) > o + 1 &&
                                ((e.status = r.TransactionStatus.failed),
                                (e.err = {
                                  message: 'nonce too high',
                                  note: 'migration 019 custom error',
                                })),
                              e
                            );
                          });
                        }
                        return t;
                      })(t.data);
                      t.data = e;
                    } catch (e) {
                      console.warn(`MetaMask Migration #19${e.stack}`);
                    }
                    return Promise.resolve(t);
                  },
                };
              };
            };
      },
      { package: '$root$', file: 'app/scripts/migrations/019.js' },
    ],
    [
      224,
      { lodash: 4921 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = void 0);
                var r = e('lodash');
                n.default = {
                  version: 20,
                  migrate(e) {
                    const t = (0, r.cloneDeep)(e);
                    t.meta.version = 20;
                    try {
                      const e = (function (e) {
                        const t = e;
                        'metamask' in t &&
                          !('firstTimeInfo' in t.metamask) &&
                          (t.metamask.firstTimeInfo = { version: '3.12.0', date: Date.now() });
                        return t;
                      })(t.data);
                      t.data = e;
                    } catch (e) {
                      console.warn(`MetaMask Migration #20${e.stack}`);
                    }
                    return Promise.resolve(t);
                  },
                };
              };
            };
      },
      { package: '$root$', file: 'app/scripts/migrations/020.js' },
    ],
    [
      225,
      { lodash: 4921 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = void 0);
                var r = e('lodash');
                n.default = {
                  version: 21,
                  migrate(e) {
                    const t = (0, r.cloneDeep)(e);
                    t.meta.version = 21;
                    try {
                      const e = (function (e) {
                        const t = e;
                        return delete t.BlacklistController, delete t.RecentBlocks, t;
                      })(t.data);
                      t.data = e;
                    } catch (e) {
                      console.warn(`MetaMask Migration #21${e.stack}`);
                    }
                    return Promise.resolve(t);
                  },
                };
              };
            };
      },
      { package: '$root$', file: 'app/scripts/migrations/021.js' },
    ],
    [
      226,
      { '@metamask/transaction-controller': 2946, lodash: 4921 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = void 0);
                var r = e('@metamask/transaction-controller'),
                  s = e('lodash');
                n.default = {
                  version: 22,
                  migrate(e) {
                    const t = (0, s.cloneDeep)(e);
                    t.meta.version = 22;
                    try {
                      const e = (function (e) {
                        const t = e,
                          { TransactionController: n } = t;
                        if (n && n.transactions) {
                          const { transactions: e } = t.TransactionController;
                          t.TransactionController.transactions = e.map(
                            e => (
                              e.status !== r.TransactionStatus.submitted ||
                                e.submittedTime ||
                                (e.submittedTime = new Date().getTime()),
                              e
                            )
                          );
                        }
                        return t;
                      })(t.data);
                      t.data = e;
                    } catch (e) {
                      console.warn(`MetaMask Migration #22${e.stack}`);
                    }
                    return Promise.resolve(t);
                  },
                };
              };
            };
      },
      { package: '$root$', file: 'app/scripts/migrations/022.js' },
    ],
    [
      227,
      { '@metamask/transaction-controller': 2946, lodash: 4921 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = void 0);
                var r = e('lodash'),
                  s = e('@metamask/transaction-controller');
                n.default = {
                  version: 23,
                  migrate(e) {
                    const t = (0, r.cloneDeep)(e);
                    t.meta.version = 23;
                    try {
                      const e = (function (e) {
                        const t = e,
                          { TransactionController: n } = t;
                        if (n && n.transactions) {
                          const { transactions: e } = t.TransactionController;
                          if (e.length <= 40) return t;
                          const n = e.reverse();
                          let r = !0;
                          for (; n.length > 40 && r; ) {
                            const e = n.findIndex(
                              e =>
                                e.status === s.TransactionStatus.failed ||
                                e.status === s.TransactionStatus.rejected ||
                                e.status === s.TransactionStatus.confirmed ||
                                e.status === s.TransactionStatus.dropped
                            );
                            e < 0 ? (r = !1) : n.splice(e, 1);
                          }
                          t.TransactionController.transactions = n.reverse();
                        }
                        return t;
                      })(t.data);
                      t.data = e;
                    } catch (e) {
                      console.warn(`MetaMask Migration #23${e.stack}`);
                    }
                    return Promise.resolve(t);
                  },
                };
              };
            };
      },
      { package: '$root$', file: 'app/scripts/migrations/023.js' },
    ],
    [
      228,
      { '@metamask/transaction-controller': 2946, lodash: 4921 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = void 0);
                var r = e('lodash'),
                  s = e('@metamask/transaction-controller');
                n.default = {
                  version: 24,
                  async migrate(e) {
                    const t = (0, r.cloneDeep)(e);
                    t.meta.version = 24;
                    const n = (function (e) {
                      const t = e;
                      if (!t.TransactionController) return t;
                      const { transactions: n } = t.TransactionController;
                      return (
                        (t.TransactionController.transactions = n.map(
                          (e, t) => (
                            e.status === s.TransactionStatus.unapproved &&
                              e.txParams &&
                              e.txParams.from &&
                              (e.txParams.from = e.txParams.from.toLowerCase()),
                            e
                          )
                        )),
                        t
                      );
                    })(t.data);
                    return (t.data = n), t;
                  },
                };
              };
            };
      },
      { package: '$root$', file: 'app/scripts/migrations/024.js' },
    ],
    [
      229,
      { '../lib/util': 204, '@metamask/transaction-controller': 2946, lodash: 4921 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = void 0);
                var r = e('lodash'),
                  s = e('@metamask/transaction-controller'),
                  a = e('../lib/util');
                n.default = {
                  version: 25,
                  async migrate(e) {
                    const t = (0, r.cloneDeep)(e);
                    t.meta.version = 25;
                    const n = (function (e) {
                      const t = e;
                      if (t.TransactionController && t.TransactionController.transactions) {
                        const { transactions: e } = t.TransactionController;
                        t.TransactionController.transactions = e.map(
                          e => (
                            e.status !== s.TransactionStatus.unapproved ||
                              (e.txParams = (function (e) {
                                const t = {
                                    from: e => (0, a.addHexPrefix)(e).toLowerCase(),
                                    to: () => (0, a.addHexPrefix)(e.to).toLowerCase(),
                                    nonce: e => (0, a.addHexPrefix)(e),
                                    value: e => (0, a.addHexPrefix)(e),
                                    data: e => (0, a.addHexPrefix)(e),
                                    gas: e => (0, a.addHexPrefix)(e),
                                    gasPrice: e => (0, a.addHexPrefix)(e),
                                  },
                                  n = {};
                                return (
                                  Object.keys(t).forEach(r => {
                                    e[r] && (n[r] = t[r](e[r]));
                                  }),
                                  n
                                );
                              })(e.txParams)),
                            e
                          )
                        );
                      }
                      return t;
                    })(t.data);
                    return (t.data = n), t;
                  },
                };
              };
            };
      },
      { package: '$root$', file: 'app/scripts/migrations/025.js' },
    ],
    [
      23,
      {},
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.getNftControllerMessenger = function (e) {
                    return e.getRestricted({
                      name: 'NftController',
                      allowedEvents: [
                        'PreferencesController:stateChange',
                        'NetworkController:networkDidChange',
                        'AccountsController:selectedEvmAccountChange',
                      ],
                      allowedActions: [
                        'ApprovalController:addRequest',
                        'NetworkController:getNetworkClientById',
                        'AccountsController:getSelectedAccount',
                        'AccountsController:getAccount',
                        'AssetsContractController:getERC721AssetName',
                        'AssetsContractController:getERC721AssetSymbol',
                        'AssetsContractController:getERC721TokenURI',
                        'AssetsContractController:getERC721OwnerOf',
                        'AssetsContractController:getERC1155BalanceOf',
                        'AssetsContractController:getERC1155TokenURI',
                      ],
                    });
                  });
              };
            };
      },
      {
        package: '$root$',
        file: 'app/scripts/controller-init/messengers/assets/nft-controller-messenger.ts',
      },
    ],
    [
      230,
      { lodash: 4921 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = void 0);
                var r = e('lodash');
                n.default = {
                  version: 26,
                  migrate(e) {
                    const t = (0, r.cloneDeep)(e);
                    t.meta.version = 26;
                    try {
                      const e = t.data;
                      t.data = (function (e) {
                        if (!e.KeyringController || !e.PreferencesController) return e;
                        if (!e.KeyringController.walletNicknames) return e;
                        return (
                          (e.PreferencesController.identities = Object.keys(
                            e.KeyringController.walletNicknames
                          ).reduce(
                            (t, n) => (
                              (t[n] = { name: e.KeyringController.walletNicknames[n], address: n }),
                              t
                            ),
                            {}
                          )),
                          delete e.KeyringController.walletNicknames,
                          e
                        );
                      })(e);
                    } catch (e) {
                      return console.warn(`MetaMask Migration #26${e.stack}`), Promise.reject(e);
                    }
                    return Promise.resolve(t);
                  },
                };
              };
            };
      },
      { package: '$root$', file: 'app/scripts/migrations/026.js' },
    ],
    [
      231,
      { '@metamask/transaction-controller': 2946, lodash: 4921 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = void 0);
                var r = e('lodash'),
                  s = e('@metamask/transaction-controller');
                n.default = {
                  version: 27,
                  async migrate(e) {
                    const t = (0, r.cloneDeep)(e);
                    t.meta.version = 27;
                    const n = (function (e) {
                      const t = e;
                      if (t.TransactionController && t.TransactionController.transactions) {
                        const { transactions: e } = t.TransactionController;
                        t.TransactionController.transactions = e.filter(
                          e => e.status !== s.TransactionStatus.rejected
                        );
                      }
                      return t;
                    })(t.data);
                    return (t.data = n), t;
                  },
                };
              };
            };
      },
      { package: '$root$', file: 'app/scripts/migrations/027.js' },
    ],
    [
      232,
      { lodash: 4921 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = void 0);
                var r = e('lodash');
                n.default = {
                  version: 28,
                  async migrate(e) {
                    const t = (0, r.cloneDeep)(e);
                    t.meta.version = 28;
                    const n = (function (e) {
                      const t = e;
                      if (
                        t.PreferencesController &&
                        t.PreferencesController.tokens &&
                        t.PreferencesController.identities
                      ) {
                        const { identities: e, tokens: n } = t.PreferencesController;
                        (t.PreferencesController.accountTokens = {}),
                          Object.keys(e).forEach(e => {
                            t.PreferencesController.accountTokens[e] = { mainnet: n };
                          }),
                          (t.PreferencesController.tokens = []);
                      }
                      return t;
                    })(t.data);
                    return (t.data = n), t;
                  },
                };
              };
            };
      },
      { package: '$root$', file: 'app/scripts/migrations/028.js' },
    ],
    [
      233,
      { './fail-tx': 380, '@metamask/transaction-controller': 2946 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = void 0);
                var r,
                  s = e('@metamask/transaction-controller'),
                  a = (r = e('./fail-tx')) && r.__esModule ? r : { default: r };
                n.default = {
                  version: 29,
                  migrate: (0, a.default)(29, 'Stuck in approved state for too long.', e => {
                    const t = e.status === s.TransactionStatus.approved,
                      n = e.submittedTime,
                      r = Date.now();
                    return t && r - n > 432e5;
                  }),
                };
              };
            };
      },
      { package: '$root$', file: 'app/scripts/migrations/029.js' },
    ],
    [
      234,
      { lodash: 4921 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = void 0);
                var r = e('lodash');
                n.default = {
                  version: 30,
                  async migrate(e) {
                    const t = (0, r.cloneDeep)(e);
                    t.meta.version = 30;
                    const n = (function (e) {
                      const t = e;
                      if (e.PreferencesController) {
                        const { frequentRpcListDetail: e } = t.PreferencesController;
                        e &&
                          (e.forEach((t, n) => {
                            Boolean(t.chainId) &&
                              Number.isNaN(parseInt(t.chainId)) &&
                              delete e[n].chainId;
                          }),
                          (t.PreferencesController.frequentRpcListDetail = e));
                      }
                      e.NetworkController &&
                        (t.NetworkController.network &&
                          Number.isNaN(parseInt(t.NetworkController.network)) &&
                          delete t.NetworkController.network,
                        t.NetworkController.provider &&
                          t.NetworkController.provider.chainId &&
                          Number.isNaN(parseInt(t.NetworkController.provider.chainId)) &&
                          delete t.NetworkController.provider.chainId);
                      return t;
                    })(t.data);
                    return (t.data = n), t;
                  },
                };
              };
            };
      },
      { package: '$root$', file: 'app/scripts/migrations/030.js' },
    ],
    [
      235,
      { lodash: 4921 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = void 0);
                var r = e('lodash');
                n.default = {
                  version: 31,
                  async migrate(e) {
                    const t = (0, r.cloneDeep)(e);
                    t.meta.version = 31;
                    const n = (function (e) {
                      const { KeyringController: t, PreferencesController: n } = e;
                      if (t && n) {
                        const { vault: e } = t;
                        n.completedOnboarding = Boolean(e);
                      }
                      return e;
                    })(t.data);
                    return (t.data = n), t;
                  },
                };
              };
            };
      },
      { package: '$root$', file: 'app/scripts/migrations/031.js' },
    ],
    [
      236,
      { lodash: 4921 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = void 0);
                var r = e('lodash');
                n.default = {
                  version: 32,
                  async migrate(e) {
                    const t = (0, r.cloneDeep)(e);
                    t.meta.version = 32;
                    const n = t.data;
                    return (
                      (t.data = (function (e) {
                        const { PreferencesController: t } = e;
                        if (t) {
                          const { betaUI: e } = t.featureFlags || {};
                          t.completedUiMigration = e;
                        }
                        return e;
                      })(n)),
                      t
                    );
                  },
                };
              };
            };
      },
      { package: '$root$', file: 'app/scripts/migrations/032.js' },
    ],
    [
      237,
      { lodash: 4921 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = void 0);
                var r = e('lodash');
                n.default = {
                  version: 33,
                  async migrate(e) {
                    const t = (0, r.cloneDeep)(e);
                    t.meta.version = 33;
                    const n = (function (e) {
                      const t = e;
                      e.NoticeController && delete t.NoticeController;
                      return t;
                    })(t.data);
                    return (t.data = n), t;
                  },
                };
              };
            };
      },
      { package: '$root$', file: 'app/scripts/migrations/033.js' },
    ],
    [
      238,
      { lodash: 4921 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = void 0);
                var r = e('lodash');
                n.default = {
                  version: 34,
                  async migrate(e) {
                    const t = (0, r.cloneDeep)(e);
                    t.meta.version = 34;
                    const n = t.data;
                    return (
                      (t.data = (function (e) {
                        const { PreferencesController: t } = e;
                        if (t) {
                          const e = t.featureFlags || {};
                          e.privacyMode ||
                            void 0 !== t.migratedPrivacyMode ||
                            ((t.migratedPrivacyMode = !0), (e.privacyMode = !0));
                        }
                        return e;
                      })(n)),
                      t
                    );
                  },
                };
              };
            };
      },
      { package: '$root$', file: 'app/scripts/migrations/034.js' },
    ],
    [
      239,
      { lodash: 4921 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = void 0);
                var r = e('lodash');
                n.default = {
                  version: 35,
                  async migrate(e) {
                    const t = (0, r.cloneDeep)(e);
                    return (
                      (t.meta.version = 35),
                      (t.data = (function (e) {
                        e.PreferencesController &&
                          e.PreferencesController.seedWords !== undefined &&
                          delete e.PreferencesController.seedWords;
                        return e;
                      })(t.data)),
                      t
                    );
                  },
                };
              };
            };
      },
      { package: '$root$', file: 'app/scripts/migrations/035.js' },
    ],
    [
      2399,
      { './push-utils.cjs': 2400 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.createSubscribeToPushNotifications =
                    n.deleteRegToken =
                    n.createRegToken =
                      void 0);
                var r = e('./push-utils.cjs');
                Object.defineProperty(n, 'createRegToken', {
                  enumerable: !0,
                  get: function () {
                    return r.createRegToken;
                  },
                }),
                  Object.defineProperty(n, 'deleteRegToken', {
                    enumerable: !0,
                    get: function () {
                      return r.deleteRegToken;
                    },
                  }),
                  Object.defineProperty(n, 'createSubscribeToPushNotifications', {
                    enumerable: !0,
                    get: function () {
                      return r.createSubscribeToPushNotifications;
                    },
                  });
              };
            };
      },
      {
        package: '@metamask/notification-services-controller',
        file: 'node_modules/@metamask/notification-services-controller/dist/NotificationServicesPushController/web/index.cjs',
      },
    ],
    [
      24,
      {},
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.getNftDetectionControllerMessenger = function (e) {
                    return e.getRestricted({
                      name: 'NftDetectionController',
                      allowedEvents: [
                        'NetworkController:stateChange',
                        'PreferencesController:stateChange',
                      ],
                      allowedActions: [
                        'ApprovalController:addRequest',
                        'NetworkController:getState',
                        'NetworkController:getNetworkClientById',
                        'AccountsController:getSelectedAccount',
                      ],
                    });
                  });
              };
            };
      },
      {
        package: '$root$',
        file: 'app/scripts/controller-init/messengers/assets/nft-detection-controller-messenger.ts',
      },
    ],
    [
      240,
      { lodash: 4921 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = void 0);
                var r = e('lodash');
                n.default = {
                  version: 36,
                  async migrate(e) {
                    const t = (0, r.cloneDeep)(e);
                    t.meta.version = 36;
                    const n = t.data;
                    return (
                      (t.data = (function (e) {
                        const { PreferencesController: t } = e;
                        if (t) {
                          const e = t.featureFlags || {};
                          void 0 !== e.privacyMode && delete e.privacyMode;
                        }
                        return e;
                      })(n)),
                      t
                    );
                  },
                };
              };
            };
      },
      { package: '$root$', file: 'app/scripts/migrations/036.js' },
    ],
    [
      2400,
      {
        '../../NotificationServicesController/index.cjs': 2372,
        '../../shared/to-raw-notification.cjs': 2404,
        'firebase/app': 4515,
        'firebase/messaging': 4516,
        'firebase/messaging/sw': 4517,
        loglevel: 4929,
      },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                var r =
                  (this && this.__importDefault) ||
                  function (e) {
                    return e && e.__esModule ? e : { default: e };
                  };
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.createSubscribeToPushNotifications =
                    n.deleteRegToken =
                    n.createRegToken =
                    n.supportedCache =
                      void 0);
                const s = e('firebase/app'),
                  a = e('firebase/messaging'),
                  o = e('firebase/messaging/sw'),
                  i = r(e('loglevel')),
                  c = e('../../NotificationServicesController/index.cjs'),
                  l = e('../../shared/to-raw-notification.cjs');
                n.supportedCache = null;
                const d = async e => {
                  if (
                    !(await (async () => (
                      n.supportedCache ?? (n.supportedCache = await (0, o.isSupported)()),
                      n.supportedCache
                    ))())
                  )
                    return null;
                  const t = await (async e => {
                    try {
                      return (0, s.getApp)();
                    } catch {
                      const t = {
                        apiKey: e.apiKey,
                        authDomain: e.authDomain,
                        storageBucket: e.storageBucket,
                        projectId: e.projectId,
                        messagingSenderId: e.messagingSenderId,
                        appId: e.appId,
                        measurementId: e.measurementId,
                      };
                      return (0, s.initializeApp)(t);
                    }
                  })(e);
                  return (0, o.getMessaging)(t);
                };
                (n.createRegToken = async function (e) {
                  try {
                    const t = await d(e);
                    if (!t) return null;
                    return await (0, a.getToken)(t, {
                      serviceWorkerRegistration: self.registration,
                      vapidKey: e.vapidKey,
                    });
                  } catch {
                    return null;
                  }
                }),
                  (n.deleteRegToken = async function (e) {
                    try {
                      const t = await d(e);
                      return !t || (await (0, a.deleteToken)(t), !0);
                    } catch {
                      return !1;
                    }
                  }),
                  (n.createSubscribeToPushNotifications = function (e) {
                    return async function (t) {
                      const n = await (async function (e, t) {
                          const n = await d(e);
                          if (!n) return null;
                          const r = (0, o.onBackgroundMessage)(n, async e => {
                            try {
                              const n = e?.data?.data ? JSON.parse(e?.data?.data) : undefined;
                              if (!n) return;
                              const r = (0, l.toRawOnChainNotification)(n),
                                s = c.Processors.processNotification(r);
                              await t(s);
                            } catch (t) {
                              throw (
                                (i.default.error('Unable to send push notification:', {
                                  notification: e?.data?.data,
                                  error: t,
                                }),
                                new Error('Unable to send push notification'))
                              );
                            }
                          });
                          return () => r();
                        })(t, async t => {
                          e.messenger.publish(
                            'NotificationServicesPushController:onNewNotifications',
                            t
                          ),
                            await e.onReceivedHandler(t);
                        }),
                        r = (function (e) {
                          const t = t => {
                            const n = t?.notification?.data;
                            e(t, n);
                          };
                          return (
                            self.addEventListener('notificationclick', t),
                            () => self.removeEventListener('notificationclick', t)
                          );
                        })((t, n) => {
                          e.messenger.publish(
                            'NotificationServicesPushController:pushNotificationClicked',
                            n
                          ),
                            e.onClickHandler(t, n);
                        });
                      return () => {
                        n?.(), r();
                      };
                    };
                  });
              };
            };
      },
      {
        package: '@metamask/notification-services-controller',
        file: 'node_modules/@metamask/notification-services-controller/dist/NotificationServicesPushController/web/push-utils.cjs',
      },
    ],
    [
      241,
      { '@metamask/controller-utils': 1515, lodash: 4921 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = void 0);
                var r = e('lodash'),
                  s = e('@metamask/controller-utils');
                n.default = {
                  version: 37,
                  async migrate(e) {
                    const t = (0, r.cloneDeep)(e);
                    t.meta.version = 37;
                    const n = t.data;
                    return (
                      (t.data = (function (e) {
                        if (e.AddressBookController) {
                          const t = e.AddressBookController.addressBook,
                            n = new Set(),
                            r = {};
                          Object.values(t).forEach(e => {
                            n.add(e.chainId);
                          });
                          for (const e of n.values()) {
                            r[e] = {};
                            for (const n in t)
                              t[n].chainId === e &&
                                ((t[n].isEns = !1),
                                (0, s.normalizeEnsName)(t[n].name) && (t[n].isEns = !0),
                                (r[e][n] = t[n]));
                          }
                          e.AddressBookController.addressBook = r;
                        }
                        return e;
                      })(n)),
                      t
                    );
                  },
                };
              };
            };
      },
      { package: '$root$', file: 'app/scripts/migrations/037.js' },
    ],
    [
      2410,
      { './ObservableStore': 2412 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.ComposedStore = void 0);
                const r = e('./ObservableStore');
                class s extends r.ObservableStore {
                  constructor(e) {
                    super({}),
                      (this._children = e || {}),
                      Object.keys(this._children).forEach(e => {
                        const t = this._children[e];
                        this._addChild(e, t);
                      });
                  }
                  _addChild(e, t) {
                    const n = t => {
                      const n = this.getState();
                      (n[e] = t), this.putState(n);
                    };
                    t.subscribe(n), n(t.getState());
                  }
                }
                n.ComposedStore = s;
              };
            };
      },
      {
        package: '@metamask/obs-store',
        file: 'node_modules/@metamask/obs-store/dist/ComposedStore.js',
      },
    ],
    [
      2411,
      { './ObservableStore': 2412 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.MergedStore = void 0);
                const r = e('./ObservableStore');
                class s extends r.ObservableStore {
                  constructor(e = []) {
                    super({}),
                      (this._children = e),
                      e.forEach(e => this._addChild(e)),
                      this._updateWholeState();
                  }
                  _addChild(e) {
                    e.subscribe(() => this._updateWholeState());
                  }
                  _updateWholeState() {
                    const e = this._children.map(e => e.getState()),
                      t = Object.assign({}, ...e);
                    this.putState(t);
                  }
                }
                n.MergedStore = s;
              };
            };
      },
      {
        package: '@metamask/obs-store',
        file: 'node_modules/@metamask/obs-store/dist/MergedStore.js',
      },
    ],
    [
      2412,
      { '@metamask/safe-event-emitter': 2587 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                var r =
                  (this && this.__importDefault) ||
                  function (e) {
                    return e && e.__esModule ? e : { default: e };
                  };
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.ObservableStore = void 0);
                const s = r(e('@metamask/safe-event-emitter'));
                class a extends s.default {
                  constructor(e) {
                    super(), e === undefined ? (this._state = {}) : (this._state = e);
                  }
                  getState() {
                    return this._getState();
                  }
                  putState(e) {
                    this._putState(e), this.emit('update', e);
                  }
                  updateState(e) {
                    if (e && 'object' == typeof e) {
                      const t = this.getState();
                      this.putState(Object.assign(Object.assign({}, t), e));
                    } else this.putState(e);
                  }
                  subscribe(e) {
                    this.on('update', e);
                  }
                  unsubscribe(e) {
                    this.removeListener('update', e);
                  }
                  _getState() {
                    return this._state;
                  }
                  _putState(e) {
                    this._state = e;
                  }
                }
                n.ObservableStore = a;
              };
            };
      },
      {
        package: '@metamask/obs-store',
        file: 'node_modules/@metamask/obs-store/dist/ObservableStore.js',
      },
    ],
    [
      2413,
      { 'readable-stream': 5343 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.storeAsStream = void 0);
                const r = e('readable-stream');
                class s extends r.Duplex {
                  constructor(e) {
                    super({ objectMode: !0 }),
                      this.resume(),
                      (this.handler = e => this.push(e)),
                      (this.obsStore = e),
                      this.obsStore.subscribe(this.handler);
                  }
                  pipe(e, t) {
                    const n = super.pipe(e, t);
                    return e.write(this.obsStore.getState()), n;
                  }
                  _write(e, t, n) {
                    this.obsStore.putState(e), n();
                  }
                  _read(e) {
                    return undefined;
                  }
                  _destroy(e, t) {
                    this.obsStore.unsubscribe(this.handler), super._destroy(e, t);
                  }
                }
                n.storeAsStream = function (e) {
                  return new s(e);
                };
              };
            };
      },
      { package: '@metamask/obs-store', file: 'node_modules/@metamask/obs-store/dist/asStream.js' },
    ],
    [
      2414,
      {
        './ComposedStore': 2410,
        './MergedStore': 2411,
        './ObservableStore': 2412,
        './asStream': 2413,
        './transform': 2415,
      },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                var r =
                    (this && this.__createBinding) ||
                    (Object.create
                      ? function (e, t, n, r) {
                          r === undefined && (r = n),
                            Object.defineProperty(e, r, {
                              enumerable: !0,
                              get: function () {
                                return t[n];
                              },
                            });
                        }
                      : function (e, t, n, r) {
                          r === undefined && (r = n), (e[r] = t[n]);
                        }),
                  s =
                    (this && this.__exportStar) ||
                    function (e, t) {
                      for (var n in e)
                        'default' === n || Object.prototype.hasOwnProperty.call(t, n) || r(t, e, n);
                    };
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  s(e('./asStream'), n),
                  s(e('./ComposedStore'), n),
                  s(e('./MergedStore'), n),
                  s(e('./ObservableStore'), n),
                  s(e('./transform'), n);
              };
            };
      },
      { package: '@metamask/obs-store', file: 'node_modules/@metamask/obs-store/dist/index.js' },
    ],
    [
      2415,
      { 'readable-stream': 5343 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.storeTransformStream = void 0);
                const r = e('readable-stream');
                n.storeTransformStream = function (e) {
                  return new r.Transform({
                    objectMode: !0,
                    transform: (t, n, r) => {
                      try {
                        const n = e(t);
                        return r(undefined, n), undefined;
                      } catch (e) {
                        return r(e), undefined;
                      }
                    },
                  });
                };
              };
            };
      },
      {
        package: '@metamask/obs-store',
        file: 'node_modules/@metamask/obs-store/dist/transform.js',
      },
    ],
    [
      242,
      { lodash: 4921 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = void 0);
                var r = e('lodash');
                n.default = {
                  version: 38,
                  async migrate(e) {
                    const t = (0, r.cloneDeep)(e);
                    t.meta.version = 38;
                    const n = t.data;
                    return (
                      (t.data = (function (e) {
                        const { ABTestController: t = {} } = e,
                          { abTests: n = {} } = t;
                        if (n.fullScreenVsPopup) return e;
                        return {
                          ...e,
                          ABTestController: {
                            ...t,
                            abTests: { ...n, fullScreenVsPopup: 'control' },
                          },
                        };
                      })(n)),
                      t
                    );
                  },
                };
              };
            };
      },
      { package: '$root$', file: 'app/scripts/migrations/038.js' },
    ],
    [
      2428,
      { './enums.cjs': 2429, '@metamask/base-controller': 1407, '@metamask/utils': 2995 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                var r,
                  s,
                  a,
                  o,
                  i,
                  c,
                  l,
                  d,
                  u,
                  h =
                    (this && this.__classPrivateFieldSet) ||
                    function (e, t, n, r, s) {
                      if ('m' === r) throw new TypeError('Private method is not writable');
                      if ('a' === r && !s)
                        throw new TypeError('Private accessor was defined without a setter');
                      if ('function' == typeof t ? e !== t || !s : !t.has(e))
                        throw new TypeError(
                          'Cannot write private member to an object whose class did not declare it'
                        );
                      return 'a' === r ? s.call(e, n) : s ? (s.value = n) : t.set(e, n), n;
                    },
                  p =
                    (this && this.__classPrivateFieldGet) ||
                    function (e, t, n, r) {
                      if ('a' === n && !r)
                        throw new TypeError('Private accessor was defined without a getter');
                      if ('function' == typeof t ? e !== t || !r : !t.has(e))
                        throw new TypeError(
                          'Cannot read private member from an object whose class did not declare it'
                        );
                      return 'm' === n ? r : 'a' === n ? r.call(e) : r ? r.value : t.get(e);
                    };
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.PermissionLogController = void 0);
                const m = e('@metamask/base-controller'),
                  f = e('@metamask/utils'),
                  g = e('./enums.cjs'),
                  b = { permissionHistory: {}, permissionActivityLog: [] };
                class y extends m.BaseController {
                  constructor({ messenger: e, restrictedMethods: t, state: n }) {
                    super({
                      messenger: e,
                      name: 'PermissionLogController',
                      metadata: {
                        permissionHistory: { persist: !0, anonymous: !1 },
                        permissionActivityLog: { persist: !0, anonymous: !1 },
                      },
                      state: { ...b, ...n },
                    }),
                      r.add(this),
                      s.set(this, void 0),
                      h(this, s, t, 'f');
                  }
                  updateAccountsHistory(e, t) {
                    if (0 === t.length) return;
                    const n = {
                      eth_accounts: { accounts: p(this, r, 'm', a).call(this, t, Date.now()) },
                    };
                    p(this, r, 'm', l).call(this, e, n);
                  }
                  createMiddleware() {
                    return (e, t, n) => {
                      const { origin: a, method: l } = e,
                        u = l.startsWith(g.WALLET_PREFIX),
                        h = 'eth_requestAccounts' === l;
                      if (
                        (!g.LOG_IGNORE_METHODS.includes(l) && (u || p(this, s, 'f').has(l))) ||
                        h
                      ) {
                        const s = p(this, r, 'm', o).call(this, e, u),
                          l = p(this, r, 'm', d).call(this, e);
                        n(e => {
                          const n = Date.now();
                          p(this, r, 'm', i).call(this, s, t, n),
                            l &&
                              !t.error &&
                              t.result &&
                              a &&
                              p(this, r, 'm', c).call(this, l, a, t.result, n, h),
                            e();
                        });
                      } else n();
                    };
                  }
                }
                (n.PermissionLogController = y),
                  (s = new WeakMap()),
                  (r = new WeakSet()),
                  (a = function (e, t) {
                    return e.reduce((e, n) => ({ ...e, [n]: t }), {});
                  }),
                  (o = function (e, t) {
                    const n = {
                      id: e.id,
                      method: e.method,
                      methodType: t ? g.LOG_METHOD_TYPES.internal : g.LOG_METHOD_TYPES.restricted,
                      origin: e.origin,
                      requestTime: Date.now(),
                      responseTime: null,
                      success: null,
                    };
                    return (
                      this.update(e => {
                        const t = [...e.permissionActivityLog, n];
                        e.permissionActivityLog = t.length > g.LOG_LIMIT ? t.slice(1) : t;
                      }),
                      n
                    );
                  }),
                  (i = function (e, t, n) {
                    e &&
                      t &&
                      this.update(r => {
                        r.permissionActivityLog = r.permissionActivityLog.map(r =>
                          r.id === e.id
                            ? { ...r, success: (0, f.hasProperty)(t, 'result'), responseTime: n }
                            : r
                        );
                      });
                  }),
                  (c = function (e, t, n, s, o) {
                    let i;
                    if (o) {
                      const e = n;
                      i = {
                        eth_accounts: {
                          accounts: p(this, r, 'm', a).call(this, e, s),
                          lastApproved: s,
                        },
                      };
                    } else {
                      i = n.reduce((t, n) => {
                        const o = n.parentCapability;
                        if (!e.includes(o)) return t;
                        if ('eth_accounts' === o) {
                          const e = p(this, r, 'm', u).call(this, n);
                          return {
                            ...t,
                            [o]: { lastApproved: s, accounts: p(this, r, 'm', a).call(this, e, s) },
                          };
                        }
                        return { ...t, [o]: { lastApproved: s } };
                      }, {});
                    }
                    Object.keys(i).length > 0 && p(this, r, 'm', l).call(this, t, i);
                  }),
                  (l = function (e, t) {
                    const { permissionHistory: n } = this.state,
                      r = n[e] ?? {},
                      s = { ...r, ...t },
                      a = r.eth_accounts,
                      o = t.eth_accounts;
                    if (a && o) {
                      const e = o.lastApproved ?? a.lastApproved;
                      s.eth_accounts = {
                        lastApproved: e,
                        accounts: { ...a.accounts, ...o.accounts },
                      };
                    }
                    this.update(t => {
                      t.permissionHistory = { ...n, [e]: s };
                    });
                  }),
                  (d = function (e) {
                    const { method: t, params: n } = e;
                    return 'eth_requestAccounts' === t
                      ? ['eth_accounts']
                      : t === `${g.WALLET_PREFIX}requestPermissions` &&
                          n &&
                          Array.isArray(n) &&
                          n[0] &&
                          'object' == typeof n[0] &&
                          !Array.isArray(n[0])
                        ? Object.keys(n[0])
                        : null;
                  }),
                  (u = function (e) {
                    if ('eth_accounts' !== e.parentCapability || !e.caveats) return [];
                    const t = new Set();
                    for (const n of e.caveats)
                      if (
                        n.type === g.CAVEAT_TYPES.restrictReturnedAccounts &&
                        Array.isArray(n.value)
                      )
                        for (const e of n.value) t.add(e);
                    return [...t];
                  });
              };
            };
      },
      {
        package: '@metamask/permission-log-controller',
        file: 'node_modules/@metamask/permission-log-controller/dist/PermissionLogController.cjs',
      },
    ],
    [
      2429,
      {},
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                var r;
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.LOG_LIMIT =
                    n.LOG_METHOD_TYPES =
                    n.LOG_IGNORE_METHODS =
                    n.CAVEAT_TYPES =
                    n.WALLET_PREFIX =
                      void 0),
                  (n.WALLET_PREFIX = 'wallet_'),
                  (n.CAVEAT_TYPES = Object.freeze({
                    restrictReturnedAccounts: 'restrictReturnedAccounts',
                  })),
                  (n.LOG_IGNORE_METHODS = ['wallet_registerOnboarding', 'wallet_watchAsset']),
                  (function (e) {
                    (e.restricted = 'restricted'), (e.internal = 'internal');
                  })(r || (n.LOG_METHOD_TYPES = r = {})),
                  (n.LOG_LIMIT = 100);
              };
            };
      },
      {
        package: '@metamask/permission-log-controller',
        file: 'node_modules/@metamask/permission-log-controller/dist/enums.cjs',
      },
    ],
    [
      243,
      { '../../../shared/modules/hexstring-utils': 5864, lodash: 4921 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = void 0);
                var r = e('lodash'),
                  s = e('../../../shared/modules/hexstring-utils');
                const a = '0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359',
                  o = 'DAI',
                  i = 'SAI';
                function c(e = {}) {
                  return (
                    e &&
                    'object' == typeof e &&
                    e.symbol === o &&
                    (0, s.toChecksumHexAddress)(e.address) === a
                  );
                }
                n.default = {
                  version: 39,
                  async migrate(e) {
                    const t = (0, r.cloneDeep)(e);
                    t.meta.version = 39;
                    const n = t.data;
                    return (
                      (t.data = (function (e) {
                        const { PreferencesController: t } = e;
                        if (t) {
                          const e = t.tokens || [];
                          if (Array.isArray(e)) for (const t of e) c(t) && (t.symbol = i);
                          const n = t.accountTokens || {};
                          if (n && 'object' == typeof n)
                            for (const e of Object.keys(n)) {
                              const t = n[e];
                              if (t && 'object' == typeof t)
                                for (const e of Object.keys(t)) {
                                  const n = t[e];
                                  if (Array.isArray(n)) for (const e of n) c(e) && (e.symbol = i);
                                }
                            }
                        }
                        return e;
                      })(n)),
                      t
                    );
                  },
                };
              };
            };
      },
      { package: '$root$', file: 'app/scripts/migrations/039.js' },
    ],
    [
      2430,
      { './PermissionLogController.cjs': 2428 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                var r =
                    (this && this.__createBinding) ||
                    (Object.create
                      ? function (e, t, n, r) {
                          r === undefined && (r = n);
                          var s = Object.getOwnPropertyDescriptor(t, n);
                          (s && !('get' in s ? !t.__esModule : s.writable || s.configurable)) ||
                            (s = {
                              enumerable: !0,
                              get: function () {
                                return t[n];
                              },
                            }),
                            Object.defineProperty(e, r, s);
                        }
                      : function (e, t, n, r) {
                          r === undefined && (r = n), (e[r] = t[n]);
                        }),
                  s =
                    (this && this.__exportStar) ||
                    function (e, t) {
                      for (var n in e)
                        'default' === n || Object.prototype.hasOwnProperty.call(t, n) || r(t, e, n);
                    };
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  s(e('./PermissionLogController.cjs'), n);
              };
            };
      },
      {
        package: '@metamask/permission-log-controller',
        file: 'node_modules/@metamask/permission-log-controller/dist/index.cjs',
      },
    ],
    [
      2431,
      {
        './PhishingDetector.cjs': 2432,
        './UrlScanCache.cjs': 2433,
        './types.cjs': 2435,
        './utils.cjs': 2436,
        '@metamask/base-controller': 1407,
        '@metamask/controller-utils': 1515,
        'punycode/punycode.js': 5140,
      },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                var r,
                  s,
                  a,
                  o,
                  i,
                  c,
                  l,
                  d,
                  u,
                  h,
                  p,
                  m,
                  f,
                  g,
                  b,
                  y =
                    (this && this.__classPrivateFieldSet) ||
                    function (e, t, n, r, s) {
                      if ('m' === r) throw new TypeError('Private method is not writable');
                      if ('a' === r && !s)
                        throw new TypeError('Private accessor was defined without a setter');
                      if ('function' == typeof t ? e !== t || !s : !t.has(e))
                        throw new TypeError(
                          'Cannot write private member to an object whose class did not declare it'
                        );
                      return 'a' === r ? s.call(e, n) : s ? (s.value = n) : t.set(e, n), n;
                    },
                  w =
                    (this && this.__classPrivateFieldGet) ||
                    function (e, t, n, r) {
                      if ('a' === n && !r)
                        throw new TypeError('Private accessor was defined without a getter');
                      if ('function' == typeof t ? e !== t || !r : !t.has(e))
                        throw new TypeError(
                          'Cannot read private member from an object whose class did not declare it'
                        );
                      return 'm' === n ? r : 'a' === n ? r.call(e) : r ? r.value : t.get(e);
                    };
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.PhishingController =
                    n.phishingListKeyNameMap =
                    n.ListNames =
                    n.ListKeys =
                    n.C2_DOMAIN_BLOCKLIST_URL =
                    n.METAMASK_HOTLIST_DIFF_URL =
                    n.METAMASK_STALELIST_URL =
                    n.STALELIST_REFRESH_INTERVAL =
                    n.HOTLIST_REFRESH_INTERVAL =
                    n.C2_DOMAIN_BLOCKLIST_REFRESH_INTERVAL =
                    n.PHISHING_DETECTION_BULK_SCAN_ENDPOINT =
                    n.PHISHING_DETECTION_SCAN_ENDPOINT =
                    n.PHISHING_DETECTION_BASE_URL =
                    n.C2_DOMAIN_BLOCKLIST_ENDPOINT =
                    n.CLIENT_SIDE_DETECION_BASE_URL =
                    n.METAMASK_HOTLIST_DIFF_FILE =
                    n.METAMASK_STALELIST_FILE =
                    n.PHISHING_CONFIG_BASE_URL =
                      void 0);
                const v = e('@metamask/base-controller'),
                  C = e('@metamask/controller-utils'),
                  k = e('punycode/punycode.js'),
                  S = e('./PhishingDetector.cjs'),
                  _ = e('./types.cjs'),
                  E = e('./UrlScanCache.cjs'),
                  T = e('./utils.cjs');
                var M, P;
                (n.PHISHING_CONFIG_BASE_URL = 'https://phishing-detection.api.cx.metamask.io'),
                  (n.METAMASK_STALELIST_FILE = '/v1/stalelist'),
                  (n.METAMASK_HOTLIST_DIFF_FILE = '/v1/diffsSince'),
                  (n.CLIENT_SIDE_DETECION_BASE_URL =
                    'https://client-side-detection.api.cx.metamask.io'),
                  (n.C2_DOMAIN_BLOCKLIST_ENDPOINT = '/v1/request-blocklist'),
                  (n.PHISHING_DETECTION_BASE_URL = 'https://dapp-scanning.api.cx.metamask.io'),
                  (n.PHISHING_DETECTION_SCAN_ENDPOINT = 'scan'),
                  (n.PHISHING_DETECTION_BULK_SCAN_ENDPOINT = 'bulk-scan'),
                  (n.C2_DOMAIN_BLOCKLIST_REFRESH_INTERVAL = 300),
                  (n.HOTLIST_REFRESH_INTERVAL = 300),
                  (n.STALELIST_REFRESH_INTERVAL = 2592e3),
                  (n.METAMASK_STALELIST_URL = `${n.PHISHING_CONFIG_BASE_URL}${n.METAMASK_STALELIST_FILE}`),
                  (n.METAMASK_HOTLIST_DIFF_URL = `${n.PHISHING_CONFIG_BASE_URL}${n.METAMASK_HOTLIST_DIFF_FILE}`),
                  (n.C2_DOMAIN_BLOCKLIST_URL = `${n.CLIENT_SIDE_DETECION_BASE_URL}${n.C2_DOMAIN_BLOCKLIST_ENDPOINT}`),
                  (function (e) {
                    e.EthPhishingDetectConfig = 'eth_phishing_detect_config';
                  })(M || (n.ListKeys = M = {})),
                  (function (e) {
                    e.MetaMask = 'MetaMask';
                  })(P || (n.ListNames = P = {}));
                const A = { [P.MetaMask]: M.EthPhishingDetectConfig };
                n.phishingListKeyNameMap = { [M.EthPhishingDetectConfig]: P.MetaMask };
                const N = 'PhishingController',
                  I = {
                    phishingLists: { persist: !0, anonymous: !1 },
                    whitelist: { persist: !0, anonymous: !1 },
                    hotlistLastFetched: { persist: !0, anonymous: !1 },
                    stalelistLastFetched: { persist: !0, anonymous: !1 },
                    c2DomainBlocklistLastFetched: { persist: !0, anonymous: !1 },
                    urlScanCache: { persist: !0, anonymous: !1 },
                  };
                class x extends v.BaseController {
                  constructor({
                    stalelistRefreshInterval: e = n.STALELIST_REFRESH_INTERVAL,
                    hotlistRefreshInterval: t = n.HOTLIST_REFRESH_INTERVAL,
                    c2DomainBlocklistRefreshInterval: m = n.C2_DOMAIN_BLOCKLIST_REFRESH_INTERVAL,
                    urlScanCacheTTL: f = E.DEFAULT_URL_SCAN_CACHE_TTL,
                    urlScanCacheMaxSize: g = E.DEFAULT_URL_SCAN_CACHE_MAX_SIZE,
                    messenger: b,
                    state: v = {},
                  }) {
                    super({
                      name: N,
                      metadata: I,
                      messenger: b,
                      state: {
                        phishingLists: [],
                        whitelist: [],
                        hotlistLastFetched: 0,
                        stalelistLastFetched: 0,
                        c2DomainBlocklistLastFetched: 0,
                        urlScanCache: {},
                        ...v,
                      },
                    }),
                      r.add(this),
                      s.set(this, void 0),
                      a.set(this, void 0),
                      o.set(this, void 0),
                      i.set(this, void 0),
                      c.set(this, void 0),
                      l.set(this, void 0),
                      d.set(this, void 0),
                      u.set(this, void 0),
                      (this.scanUrl = async e => {
                        const [t, r] = (0, T.getHostnameFromWebUrl)(e);
                        if (!r)
                          return {
                            domainName: '',
                            recommendedAction: _.RecommendedAction.None,
                            fetchError: 'url is not a valid web URL',
                          };
                        const s = w(this, c, 'f').get(t);
                        if (s) return s;
                        const a = await (0, C.safelyExecuteWithTimeout)(
                          async () => {
                            const e = await fetch(
                              `${n.PHISHING_DETECTION_BASE_URL}/${n.PHISHING_DETECTION_SCAN_ENDPOINT}?url=${encodeURIComponent(t)}`,
                              { method: 'GET', headers: { Accept: 'application/json' } }
                            );
                            if (!e.ok) return { error: `${e.status} ${e.statusText}` };
                            return await e.json();
                          },
                          !0,
                          8e3
                        );
                        if (!a)
                          return {
                            domainName: '',
                            recommendedAction: _.RecommendedAction.None,
                            fetchError: 'timeout of 8000ms exceeded',
                          };
                        if ('error' in a)
                          return {
                            domainName: '',
                            recommendedAction: _.RecommendedAction.None,
                            fetchError: a.error,
                          };
                        const o = { domainName: t, recommendedAction: a.recommendedAction };
                        return w(this, c, 'f').add(t, o), o;
                      }),
                      (this.bulkScanUrls = async e => {
                        if (!e || 0 === e.length) return { results: {}, errors: {} };
                        if (e.length > 250)
                          return {
                            results: {},
                            errors: { too_many_urls: ['Maximum of 250 URLs allowed per request'] },
                          };
                        const t = { results: {}, errors: {} },
                          n = {},
                          r = [];
                        for (const s of e) {
                          if (s.length > 2048) {
                            t.errors[s] = ['URL length must not exceed 2048 characters'];
                            continue;
                          }
                          const [e, a] = (0, T.getHostnameFromWebUrl)(s);
                          if (!a) {
                            t.errors[s] = ['url is not a valid web URL'];
                            continue;
                          }
                          const o = w(this, c, 'f').get(e);
                          o ? (t.results[s] = o) : ((n[s] = e), r.push(s));
                        }
                        if (r.length > 0) {
                          const e = 50,
                            s = [];
                          for (let t = 0; t < r.length; t += e) s.push(r.slice(t, t + e));
                          (await Promise.all(s.map(e => w(this, p, 'f').call(this, e)))).forEach(
                            e => {
                              Object.entries(e.results).forEach(([e, r]) => {
                                const s = n[e];
                                s && w(this, c, 'f').add(s, r), (t.results[e] = r);
                              }),
                                Object.entries(e.errors).forEach(([e, n]) => {
                                  t.errors[e] = [...(t.errors[e] || []), ...n];
                                });
                            }
                          );
                        }
                        return t;
                      }),
                      p.set(this, async e => {
                        const t = await (0, C.safelyExecuteWithTimeout)(
                          async () => {
                            const t = await fetch(
                              `${n.PHISHING_DETECTION_BASE_URL}/${n.PHISHING_DETECTION_BULK_SCAN_ENDPOINT}`,
                              {
                                method: 'POST',
                                headers: {
                                  Accept: 'application/json',
                                  'Content-Type': 'application/json',
                                },
                                body: JSON.stringify({ urls: e }),
                              }
                            );
                            if (!t.ok)
                              return {
                                error: `${t.status} ${t.statusText}`,
                                status: t.status,
                                statusText: t.statusText,
                              };
                            return await t.json();
                          },
                          !0,
                          15e3
                        );
                        return t
                          ? 'error' in t && 'status' in t && 'statusText' in t
                            ? {
                                results: {},
                                errors: { api_error: [`${t.status} ${t.statusText}`] },
                              }
                            : t
                          : {
                              results: {},
                              errors: { network_error: ['timeout of 15000ms exceeded'] },
                            };
                      }),
                      y(this, a, e, 'f'),
                      y(this, o, t, 'f'),
                      y(this, i, m, 'f'),
                      y(
                        this,
                        c,
                        new E.UrlScanCache({
                          cacheTTL: f,
                          maxCacheSize: g,
                          initialCache: this.state.urlScanCache,
                          updateState: e => {
                            this.update(t => {
                              t.urlScanCache = e;
                            });
                          },
                        }),
                        'f'
                      ),
                      w(this, r, 'm', h).call(this),
                      this.updatePhishingDetector();
                  }
                  updatePhishingDetector() {
                    y(this, s, new S.PhishingDetector(this.state.phishingLists), 'f');
                  }
                  setStalelistRefreshInterval(e) {
                    y(this, a, e, 'f');
                  }
                  setHotlistRefreshInterval(e) {
                    y(this, o, e, 'f');
                  }
                  setC2DomainBlocklistRefreshInterval(e) {
                    y(this, i, e, 'f');
                  }
                  setUrlScanCacheTTL(e) {
                    w(this, c, 'f').setTTL(e);
                  }
                  setUrlScanCacheMaxSize(e) {
                    w(this, c, 'f').setMaxSize(e);
                  }
                  clearUrlScanCache() {
                    w(this, c, 'f').clear();
                  }
                  isStalelistOutOfDate() {
                    return (
                      (0, T.fetchTimeNow)() - this.state.stalelistLastFetched >= w(this, a, 'f')
                    );
                  }
                  isHotlistOutOfDate() {
                    return (0, T.fetchTimeNow)() - this.state.hotlistLastFetched >= w(this, o, 'f');
                  }
                  isC2DomainBlocklistOutOfDate() {
                    return (
                      (0, T.fetchTimeNow)() - this.state.c2DomainBlocklistLastFetched >=
                      w(this, i, 'f')
                    );
                  }
                  async maybeUpdateState() {
                    if (this.isStalelistOutOfDate()) return void (await this.updateStalelist());
                    this.isHotlistOutOfDate() && (await this.updateHotlist());
                    this.isC2DomainBlocklistOutOfDate() && (await this.updateC2DomainBlocklist());
                  }
                  test(e) {
                    const t = (0, k.toASCII)(e),
                      n = (0, T.getHostnameFromUrl)(t);
                    return this.state.whitelist.includes(n || t)
                      ? { result: !1, type: _.PhishingDetectorResultType.All }
                      : w(this, s, 'f').check(t);
                  }
                  isBlockedRequest(e) {
                    const t = (0, k.toASCII)(e),
                      n = (0, T.getHostnameFromUrl)(t);
                    return this.state.whitelist.includes(n || t)
                      ? { result: !1, type: _.PhishingDetectorResultType.All }
                      : w(this, s, 'f').isMaliciousC2Domain(t);
                  }
                  bypass(e) {
                    const t = (0, k.toASCII)(e),
                      n = (0, T.getHostnameFromUrl)(t),
                      { whitelist: r } = this.state;
                    r.includes(n || t) ||
                      this.update(e => {
                        e.whitelist.push(n || t);
                      });
                  }
                  async updateC2DomainBlocklist() {
                    if (w(this, u, 'f')) await w(this, u, 'f');
                    else
                      try {
                        y(this, u, w(this, r, 'm', g).call(this), 'f'), await w(this, u, 'f');
                      } finally {
                        y(this, u, undefined, 'f');
                      }
                  }
                  async updateHotlist() {
                    if (w(this, l, 'f')) await w(this, l, 'f');
                    else
                      try {
                        y(this, l, w(this, r, 'm', f).call(this), 'f'), await w(this, l, 'f');
                      } finally {
                        y(this, l, undefined, 'f');
                      }
                  }
                  async updateStalelist() {
                    if (w(this, d, 'f')) await w(this, d, 'f');
                    else
                      try {
                        y(this, d, w(this, r, 'm', m).call(this), 'f'), await w(this, d, 'f');
                      } finally {
                        y(this, d, undefined, 'f');
                      }
                  }
                }
                (n.PhishingController = x),
                  (s = new WeakMap()),
                  (a = new WeakMap()),
                  (o = new WeakMap()),
                  (i = new WeakMap()),
                  (c = new WeakMap()),
                  (l = new WeakMap()),
                  (d = new WeakMap()),
                  (u = new WeakMap()),
                  (p = new WeakMap()),
                  (r = new WeakSet()),
                  (h = function () {
                    this.messagingSystem.registerActionHandler(
                      `${N}:maybeUpdateState`,
                      this.maybeUpdateState.bind(this)
                    ),
                      this.messagingSystem.registerActionHandler(
                        `${N}:testOrigin`,
                        this.test.bind(this)
                      );
                  }),
                  (m = async function () {
                    let e = null,
                      t = null,
                      s = null;
                    try {
                      const a = w(this, r, 'm', b).call(this, n.METAMASK_STALELIST_URL),
                        o = w(this, r, 'm', b).call(this, n.C2_DOMAIN_BLOCKLIST_URL);
                      ([e, s] = await Promise.all([a, o])),
                        e?.data &&
                          e.data.lastUpdated > 0 &&
                          (t = await w(this, r, 'm', b).call(
                            this,
                            `${n.METAMASK_HOTLIST_DIFF_URL}/${e.data.lastUpdated}`
                          ));
                    } finally {
                      const e = (0, T.fetchTimeNow)();
                      this.update(t => {
                        (t.stalelistLastFetched = e),
                          (t.hotlistLastFetched = e),
                          (t.c2DomainBlocklistLastFetched = e);
                      });
                    }
                    if (!e || !t) return;
                    const { eth_phishing_detect_config: a, ...o } = e.data,
                      i = {
                        ...a,
                        ...o,
                        c2DomainBlocklist: s ? s.recentlyAdded : [],
                        name: n.phishingListKeyNameMap.eth_phishing_detect_config,
                      },
                      c = (0, T.applyDiffs)(i, t.data, M.EthPhishingDetectConfig);
                    this.update(e => {
                      e.phishingLists = [c];
                    }),
                      this.updatePhishingDetector();
                  }),
                  (f = async function () {
                    let e;
                    try {
                      if (0 === this.state.phishingLists.length) return;
                      const t = Math.max(
                        ...this.state.phishingLists.map(({ lastUpdated: e }) => e)
                      );
                      e = await w(this, r, 'm', b).call(
                        this,
                        `${n.METAMASK_HOTLIST_DIFF_URL}/${t}`
                      );
                    } finally {
                      this.update(e => {
                        e.hotlistLastFetched = (0, T.fetchTimeNow)();
                      });
                    }
                    if (!e?.data) return;
                    const t = e.data,
                      s = this.state.phishingLists.map(e =>
                        (0, T.applyDiffs)(e, t, A[e.name], [], [])
                      );
                    this.update(e => {
                      e.phishingLists = s;
                    }),
                      this.updatePhishingDetector();
                  }),
                  (g = async function () {
                    let e = null;
                    try {
                      e = await w(this, r, 'm', b).call(
                        this,
                        `${n.C2_DOMAIN_BLOCKLIST_URL}?timestamp=${(0, T.roundToNearestMinute)(this.state.c2DomainBlocklistLastFetched)}`
                      );
                    } finally {
                      this.update(e => {
                        e.c2DomainBlocklistLastFetched = (0, T.fetchTimeNow)();
                      });
                    }
                    if (!e) return;
                    const t = e.recentlyAdded,
                      s = e.recentlyRemoved,
                      a = this.state.phishingLists.map(e =>
                        (0, T.applyDiffs)(e, [], A[e.name], t, s)
                      );
                    this.update(e => {
                      e.phishingLists = a;
                    }),
                      this.updatePhishingDetector();
                  }),
                  (b = async function (e) {
                    const t = await (0, C.safelyExecute)(() => fetch(e, { cache: 'no-cache' }), !0);
                    return 200 === t?.status ? await t.json() : null;
                  }),
                  (n.default = x);
              };
            };
      },
      {
        package: '@metamask/phishing-controller',
        file: 'node_modules/@metamask/phishing-controller/dist/PhishingController.cjs',
      },
    ],
    [
      2432,
      { './types.cjs': 2435, './utils.cjs': 2436, 'fastest-levenshtein': 4514 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                var r,
                  s,
                  a,
                  o,
                  i =
                    (this && this.__classPrivateFieldSet) ||
                    function (e, t, n, r, s) {
                      if ('m' === r) throw new TypeError('Private method is not writable');
                      if ('a' === r && !s)
                        throw new TypeError('Private accessor was defined without a setter');
                      if ('function' == typeof t ? e !== t || !s : !t.has(e))
                        throw new TypeError(
                          'Cannot write private member to an object whose class did not declare it'
                        );
                      return 'a' === r ? s.call(e, n) : s ? (s.value = n) : t.set(e, n), n;
                    },
                  c =
                    (this && this.__classPrivateFieldGet) ||
                    function (e, t, n, r) {
                      if ('a' === n && !r)
                        throw new TypeError('Private accessor was defined without a getter');
                      if ('function' == typeof t ? e !== t || !r : !t.has(e))
                        throw new TypeError(
                          'Cannot read private member from an object whose class did not declare it'
                        );
                      return 'm' === n ? r : 'a' === n ? r.call(e) : r ? r.value : t.get(e);
                    };
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.PhishingDetector = void 0);
                const l = e('fastest-levenshtein'),
                  d = e('./types.cjs'),
                  u = e('./utils.cjs');
                (n.PhishingDetector = class {
                  constructor(e) {
                    r.add(this),
                      s.set(this, void 0),
                      a.set(this, void 0),
                      Array.isArray(e)
                        ? (i(this, s, (0, u.processConfigs)(e), 'f'), i(this, a, !1, 'f'))
                        : (i(
                            this,
                            s,
                            [
                              (0, u.getDefaultPhishingDetectorConfig)({
                                allowlist: e.whitelist,
                                blocklist: e.blacklist,
                                c2DomainBlocklist: e.c2DomainBlocklist,
                                fuzzylist: e.fuzzylist,
                                tolerance: e.tolerance,
                              }),
                            ],
                            'f'
                          ),
                          i(this, a, !0, 'f'));
                  }
                  check(e) {
                    const t = c(this, r, 'm', o).call(this, e);
                    if (c(this, a, 'f')) {
                      let e = t.type;
                      return (
                        e === d.PhishingDetectorResultType.Allowlist
                          ? (e = d.PhishingDetectorResultType.Whitelist)
                          : e === d.PhishingDetectorResultType.Blocklist &&
                            (e = d.PhishingDetectorResultType.Blacklist),
                        { match: t.match, result: t.result, type: e }
                      );
                    }
                    return t;
                  }
                  isMaliciousC2Domain(e) {
                    const t = (0, u.getHostnameFromUrl)(e);
                    if (!t)
                      return { result: !1, type: d.PhishingDetectorResultType.C2DomainBlocklist };
                    const n = t.endsWith('.') ? t.slice(0, -1) : t,
                      r = (0, u.domainToParts)(n);
                    for (const { allowlist: e, name: t, version: n } of c(this, s, 'f')) {
                      const s = (0, u.matchPartsAgainstList)(r, e);
                      if (s) {
                        return {
                          match: (0, u.domainPartsToDomain)(s),
                          name: t,
                          result: !1,
                          type: d.PhishingDetectorResultType.Allowlist,
                          version: n === undefined ? n : String(n),
                        };
                      }
                    }
                    const a = (0, u.sha256Hash)(t.toLowerCase()),
                      o = (0, u.generateParentDomains)(r.reverse(), 5);
                    for (const { c2DomainBlocklist: e, name: t, version: n } of c(this, s, 'f'))
                      if (e && 0 !== e.length) {
                        if (e.includes(a))
                          return {
                            name: t,
                            result: !0,
                            type: d.PhishingDetectorResultType.C2DomainBlocklist,
                            version: n === undefined ? n : String(n),
                          };
                        for (const r of o) {
                          const s = (0, u.sha256Hash)(r);
                          if (e.includes(s))
                            return {
                              name: t,
                              result: !0,
                              type: d.PhishingDetectorResultType.C2DomainBlocklist,
                              version: n === undefined ? n : String(n),
                            };
                        }
                      }
                    return { result: !1, type: d.PhishingDetectorResultType.C2DomainBlocklist };
                  }
                }),
                  (s = new WeakMap()),
                  (a = new WeakMap()),
                  (r = new WeakSet()),
                  (o = function (e) {
                    const t = e.match(
                      new RegExp(
                        'Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,}',
                        'u'
                      )
                    );
                    if (null !== t) {
                      const e = t[0];
                      for (const { blocklist: t, name: n, version: r } of c(this, s, 'f')) {
                        if (t.filter(e => 1 === e.length).find(t => t[0] === e))
                          return {
                            name: n,
                            match: e,
                            result: !0,
                            type: d.PhishingDetectorResultType.Blocklist,
                            version: r === undefined ? r : String(r),
                          };
                      }
                    }
                    let n;
                    try {
                      n = new URL(e).hostname;
                    } catch (e) {
                      return { result: !1, type: d.PhishingDetectorResultType.All };
                    }
                    const r = n.endsWith('.') ? n.slice(0, -1) : n,
                      a = (0, u.domainToParts)(r);
                    for (const { allowlist: e, name: t, version: n } of c(this, s, 'f')) {
                      const r = (0, u.matchPartsAgainstList)(a, e);
                      if (r) {
                        return {
                          match: (0, u.domainPartsToDomain)(r),
                          name: t,
                          result: !1,
                          type: d.PhishingDetectorResultType.Allowlist,
                          version: n === undefined ? n : String(n),
                        };
                      }
                    }
                    for (const {
                      blocklist: e,
                      fuzzylist: t,
                      name: n,
                      tolerance: r,
                      version: o,
                    } of c(this, s, 'f')) {
                      const s = (0, u.matchPartsAgainstList)(a, e);
                      if (s) {
                        return {
                          match: (0, u.domainPartsToDomain)(s),
                          name: n,
                          result: !0,
                          type: d.PhishingDetectorResultType.Blocklist,
                          version: o === undefined ? o : String(o),
                        };
                      }
                      if (r > 0) {
                        let e = (0, u.domainPartsToFuzzyForm)(a);
                        e = e.replace(/^www\./u, '');
                        const s = t.find(t => {
                          const n = (0, u.domainPartsToFuzzyForm)(t);
                          return (0, l.distance)(e, n) <= r;
                        });
                        if (s) {
                          return {
                            name: n,
                            match: (0, u.domainPartsToDomain)(s),
                            result: !0,
                            type: d.PhishingDetectorResultType.Fuzzy,
                            version: o === undefined ? o : String(o),
                          };
                        }
                      }
                    }
                    return { result: !1, type: d.PhishingDetectorResultType.All };
                  });
              };
            };
      },
      {
        package: '@metamask/phishing-controller',
        file: 'node_modules/@metamask/phishing-controller/dist/PhishingDetector.cjs',
      },
    ],
    [
      2433,
      { './utils.cjs': 2436 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                var r,
                  s,
                  a,
                  o,
                  i,
                  c,
                  l,
                  d =
                    (this && this.__classPrivateFieldSet) ||
                    function (e, t, n, r, s) {
                      if ('m' === r) throw new TypeError('Private method is not writable');
                      if ('a' === r && !s)
                        throw new TypeError('Private accessor was defined without a setter');
                      if ('function' == typeof t ? e !== t || !s : !t.has(e))
                        throw new TypeError(
                          'Cannot write private member to an object whose class did not declare it'
                        );
                      return 'a' === r ? s.call(e, n) : s ? (s.value = n) : t.set(e, n), n;
                    },
                  u =
                    (this && this.__classPrivateFieldGet) ||
                    function (e, t, n, r) {
                      if ('a' === n && !r)
                        throw new TypeError('Private accessor was defined without a getter');
                      if ('function' == typeof t ? e !== t || !r : !t.has(e))
                        throw new TypeError(
                          'Cannot read private member from an object whose class did not declare it'
                        );
                      return 'm' === n ? r : 'a' === n ? r.call(e) : r ? r.value : t.get(e);
                    };
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.UrlScanCache =
                    n.DEFAULT_URL_SCAN_CACHE_MAX_SIZE =
                    n.DEFAULT_URL_SCAN_CACHE_TTL =
                      void 0);
                const h = e('./utils.cjs');
                (n.DEFAULT_URL_SCAN_CACHE_TTL = 300), (n.DEFAULT_URL_SCAN_CACHE_MAX_SIZE = 100);
                (n.UrlScanCache = class {
                  constructor({
                    cacheTTL: e = n.DEFAULT_URL_SCAN_CACHE_TTL,
                    maxCacheSize: t = n.DEFAULT_URL_SCAN_CACHE_MAX_SIZE,
                    initialCache: c = {},
                    updateState: h,
                  }) {
                    r.add(this),
                      s.set(this, void 0),
                      a.set(this, void 0),
                      o.set(this, void 0),
                      i.set(this, void 0),
                      d(this, s, e, 'f'),
                      d(this, a, t, 'f'),
                      d(this, o, new Map(Object.entries(c)), 'f'),
                      d(this, i, h, 'f'),
                      u(this, r, 'm', l).call(this);
                  }
                  setTTL(e) {
                    d(this, s, e, 'f');
                  }
                  setMaxSize(e) {
                    d(this, a, e, 'f'), u(this, r, 'm', l).call(this);
                  }
                  clear() {
                    u(this, o, 'f').clear(), u(this, r, 'm', c).call(this);
                  }
                  get(e) {
                    const t = u(this, o, 'f').get(e);
                    if (!t) return undefined;
                    return (0, h.fetchTimeNow)() - t.timestamp > u(this, s, 'f')
                      ? (u(this, o, 'f').delete(e), u(this, r, 'm', c).call(this), undefined)
                      : t.result;
                  }
                  add(e, t) {
                    u(this, o, 'f').set(e, { result: t, timestamp: (0, h.fetchTimeNow)() }),
                      u(this, r, 'm', l).call(this),
                      u(this, r, 'm', c).call(this);
                  }
                }),
                  (s = new WeakMap()),
                  (a = new WeakMap()),
                  (o = new WeakMap()),
                  (i = new WeakMap()),
                  (r = new WeakSet()),
                  (c = function () {
                    u(this, i, 'f').call(this, Object.fromEntries(u(this, o, 'f')));
                  }),
                  (l = function () {
                    if (u(this, o, 'f').size <= u(this, a, 'f')) return;
                    const e = u(this, o, 'f').size - u(this, a, 'f');
                    let t = 0;
                    for (const n of u(this, o, 'f').keys()) {
                      if (t >= e) break;
                      u(this, o, 'f').delete(n), (t += 1);
                    }
                  });
              };
            };
      },
      {
        package: '@metamask/phishing-controller',
        file: 'node_modules/@metamask/phishing-controller/dist/UrlScanCache.cjs',
      },
    ],
    [
      2434,
      { './PhishingController.cjs': 2431, './PhishingDetector.cjs': 2432, './types.cjs': 2435 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                var r =
                    (this && this.__createBinding) ||
                    (Object.create
                      ? function (e, t, n, r) {
                          r === undefined && (r = n);
                          var s = Object.getOwnPropertyDescriptor(t, n);
                          (s && !('get' in s ? !t.__esModule : s.writable || s.configurable)) ||
                            (s = {
                              enumerable: !0,
                              get: function () {
                                return t[n];
                              },
                            }),
                            Object.defineProperty(e, r, s);
                        }
                      : function (e, t, n, r) {
                          r === undefined && (r = n), (e[r] = t[n]);
                        }),
                  s =
                    (this && this.__exportStar) ||
                    function (e, t) {
                      for (var n in e)
                        'default' === n || Object.prototype.hasOwnProperty.call(t, n) || r(t, e, n);
                    };
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.RecommendedAction =
                    n.PhishingDetectorResultType =
                    n.PhishingDetector =
                      void 0),
                  s(e('./PhishingController.cjs'), n);
                var a = e('./PhishingDetector.cjs');
                Object.defineProperty(n, 'PhishingDetector', {
                  enumerable: !0,
                  get: function () {
                    return a.PhishingDetector;
                  },
                });
                var o = e('./types.cjs');
                Object.defineProperty(n, 'PhishingDetectorResultType', {
                  enumerable: !0,
                  get: function () {
                    return o.PhishingDetectorResultType;
                  },
                }),
                  Object.defineProperty(n, 'RecommendedAction', {
                    enumerable: !0,
                    get: function () {
                      return o.RecommendedAction;
                    },
                  });
              };
            };
      },
      {
        package: '@metamask/phishing-controller',
        file: 'node_modules/@metamask/phishing-controller/dist/index.cjs',
      },
    ],
    [
      2435,
      {},
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                var r, s;
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.RecommendedAction = n.PhishingDetectorResultType = void 0),
                  (function (e) {
                    (e.All = 'all'),
                      (e.Fuzzy = 'fuzzy'),
                      (e.Blocklist = 'blocklist'),
                      (e.Allowlist = 'allowlist'),
                      (e.Blacklist = 'blacklist'),
                      (e.Whitelist = 'whitelist'),
                      (e.C2DomainBlocklist = 'c2DomainBlocklist');
                  })(r || (n.PhishingDetectorResultType = r = {})),
                  (function (e) {
                    (e.None = 'NONE'), (e.Warn = 'WARN'), (e.Block = 'BLOCK');
                  })(s || (n.RecommendedAction = s = {}));
              };
            };
      },
      {
        package: '@metamask/phishing-controller',
        file: 'node_modules/@metamask/phishing-controller/dist/types.cjs',
      },
    ],
    [
      2436,
      {
        './PhishingController.cjs': 2431,
        '@noble/hashes/utils': 3057,
        'ethereum-cryptography/sha256': 4384,
      },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.generateParentDomains =
                    n.getHostnameFromWebUrl =
                    n.getHostnameFromUrl =
                    n.sha256Hash =
                    n.matchPartsAgainstList =
                    n.domainPartsToFuzzyForm =
                    n.domainPartsToDomain =
                    n.processConfigs =
                    n.getDefaultPhishingDetectorConfig =
                    n.processDomainList =
                    n.domainToParts =
                    n.validateConfig =
                    n.applyDiffs =
                    n.roundToNearestMinute =
                    n.fetchTimeNow =
                      void 0);
                const r = e('@noble/hashes/utils'),
                  s = e('ethereum-cryptography/sha256'),
                  a = e('./PhishingController.cjs');
                (n.fetchTimeNow = () => Math.round(Date.now() / 1e3)),
                  (n.roundToNearestMinute = function (e) {
                    return 60 * Math.floor(e / 60);
                  });
                const o = e => {
                  const t = e.indexOf('.');
                  return [e.slice(0, t), e.slice(t + 1)];
                };
                function i(e) {
                  if (null === e || 'object' != typeof e) throw new Error('Invalid config');
                  if ('tolerance' in e && !('fuzzylist' in e))
                    throw new Error('Fuzzylist tolerance provided without fuzzylist');
                  if ('name' in e && ('string' != typeof e.name || '' === e.name))
                    throw new Error("Invalid config parameter: 'name'");
                  if (
                    'version' in e &&
                    (!['number', 'string'].includes(typeof e.version) || '' === e.version)
                  )
                    throw new Error("Invalid config parameter: 'version'");
                }
                (n.applyDiffs = (e, t, n, r = [], s = []) => {
                  const i = t.filter(
                    ({ timestamp: t, targetList: r }) => t > e.lastUpdated && o(r)[0] === n
                  );
                  let c = e.lastUpdated;
                  const l = {
                    allowlist: new Set(e.allowlist),
                    blocklist: new Set(e.blocklist),
                    fuzzylist: new Set(e.fuzzylist),
                    c2DomainBlocklist: new Set(e.c2DomainBlocklist),
                  };
                  for (const { isRemoval: e, targetList: t, url: n, timestamp: r } of i) {
                    const s = o(t)[1];
                    r > c && (c = r), e ? l[s].delete(n) : l[s].add(n);
                  }
                  if (n === a.ListKeys.EthPhishingDetectConfig) {
                    for (const e of r) l.c2DomainBlocklist.add(e);
                    for (const e of s) l.c2DomainBlocklist.delete(e);
                  }
                  return {
                    c2DomainBlocklist: Array.from(l.c2DomainBlocklist),
                    allowlist: Array.from(l.allowlist),
                    blocklist: Array.from(l.blocklist),
                    fuzzylist: Array.from(l.fuzzylist),
                    version: e.version,
                    name: a.phishingListKeyNameMap[n],
                    tolerance: e.tolerance,
                    lastUpdated: c,
                  };
                }),
                  (n.validateConfig = i);
                n.domainToParts = e => {
                  try {
                    return e.split('.').reverse();
                  } catch (t) {
                    throw new Error(JSON.stringify(e));
                  }
                };
                n.processDomainList = e => e.map(n.domainToParts);
                n.getDefaultPhishingDetectorConfig = ({
                  allowlist: e = [],
                  blocklist: t = [],
                  fuzzylist: r = [],
                  tolerance: s = 3,
                }) => ({
                  allowlist: (0, n.processDomainList)(e),
                  blocklist: (0, n.processDomainList)(t),
                  fuzzylist: (0, n.processDomainList)(r),
                  tolerance: s,
                });
                n.processConfigs = (e = []) =>
                  e
                    .filter(e => {
                      try {
                        return i(e), !0;
                      } catch (e) {
                        return console.error(e), !1;
                      }
                    })
                    .map(e => ({ ...e, ...(0, n.getDefaultPhishingDetectorConfig)(e) }));
                n.domainPartsToDomain = e => e.slice().reverse().join('.');
                n.domainPartsToFuzzyForm = e => e.slice(1).reverse().join('.');
                n.matchPartsAgainstList = (e, t) =>
                  t.find(t => !(t.length > e.length) && t.every((t, n) => e[n] === t));
                n.sha256Hash = e => {
                  const t = (0, s.sha256)(new TextEncoder().encode(e.toLowerCase()));
                  return (0, r.bytesToHex)(t);
                };
                n.getHostnameFromUrl = e => {
                  let t;
                  try {
                    if (((t = new URL(e).hostname), !t || '' === t.split('.').join('')))
                      return null;
                  } catch {
                    return null;
                  }
                  return t;
                };
                n.getHostnameFromWebUrl = e => {
                  if (
                    !e.toLowerCase().startsWith('http://') &&
                    !e.toLowerCase().startsWith('https://')
                  )
                    return ['', !1];
                  const t = (0, n.getHostnameFromUrl)(e);
                  return [t || '', Boolean(t)];
                };
                n.generateParentDomains = (e, t = 5) => {
                  const n = [];
                  if (0 === e.length) return n;
                  if (1 === e.length) n.push(e[0].toLowerCase());
                  else {
                    const r = e.slice(-2).join('.');
                    n.push(r.toLowerCase());
                    for (let r = e.length - 3; r >= 0 && n.length < t; r--) {
                      const t = e.slice(r).join('.');
                      n.push(t.toLowerCase());
                    }
                  }
                  return n;
                };
              };
            };
      },
      {
        package: '@metamask/phishing-controller',
        file: 'node_modules/@metamask/phishing-controller/dist/utils.cjs',
      },
    ],
    [
      244,
      { lodash: 4921 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = void 0);
                var r = e('lodash');
                n.default = {
                  version: 40,
                  async migrate(e) {
                    const t = (0, r.cloneDeep)(e);
                    t.meta.version = 40;
                    const n = t.data;
                    return (
                      (t.data = (function (e) {
                        return delete e.ProviderApprovalController, e;
                      })(n)),
                      t
                    );
                  },
                };
              };
            };
      },
      { package: '$root$', file: 'app/scripts/migrations/040.js' },
    ],
    [
      2448,
      { './ppom-controller': 2449 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.PPOMController = n.NETWORK_CACHE_DURATION = void 0);
                var r = e('./ppom-controller');
                Object.defineProperty(n, 'NETWORK_CACHE_DURATION', {
                  enumerable: !0,
                  get: function () {
                    return r.NETWORK_CACHE_DURATION;
                  },
                }),
                  Object.defineProperty(n, 'PPOMController', {
                    enumerable: !0,
                    get: function () {
                      return r.PPOMController;
                    },
                  });
              };
            };
      },
      {
        package: '@metamask/ppom-validator',
        file: 'node_modules/@metamask/ppom-validator/dist/index.js',
      },
    ],
    [
      2449,
      {
        './ppom-storage': 2450,
        './util': 2451,
        '@metamask/base-controller': 2456,
        '@metamask/controller-utils': 1515,
        'await-semaphore': 3969,
      },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                var r,
                  s,
                  a,
                  o,
                  i,
                  c,
                  l,
                  d,
                  u,
                  h,
                  p,
                  m,
                  f,
                  g,
                  b,
                  y,
                  w,
                  v,
                  C,
                  k,
                  S,
                  _,
                  E,
                  T,
                  M,
                  P,
                  A,
                  N,
                  I,
                  x,
                  R,
                  O,
                  j =
                    (this && this.__classPrivateFieldSet) ||
                    function (e, t, n, r, s) {
                      if ('m' === r) throw new TypeError('Private method is not writable');
                      if ('a' === r && !s)
                        throw new TypeError('Private accessor was defined without a setter');
                      if ('function' == typeof t ? e !== t || !s : !t.has(e))
                        throw new TypeError(
                          'Cannot write private member to an object whose class did not declare it'
                        );
                      return 'a' === r ? s.call(e, n) : s ? (s.value = n) : t.set(e, n), n;
                    },
                  B =
                    (this && this.__classPrivateFieldGet) ||
                    function (e, t, n, r) {
                      if ('a' === n && !r)
                        throw new TypeError('Private accessor was defined without a getter');
                      if ('function' == typeof t ? e !== t || !r : !t.has(e))
                        throw new TypeError(
                          'Cannot read private member from an object whose class did not declare it'
                        );
                      return 'm' === n ? r : 'a' === n ? r.call(e) : r ? r.value : t.get(e);
                    };
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.PPOMController = n.NETWORK_CACHE_DURATION = void 0);
                const $ = e('@metamask/base-controller'),
                  D = e('@metamask/controller-utils'),
                  L = e('await-semaphore'),
                  F = e('./ppom-storage'),
                  q = e('./util');
                n.NETWORK_CACHE_DURATION = 6048e5;
                const U = [
                    'eth_call',
                    'eth_blockNumber',
                    'eth_createAccessList',
                    'eth_getLogs',
                    'eth_getFilterLogs',
                    'eth_getTransactionByHash',
                    'eth_chainId',
                    'eth_getBlockByHash',
                    'eth_getBlockByNumber',
                    'eth_getCode',
                    'eth_getStorageAt',
                    'eth_getBalance',
                    'eth_getTransactionCount',
                    'trace_call',
                    'trace_callMany',
                    'debug_traceCall',
                    'trace_filter',
                  ],
                  H = {
                    versionInfo: { persist: !0, anonymous: !1 },
                    storageMetadata: { persist: !0, anonymous: !1 },
                  },
                  V = 'PPOMController',
                  K = { headers: { 'Content-Type': 'application/json' } };
                class G extends $.BaseController {
                  constructor({
                    chainId: e,
                    messenger: t,
                    provider: n,
                    storageBackend: y,
                    securityAlertsEnabled: w,
                    onPreferencesChange: v,
                    ppomProvider: _,
                    cdnBaseUrl: E,
                    providerRequestLimit: T,
                    state: M,
                    blockaidPublicKey: P,
                    nativeCrypto: A,
                  }) {
                    super({
                      name: V,
                      metadata: H,
                      messenger: t,
                      state: {
                        versionInfo: M?.versionInfo ?? [],
                        storageMetadata: M?.storageMetadata ?? [],
                      },
                    }),
                      r.add(this),
                      s.set(this, void 0),
                      a.set(this, void 0),
                      o.set(this, void 0),
                      i.set(this, void 0),
                      c.set(this, void 0),
                      l.set(this, void 0),
                      d.set(this, void 0),
                      u.set(this, 0),
                      h.set(this, void 0),
                      p.set(this, void 0),
                      m.set(this, {}),
                      f.set(this, void 0),
                      g.set(this, !1),
                      b.set(this, undefined),
                      j(this, h, (0, q.addHexPrefix)(e), 'f'),
                      j(this, a, n, 'f'),
                      j(this, c, _, 'f'),
                      j(
                        this,
                        o,
                        new F.PPOMStorage({
                          storageBackend: y,
                          readMetadata: () => [...this.state.storageMetadata],
                          writeMetadata: e => {
                            this.update(t => {
                              t.storageMetadata = e;
                            });
                          },
                        }),
                        'f'
                      ),
                      j(this, i, new L.Mutex(), 'f'),
                      j(this, l, E, 'f'),
                      j(this, d, T ?? 300, 'f'),
                      j(this, p, w, 'f'),
                      j(this, f, P, 'f'),
                      j(this, b, A, 'f'),
                      v(B(this, r, 'm', C).bind(this)),
                      B(this, r, 'm', k).call(this),
                      B(this, r, 'm', S).call(this);
                  }
                  async usePPOM(e, t) {
                    const n = t ?? B(this, h, 'f');
                    if (!B(this, p, 'f'))
                      throw Error('User has securityAlertsEnabled set to false');
                    if (!(0, q.blockaidValidationSupportedForNetwork)(n))
                      throw Error(
                        `Blockaid validation not available on network with chainId: ${n}`
                      );
                    return await B(this, i, 'f').use(async () => {
                      const t = await B(this, r, 'm', E).call(this, n);
                      j(this, u, 0, 'f'), j(this, m, {}, 'f');
                      return { ...(await e(t)), providerRequestsCount: { ...B(this, m, 'f') } };
                    });
                  }
                }
                (n.PPOMController = G),
                  (s = new WeakMap()),
                  (a = new WeakMap()),
                  (o = new WeakMap()),
                  (i = new WeakMap()),
                  (c = new WeakMap()),
                  (l = new WeakMap()),
                  (d = new WeakMap()),
                  (u = new WeakMap()),
                  (h = new WeakMap()),
                  (p = new WeakMap()),
                  (m = new WeakMap()),
                  (f = new WeakMap()),
                  (g = new WeakMap()),
                  (b = new WeakMap()),
                  (r = new WeakSet()),
                  (y = async function () {
                    if (B(this, p, 'f') && !B(this, g, 'f')) {
                      const { ppomInit: e } = B(this, c, 'f');
                      await e('./ppom_bg.wasm'), j(this, g, !0, 'f');
                    }
                  }),
                  (w = function () {
                    B(this, r, 'm', _)
                      .call(this)
                      .catch(e => {
                        console.error(`Error in resetting ppom: ${e.message}`);
                      });
                    const { storageMetadata: e } = this.state;
                    this.update(e => {
                      (e.versionInfo = []), (e.storageMetadata = []);
                    }),
                      B(this, o, 'f')
                        .deleteAllFiles(e)
                        .catch(e => {
                          console.error(`Error in deleting files: ${e.message}`);
                        });
                  }),
                  (v = function (e) {
                    const t = this.messagingSystem.call(
                        'NetworkController:getNetworkClientById',
                        e.selectedNetworkClientId
                      ),
                      { chainId: n } = t.configuration,
                      s = (0, q.addHexPrefix)(n);
                    s !== B(this, h, 'f') &&
                      (j(this, h, s, 'f'),
                      B(this, r, 'm', _)
                        .call(this)
                        .catch(e => {
                          console.error(`Error in resetting ppom: ${e.message}`);
                        }));
                  }),
                  (C = function (e) {
                    const t = e.securityAlertsEnabled;
                    t !== B(this, p, 'f') &&
                      (j(this, p, t, 'f'), t || B(this, r, 'm', w).call(this));
                  }),
                  (k = function () {
                    this.messagingSystem.registerActionHandler(
                      `${V}:usePPOM`,
                      this.usePPOM.bind(this)
                    );
                  }),
                  (S = function () {
                    const e = B(this, r, 'm', v).bind(this);
                    this.messagingSystem.subscribe('NetworkController:networkDidChange', e);
                  }),
                  (_ = async function () {
                    await B(this, i, 'f').use(async () => {
                      B(this, s, 'f') && (B(this, s, 'f').free(), j(this, s, undefined, 'f'));
                    });
                  }),
                  (E = async function (e) {
                    const t = await B(this, r, 'm', T).call(this);
                    let n;
                    return (
                      (B(this, s, 'f') === undefined || t) &&
                        ((n = await B(this, r, 'm', O).call(this, e)),
                        B(this, h, 'f') === e &&
                          (B(this, s, 'f') && B(this, s, 'f').free(), j(this, s, n, 'f')),
                        B(this, o, 'f')
                          .syncMetadata(this.state.versionInfo)
                          .catch(e => {
                            console.error(`Error while trying to sync metadata: ${e.message}`);
                          })),
                      n
                    );
                  }),
                  (T = async function () {
                    const e = await B(this, r, 'm', I).call(this);
                    return (
                      !!e &&
                      (this.update(t => {
                        t.versionInfo = e;
                      }),
                      !0)
                    );
                  }),
                  (M = function (e, t) {
                    return e.find(
                      e =>
                        e.name === t.name &&
                        e.chainId === t.chainId &&
                        e.version === t.version &&
                        e.checksum === t.checksum
                    );
                  }),
                  (P = async function (e) {
                    const t = await Promise.all(
                      e.map(async e => {
                        let t;
                        try {
                          t = await B(this, r, 'm', A).call(this, e);
                        } catch (t) {
                          console.error(`Error in getting file ${e.filePath}: ${t.message}`);
                        }
                        return t ? [e.name, new Uint8Array(t)] : undefined;
                      })
                    );
                    return t?.filter(e => e?.[1] !== undefined);
                  }),
                  (A = async function (e) {
                    const { storageMetadata: t } = this.state;
                    if (B(this, r, 'm', M).call(this, t, e))
                      try {
                        return await B(this, o, 'f').readFile(e.name, e.chainId);
                      } catch (e) {
                        console.error(`Error in reading file: ${e.message}`);
                      }
                    (0, q.checkFilePath)(e.filePath);
                    const n = (0, q.constructURLHref)(B(this, l, 'f'), e.filePath),
                      s = await B(this, r, 'm', x).call(this, n);
                    return (
                      await (0, q.validateSignature)(
                        s,
                        e.hashSignature,
                        B(this, f, 'f'),
                        e.filePath,
                        B(this, b, 'f')
                      ),
                      await B(this, o, 'f')
                        .writeFile({ data: s, ...e })
                        .catch(e => {
                          console.error(`Error in writing file: ${e.message}`);
                        }),
                      s
                    );
                  }),
                  (N = async function (e, t = {}, n = 'GET') {
                    const r = await (0, D.safelyExecute)(
                        async () =>
                          (0, D.timeoutFetch)(
                            e,
                            { method: n, cache: 'no-cache', redirect: 'error', ...t },
                            1e4
                          ),
                        !0
                      ),
                      s = 304 === r?.status;
                    if (!r?.status || r?.status < 200 || r?.status > 399)
                      throw new Error(`Failed to fetch file with url: ${e}`);
                    return { cached: s, response: r };
                  }),
                  (I = async function () {
                    const e = (0, q.constructURLHref)(B(this, l, 'f'), 'ppom_version.json'),
                      { cached: t, response: n } = await B(this, r, 'm', N).call(this, e, {
                        headers: K,
                      });
                    return t && this.state.versionInfo?.length ? undefined : n.json();
                  }),
                  (x = async function (e) {
                    const { response: t } = await B(this, r, 'm', N).call(this, e);
                    return await t.arrayBuffer();
                  }),
                  (R = async function (e, t) {
                    if (B(this, u, 'f') > B(this, d, 'f')) return q.PROVIDER_ERRORS.limitExceeded();
                    if ((j(this, u, B(this, u, 'f') + 1, 'f'), !U.includes(e)))
                      return q.PROVIDER_ERRORS.methodNotSupported();
                    B(this, m, 'f')[e] = B(this, m, 'f')[e] ? Number(B(this, m, 'f')[e]) + 1 : 1;
                    const n = (0, q.createPayload)(e, t);
                    try {
                      const e = await B(this, a, 'f').request(n);
                      return { jsonrpc: '2.0', id: n.id, result: e };
                    } catch (e) {
                      return { jsonrpc: '2.0', id: n.id, error: e };
                    }
                  }),
                  (O = async function (e) {
                    await B(this, r, 'm', y).call(this);
                    const t = this.state.versionInfo.filter(({ chainId: t }) => t === e);
                    if (t?.length === undefined || 0 === t?.length)
                      throw new Error(
                        `Aborting initialising PPOM as no files are found for the network with chainId: ${e}`
                      );
                    const n = await B(this, r, 'm', P).call(this, t);
                    if (n?.length !== t?.length)
                      throw new Error(
                        `Aborting initialising PPOM as not all files could not be downloaded for the network with chainId: ${e}`
                      );
                    const { PPOM: s } = B(this, c, 'f');
                    return s.new(B(this, r, 'm', R).bind(this), n);
                  });
              };
            };
      },
      {
        package: '@metamask/ppom-validator',
        file: 'node_modules/@metamask/ppom-validator/dist/ppom-controller.js',
      },
    ],
    [
      245,
      { lodash: 4921 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = void 0);
                var r = e('lodash');
                n.default = {
                  version: 41,
                  async migrate(e) {
                    const t = (0, r.cloneDeep)(e);
                    t.meta.version = 41;
                    const n = t.data;
                    return (
                      (t.data = (function (e) {
                        e.PreferencesController &&
                          e.PreferencesController.preferences &&
                          ((e.PreferencesController.preferences.autoLockTimeLimit =
                            e.PreferencesController.preferences.autoLogoutTimeLimit),
                          delete e.PreferencesController.preferences.autoLogoutTimeLimit);
                        return e;
                      })(n)),
                      t
                    );
                  },
                };
              };
            };
      },
      { package: '$root$', file: 'app/scripts/migrations/041.js' },
    ],
    [
      2450,
      {},
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                var r,
                  s,
                  a,
                  o =
                    (this && this.__classPrivateFieldSet) ||
                    function (e, t, n, r, s) {
                      if ('m' === r) throw new TypeError('Private method is not writable');
                      if ('a' === r && !s)
                        throw new TypeError('Private accessor was defined without a setter');
                      if ('function' == typeof t ? e !== t || !s : !t.has(e))
                        throw new TypeError(
                          'Cannot write private member to an object whose class did not declare it'
                        );
                      return 'a' === r ? s.call(e, n) : s ? (s.value = n) : t.set(e, n), n;
                    },
                  i =
                    (this && this.__classPrivateFieldGet) ||
                    function (e, t, n, r) {
                      if ('a' === n && !r)
                        throw new TypeError('Private accessor was defined without a getter');
                      if ('function' == typeof t ? e !== t || !r : !t.has(e))
                        throw new TypeError(
                          'Cannot read private member from an object whose class did not declare it'
                        );
                      return 'm' === n ? r : 'a' === n ? r.call(e) : r ? r.value : t.get(e);
                    };
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.PPOMStorage = void 0);
                (n.PPOMStorage = class {
                  constructor({ storageBackend: e, readMetadata: t, writeMetadata: n }) {
                    r.set(this, void 0),
                      s.set(this, void 0),
                      a.set(this, void 0),
                      o(this, r, e, 'f'),
                      o(this, s, t, 'f'),
                      o(this, a, n, 'f');
                  }
                  async syncMetadata(e) {
                    const t = i(this, s, 'f').call(this),
                      n = [];
                    for (const r of t) {
                      try {
                        await this.readFile(r.name, r.chainId);
                      } catch (e) {
                        console.error('Error: ', e);
                        continue;
                      }
                      e.find(
                        e =>
                          e.name === r.name &&
                          e.chainId === r.chainId &&
                          e.version === r.version &&
                          e.checksum === r.checksum
                      ) && n.push(r);
                    }
                    const o = await i(this, r, 'f').dir();
                    for (const { name: e, chainId: t } of o)
                      n.find(n => n.name === e && n.chainId === t) ||
                        (await i(this, r, 'f').delete({ name: e, chainId: t }));
                    return i(this, a, 'f').call(this, n), n;
                  }
                  async deleteAllFiles(e) {
                    for (const t of e) {
                      const { name: e, chainId: n } = t;
                      try {
                        await i(this, r, 'f').delete({ name: e, chainId: n });
                      } catch (t) {
                        console.error(`Error in deleting file: ${e}, ${n}`, t);
                      }
                    }
                  }
                  async readFile(e, t) {
                    const n = i(this, s, 'f')
                      .call(this)
                      .find(n => n.name === e && n.chainId === t);
                    if (!n) throw new Error(`File metadata (${e}, ${t}) not found`);
                    const a = await i(this, r, 'f').read({ name: e, chainId: t }, n.checksum);
                    if (!a) throw new Error(`Storage File (${e}, ${t}) not found`);
                    return a;
                  }
                  async writeFile({ data: e, name: t, chainId: n, version: o, checksum: c }) {
                    await i(this, r, 'f').write({ name: t, chainId: n }, e, c);
                    const l = i(this, s, 'f').call(this),
                      d = l.find(e => e.name === t && e.chainId === n);
                    d
                      ? ((d.version = o), (d.checksum = c))
                      : l.push({ name: t, chainId: n, version: o, checksum: c }),
                      i(this, a, 'f').call(this, l);
                  }
                }),
                  (r = new WeakMap()),
                  (s = new WeakMap()),
                  (a = new WeakMap());
              };
            };
      },
      {
        package: '@metamask/ppom-validator',
        file: 'node_modules/@metamask/ppom-validator/dist/ppom-storage.js',
      },
    ],
    [
      2451,
      { buffer: 4139, 'crypto-js': 4258, elliptic: 4314, 'json-rpc-random-id': 4753 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                (function (t) {
                  (function () {
                    var r =
                        (this && this.__createBinding) ||
                        (Object.create
                          ? function (e, t, n, r) {
                              r === undefined && (r = n);
                              var s = Object.getOwnPropertyDescriptor(t, n);
                              (s && !('get' in s ? !t.__esModule : s.writable || s.configurable)) ||
                                (s = {
                                  enumerable: !0,
                                  get: function () {
                                    return t[n];
                                  },
                                }),
                                Object.defineProperty(e, r, s);
                            }
                          : function (e, t, n, r) {
                              r === undefined && (r = n), (e[r] = t[n]);
                            }),
                      s =
                        (this && this.__setModuleDefault) ||
                        (Object.create
                          ? function (e, t) {
                              Object.defineProperty(e, 'default', { enumerable: !0, value: t });
                            }
                          : function (e, t) {
                              e.default = t;
                            }),
                      a =
                        (this && this.__importStar) ||
                        function (e) {
                          if (e && e.__esModule) return e;
                          var t = {};
                          if (null != e)
                            for (var n in e)
                              'default' !== n &&
                                Object.prototype.hasOwnProperty.call(e, n) &&
                                r(t, e, n);
                          return s(t, e), t;
                        },
                      o =
                        (this && this.__importDefault) ||
                        function (e) {
                          return e && e.__esModule ? e : { default: e };
                        };
                    Object.defineProperty(n, '__esModule', { value: !0 }),
                      (n.checkFilePath =
                        n.addHexPrefix =
                        n.constructURLHref =
                        n.validateSignature =
                        n.PROVIDER_ERRORS =
                        n.createPayload =
                        n.IdGenerator =
                        n.blockaidValidationSupportedForNetwork =
                        n.SUPPORTED_NETWORK_CHAINIDS =
                          void 0);
                    const i = a(e('crypto-js')),
                      c = o(e('elliptic')),
                      l = o(e('json-rpc-random-id')),
                      d = c.default.eddsa;
                    n.SUPPORTED_NETWORK_CHAINIDS = {
                      MAINNET: '0x1',
                      BSC: '0x38',
                      OPTIMISM: '0xa',
                      POLYGON: '0x89',
                      AVALANCHE: '0xa86a',
                      ARBITRUM: '0xa4b1',
                      LINEA_MAINNET: '0xe708',
                      BASE: '0x2105',
                      SEPOLIA: '0xaa36a7',
                      OPBNB: '0xcc',
                      ZKSYNC: '0x144',
                      SCROLL: '0x82750',
                      BERACHAIN: '0x138d4',
                      METACHAIN_ONE: '0x1b6e6',
                    };
                    (n.blockaidValidationSupportedForNetwork = e =>
                      Object.values(n.SUPPORTED_NETWORK_CHAINIDS).some(t => t === e)),
                      (n.IdGenerator = (0, l.default)());
                    (n.createPayload = (e, t) => ({
                      id: (0, n.IdGenerator)(),
                      jsonrpc: '2.0',
                      method: e,
                      params: t ?? [],
                    })),
                      (n.PROVIDER_ERRORS = {
                        limitExceeded: () => ({
                          jsonrpc: '2.0',
                          id: (0, n.IdGenerator)(),
                          error: { code: -32005, message: 'Limit exceeded' },
                        }),
                        methodNotSupported: () => ({
                          jsonrpc: '2.0',
                          id: (0, n.IdGenerator)(),
                          error: { code: -32601, message: 'Method not supported' },
                        }),
                      });
                    n.validateSignature = async (e, n, r, s, a, o) => {
                      const c = await (async (e, t, n = !0) => {
                        if (t) return t.createHash('sha256').update(e).digest('hex');
                        if (
                          'crypto' in globalThis &&
                          'object' == typeof globalThis.crypto &&
                          globalThis.crypto.subtle?.digest &&
                          n
                        ) {
                          const t = await globalThis.crypto.subtle.digest('SHA-256', e);
                          return Array.from(new Uint8Array(t))
                            .map(e => e.toString(16).padStart(2, '0'))
                            .join('');
                        }
                        return (0, i.SHA256)(i.default.lib.WordArray.create(e)).toString();
                      })(e, a, o);
                      if (!new d('ed25519').keyFromPublic(r).verify(t.from(c), n))
                        throw Error(`Signature verification failed for file path: ${s}`);
                    };
                    n.constructURLHref = (e, t) =>
                      new URL(
                        `https://${e}/${t}`
                          .replace(/https:\/\/https:\/\//gu, 'https://')
                          .replace(/\/\//gu, '/')
                      ).href;
                    n.addHexPrefix = e =>
                      'string' != typeof e || e.match(/^-?0x/u)
                        ? e
                        : e.match(/^-?0X/u)
                          ? e.replace('0X', '0x')
                          : `0x${parseInt(e, 10).toString(16)}`;
                    n.checkFilePath = e => {
                      if (!e.match(/^[\w./]+$/u))
                        throw new Error(`Invalid file path for data file: ${e}`);
                    };
                  }).call(this);
                }).call(this, e('buffer').Buffer);
              };
            };
      },
      {
        package: '@metamask/ppom-validator',
        file: 'node_modules/@metamask/ppom-validator/dist/util.js',
      },
    ],
    [
      2452,
      {},
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.BaseControllerV1 = n.isBaseControllerV1 = void 0),
                  (n.isBaseControllerV1 = function (e) {
                    return (
                      'name' in e &&
                      'string' == typeof e.name &&
                      'config' in e &&
                      'object' == typeof e.config &&
                      'defaultConfig' in e &&
                      'object' == typeof e.defaultConfig &&
                      'state' in e &&
                      'object' == typeof e.state &&
                      'defaultState' in e &&
                      'object' == typeof e.defaultState &&
                      'disabled' in e &&
                      'boolean' == typeof e.disabled &&
                      'subscribe' in e &&
                      'function' == typeof e.subscribe
                    );
                  });
                class r {
                  constructor(e = {}, t = {}) {
                    (this.defaultConfig = {}),
                      (this.defaultState = {}),
                      (this.disabled = !1),
                      (this.name = 'BaseController'),
                      (this.internalConfig = this.defaultConfig),
                      (this.internalState = this.defaultState),
                      (this.internalListeners = []),
                      (this.initialState = t),
                      (this.initialConfig = e);
                  }
                  initialize() {
                    return (
                      (this.internalState = this.defaultState),
                      (this.internalConfig = this.defaultConfig),
                      this.configure(this.initialConfig),
                      this.update(this.initialState),
                      this
                    );
                  }
                  get config() {
                    return this.internalConfig;
                  }
                  get state() {
                    return this.internalState;
                  }
                  configure(e, t = !1, n = !0) {
                    if (n) {
                      this.internalConfig = t ? e : Object.assign(this.internalConfig, e);
                      for (const e of Object.keys(this.internalConfig)) {
                        const t = this.internalConfig[e];
                        t !== undefined && (this[e] = t);
                      }
                    } else
                      for (const t of Object.keys(e))
                        if (this.internalConfig[t] !== undefined) {
                          const n = e[t];
                          (this.internalConfig[t] = n), (this[t] = n);
                        }
                  }
                  notify() {
                    this.disabled ||
                      this.internalListeners.forEach(e => {
                        e(this.internalState);
                      });
                  }
                  subscribe(e) {
                    this.internalListeners.push(e);
                  }
                  unsubscribe(e) {
                    const t = this.internalListeners.findIndex(t => e === t);
                    return t > -1 && this.internalListeners.splice(t, 1), t > -1;
                  }
                  update(e, t = !1) {
                    (this.internalState = t
                      ? Object.assign({}, e)
                      : Object.assign({}, this.internalState, e)),
                      this.notify();
                  }
                }
                (n.BaseControllerV1 = r), (n.default = r);
              };
            };
      },
      {
        package: '@metamask/ppom-validator>@metamask/base-controller',
        file: 'node_modules/@metamask/ppom-validator/node_modules/@metamask/base-controller/dist/BaseControllerV1.cjs',
      },
    ],
    [
      2453,
      { immer: 4715 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                var r,
                  s =
                    (this && this.__classPrivateFieldSet) ||
                    function (e, t, n, r, s) {
                      if ('m' === r) throw new TypeError('Private method is not writable');
                      if ('a' === r && !s)
                        throw new TypeError('Private accessor was defined without a setter');
                      if ('function' == typeof t ? e !== t || !s : !t.has(e))
                        throw new TypeError(
                          'Cannot write private member to an object whose class did not declare it'
                        );
                      return 'a' === r ? s.call(e, n) : s ? (s.value = n) : t.set(e, n), n;
                    },
                  a =
                    (this && this.__classPrivateFieldGet) ||
                    function (e, t, n, r) {
                      if ('a' === n && !r)
                        throw new TypeError('Private accessor was defined without a getter');
                      if ('function' == typeof t ? e !== t || !r : !t.has(e))
                        throw new TypeError(
                          'Cannot read private member from an object whose class did not declare it'
                        );
                      return 'm' === n ? r : 'a' === n ? r.call(e) : r ? r.value : t.get(e);
                    };
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.getPersistentState =
                    n.getAnonymizedState =
                    n.BaseController =
                    n.isBaseController =
                      void 0);
                const o = e('immer');
                (0, o.enablePatches)(),
                  (n.isBaseController = function (e) {
                    return (
                      'name' in e &&
                      'string' == typeof e.name &&
                      'state' in e &&
                      'object' == typeof e.state &&
                      'metadata' in e &&
                      'object' == typeof e.metadata
                    );
                  });
                function i(e, t, n) {
                  return Object.keys(e).reduce((r, s) => {
                    try {
                      const a = t[s];
                      if (!a) throw new Error(`No metadata found for '${String(s)}'`);
                      const o = a[n],
                        i = e[s];
                      return 'function' == typeof o ? (r[s] = o(i)) : o && (r[s] = i), r;
                    } catch (e) {
                      return (
                        setTimeout(() => {
                          throw e;
                        }),
                        r
                      );
                    }
                  }, {});
                }
                (n.BaseController = class {
                  constructor({ messenger: e, metadata: t, name: n, state: a }) {
                    r.set(this, void 0),
                      (this.messagingSystem = e),
                      (this.name = n),
                      s(this, r, (0, o.freeze)(a, !0), 'f'),
                      (this.metadata = t),
                      this.messagingSystem.registerActionHandler(`${n}:getState`, () => this.state),
                      this.messagingSystem.registerInitialEventPayload({
                        eventType: `${n}:stateChange`,
                        getPayload: () => [this.state, []],
                      });
                  }
                  get state() {
                    return a(this, r, 'f');
                  }
                  set state(e) {
                    throw new Error(
                      "Controller state cannot be directly mutated; use 'update' method instead."
                    );
                  }
                  update(e) {
                    const [t, n, i] = o.produceWithPatches(a(this, r, 'f'), e);
                    return (
                      s(this, r, t, 'f'),
                      this.messagingSystem.publish(`${this.name}:stateChange`, t, n),
                      { nextState: t, patches: n, inversePatches: i }
                    );
                  }
                  applyPatches(e) {
                    const t = (0, o.applyPatches)(a(this, r, 'f'), e);
                    s(this, r, t, 'f'),
                      this.messagingSystem.publish(`${this.name}:stateChange`, t, e);
                  }
                  destroy() {
                    this.messagingSystem.clearEventSubscriptions(`${this.name}:stateChange`);
                  }
                }),
                  (r = new WeakMap()),
                  (n.getAnonymizedState = function (e, t) {
                    return i(e, t, 'anonymous');
                  }),
                  (n.getPersistentState = function (e, t) {
                    return i(e, t, 'persist');
                  });
              };
            };
      },
      {
        package: '@metamask/ppom-validator>@metamask/base-controller',
        file: 'node_modules/@metamask/ppom-validator/node_modules/@metamask/base-controller/dist/BaseControllerV2.cjs',
      },
    ],
    [
      2454,
      { './RestrictedMessenger.cjs': 2455 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                var r,
                  s,
                  a,
                  o,
                  i =
                    (this && this.__classPrivateFieldGet) ||
                    function (e, t, n, r) {
                      if ('a' === n && !r)
                        throw new TypeError('Private accessor was defined without a getter');
                      if ('function' == typeof t ? e !== t || !r : !t.has(e))
                        throw new TypeError(
                          'Cannot read private member from an object whose class did not declare it'
                        );
                      return 'm' === n ? r : 'a' === n ? r.call(e) : r ? r.value : t.get(e);
                    };
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.ControllerMessenger = n.Messenger = void 0);
                const c = e('./RestrictedMessenger.cjs');
                class l {
                  constructor() {
                    r.set(this, new Map()),
                      s.set(this, new Map()),
                      a.set(this, new Map()),
                      o.set(this, new Map());
                  }
                  registerActionHandler(e, t) {
                    if (i(this, r, 'f').has(e))
                      throw new Error(`A handler for ${e} has already been registered`);
                    i(this, r, 'f').set(e, t);
                  }
                  unregisterActionHandler(e) {
                    i(this, r, 'f').delete(e);
                  }
                  clearActions() {
                    i(this, r, 'f').clear();
                  }
                  call(e, ...t) {
                    const n = i(this, r, 'f').get(e);
                    if (!n) throw new Error(`A handler for ${e} has not been registered`);
                    return n(...t);
                  }
                  registerInitialEventPayload({ eventType: e, getPayload: t }) {
                    i(this, a, 'f').set(e, t);
                  }
                  publish(e, ...t) {
                    const n = i(this, s, 'f').get(e);
                    if (n)
                      for (const [e, r] of n.entries())
                        try {
                          if (r) {
                            const n = i(this, o, 'f').get(e),
                              s = r(...t);
                            s !== n && (i(this, o, 'f').set(e, s), e(s, n));
                          } else e(...t);
                        } catch (e) {
                          setTimeout(() => {
                            throw e;
                          });
                        }
                  }
                  subscribe(e, t, n) {
                    let r = i(this, s, 'f').get(e);
                    if ((r || ((r = new Map()), i(this, s, 'f').set(e, r)), r.set(t, n), n)) {
                      const r = i(this, a, 'f').get(e);
                      if (r) {
                        const e = n(...r());
                        i(this, o, 'f').set(t, e);
                      }
                    }
                  }
                  unsubscribe(e, t) {
                    const n = i(this, s, 'f').get(e);
                    if (!n || !n.has(t)) throw new Error(`Subscription not found for event: ${e}`);
                    n.get(t) && i(this, o, 'f').delete(t), n.delete(t);
                  }
                  clearEventSubscriptions(e) {
                    i(this, s, 'f').delete(e);
                  }
                  clearSubscriptions() {
                    i(this, s, 'f').clear();
                  }
                  getRestricted({ name: e, allowedActions: t, allowedEvents: n }) {
                    return new c.RestrictedMessenger({
                      messenger: this,
                      name: e,
                      allowedActions: t,
                      allowedEvents: n,
                    });
                  }
                }
                (n.Messenger = l),
                  (n.ControllerMessenger = l),
                  (r = new WeakMap()),
                  (s = new WeakMap()),
                  (a = new WeakMap()),
                  (o = new WeakMap());
              };
            };
      },
      {
        package: '@metamask/ppom-validator>@metamask/base-controller',
        file: 'node_modules/@metamask/ppom-validator/node_modules/@metamask/base-controller/dist/Messenger.cjs',
      },
    ],
    [
      2455,
      {},
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                var r,
                  s,
                  a,
                  o,
                  i,
                  c,
                  l,
                  d,
                  u =
                    (this && this.__classPrivateFieldSet) ||
                    function (e, t, n, r, s) {
                      if ('m' === r) throw new TypeError('Private method is not writable');
                      if ('a' === r && !s)
                        throw new TypeError('Private accessor was defined without a setter');
                      if ('function' == typeof t ? e !== t || !s : !t.has(e))
                        throw new TypeError(
                          'Cannot write private member to an object whose class did not declare it'
                        );
                      return 'a' === r ? s.call(e, n) : s ? (s.value = n) : t.set(e, n), n;
                    },
                  h =
                    (this && this.__classPrivateFieldGet) ||
                    function (e, t, n, r) {
                      if ('a' === n && !r)
                        throw new TypeError('Private accessor was defined without a getter');
                      if ('function' == typeof t ? e !== t || !r : !t.has(e))
                        throw new TypeError(
                          'Cannot read private member from an object whose class did not declare it'
                        );
                      return 'm' === n ? r : 'a' === n ? r.call(e) : r ? r.value : t.get(e);
                    };
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.RestrictedControllerMessenger = n.RestrictedMessenger = void 0);
                class p {
                  constructor({
                    controllerMessenger: e,
                    messenger: t,
                    name: n,
                    allowedActions: c,
                    allowedEvents: l,
                  }) {
                    if (
                      (r.add(this),
                      s.set(this, void 0),
                      a.set(this, void 0),
                      o.set(this, void 0),
                      i.set(this, void 0),
                      t && e)
                    )
                      throw new Error(
                        "Both messenger properties provided. Provide message using only 'messenger' option, 'controllerMessenger' is deprecated"
                      );
                    if (!t && !e) throw new Error('Messenger not provided');
                    u(this, s, t ?? e, 'f'),
                      u(this, a, n, 'f'),
                      u(this, o, c, 'f'),
                      u(this, i, l, 'f');
                  }
                  registerActionHandler(e, t) {
                    if (!h(this, r, 'm', d).call(this, e))
                      throw new Error(
                        `Only allowed registering action handlers prefixed by '${h(this, a, 'f')}:'`
                      );
                    h(this, s, 'f').registerActionHandler(e, t);
                  }
                  unregisterActionHandler(e) {
                    if (!h(this, r, 'm', d).call(this, e))
                      throw new Error(
                        `Only allowed unregistering action handlers prefixed by '${h(this, a, 'f')}:'`
                      );
                    h(this, s, 'f').unregisterActionHandler(e);
                  }
                  call(e, ...t) {
                    if (!h(this, r, 'm', l).call(this, e))
                      throw new Error(`Action missing from allow list: ${e}`);
                    return h(this, s, 'f').call(e, ...t);
                  }
                  registerInitialEventPayload({ eventType: e, getPayload: t }) {
                    if (!h(this, r, 'm', d).call(this, e))
                      throw new Error(
                        `Only allowed publishing events prefixed by '${h(this, a, 'f')}:'`
                      );
                    h(this, s, 'f').registerInitialEventPayload({ eventType: e, getPayload: t });
                  }
                  publish(e, ...t) {
                    if (!h(this, r, 'm', d).call(this, e))
                      throw new Error(
                        `Only allowed publishing events prefixed by '${h(this, a, 'f')}:'`
                      );
                    h(this, s, 'f').publish(e, ...t);
                  }
                  subscribe(e, t, n) {
                    if (!h(this, r, 'm', c).call(this, e))
                      throw new Error(`Event missing from allow list: ${e}`);
                    return n ? h(this, s, 'f').subscribe(e, t, n) : h(this, s, 'f').subscribe(e, t);
                  }
                  unsubscribe(e, t) {
                    if (!h(this, r, 'm', c).call(this, e))
                      throw new Error(`Event missing from allow list: ${e}`);
                    h(this, s, 'f').unsubscribe(e, t);
                  }
                  clearEventSubscriptions(e) {
                    if (!h(this, r, 'm', d).call(this, e))
                      throw new Error(
                        `Only allowed clearing events prefixed by '${h(this, a, 'f')}:'`
                      );
                    h(this, s, 'f').clearEventSubscriptions(e);
                  }
                }
                (n.RestrictedMessenger = p),
                  (n.RestrictedControllerMessenger = p),
                  (s = new WeakMap()),
                  (a = new WeakMap()),
                  (o = new WeakMap()),
                  (i = new WeakMap()),
                  (r = new WeakSet()),
                  (c = function (e) {
                    const t = h(this, i, 'f');
                    return h(this, r, 'm', d).call(this, e) || (null !== t && t.includes(e));
                  }),
                  (l = function (e) {
                    const t = h(this, o, 'f');
                    return h(this, r, 'm', d).call(this, e) || (null !== t && t.includes(e));
                  }),
                  (d = function (e) {
                    return e.startsWith(`${h(this, a, 'f')}:`);
                  });
              };
            };
      },
      {
        package: '@metamask/ppom-validator>@metamask/base-controller',
        file: 'node_modules/@metamask/ppom-validator/node_modules/@metamask/base-controller/dist/RestrictedMessenger.cjs',
      },
    ],
    [
      2456,
      {
        './BaseControllerV1.cjs': 2452,
        './BaseControllerV2.cjs': 2453,
        './Messenger.cjs': 2454,
        './RestrictedMessenger.cjs': 2455,
      },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.RestrictedMessenger =
                    n.RestrictedControllerMessenger =
                    n.Messenger =
                    n.ControllerMessenger =
                    n.isBaseController =
                    n.getPersistentState =
                    n.getAnonymizedState =
                    n.BaseController =
                    n.isBaseControllerV1 =
                    n.BaseControllerV1 =
                      void 0);
                var r = e('./BaseControllerV1.cjs');
                Object.defineProperty(n, 'BaseControllerV1', {
                  enumerable: !0,
                  get: function () {
                    return r.BaseControllerV1;
                  },
                }),
                  Object.defineProperty(n, 'isBaseControllerV1', {
                    enumerable: !0,
                    get: function () {
                      return r.isBaseControllerV1;
                    },
                  });
                var s = e('./BaseControllerV2.cjs');
                Object.defineProperty(n, 'BaseController', {
                  enumerable: !0,
                  get: function () {
                    return s.BaseController;
                  },
                }),
                  Object.defineProperty(n, 'getAnonymizedState', {
                    enumerable: !0,
                    get: function () {
                      return s.getAnonymizedState;
                    },
                  }),
                  Object.defineProperty(n, 'getPersistentState', {
                    enumerable: !0,
                    get: function () {
                      return s.getPersistentState;
                    },
                  }),
                  Object.defineProperty(n, 'isBaseController', {
                    enumerable: !0,
                    get: function () {
                      return s.isBaseController;
                    },
                  });
                var a = e('./Messenger.cjs');
                Object.defineProperty(n, 'ControllerMessenger', {
                  enumerable: !0,
                  get: function () {
                    return a.ControllerMessenger;
                  },
                }),
                  Object.defineProperty(n, 'Messenger', {
                    enumerable: !0,
                    get: function () {
                      return a.Messenger;
                    },
                  });
                var o = e('./RestrictedMessenger.cjs');
                Object.defineProperty(n, 'RestrictedControllerMessenger', {
                  enumerable: !0,
                  get: function () {
                    return o.RestrictedControllerMessenger;
                  },
                }),
                  Object.defineProperty(n, 'RestrictedMessenger', {
                    enumerable: !0,
                    get: function () {
                      return o.RestrictedMessenger;
                    },
                  });
              };
            };
      },
      {
        package: '@metamask/ppom-validator>@metamask/base-controller',
        file: 'node_modules/@metamask/ppom-validator/node_modules/@metamask/base-controller/dist/index.cjs',
      },
    ],
    [
      2457,
      {
        './constants.cjs': 2458,
        '@metamask/base-controller': 1407,
        '@metamask/controller-utils': 1515,
      },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                var r,
                  s,
                  a =
                    (this && this.__classPrivateFieldGet) ||
                    function (e, t, n, r) {
                      if ('a' === n && !r)
                        throw new TypeError('Private accessor was defined without a getter');
                      if ('function' == typeof t ? e !== t || !r : !t.has(e))
                        throw new TypeError(
                          'Cannot read private member from an object whose class did not declare it'
                        );
                      return 'm' === n ? r : 'a' === n ? r.call(e) : r ? r.value : t.get(e);
                    };
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.PreferencesController = n.getDefaultPreferencesState = void 0);
                const o = e('@metamask/base-controller'),
                  i = e('@metamask/controller-utils'),
                  c = e('./constants.cjs'),
                  l = {
                    featureFlags: { persist: !0, anonymous: !0 },
                    identities: { persist: !0, anonymous: !1 },
                    ipfsGateway: { persist: !0, anonymous: !1 },
                    isIpfsGatewayEnabled: { persist: !0, anonymous: !0 },
                    isMultiAccountBalancesEnabled: { persist: !0, anonymous: !0 },
                    lostIdentities: { persist: !0, anonymous: !1 },
                    openSeaEnabled: { persist: !0, anonymous: !0 },
                    securityAlertsEnabled: { persist: !0, anonymous: !0 },
                    selectedAddress: { persist: !0, anonymous: !1 },
                    showTestNetworks: { persist: !0, anonymous: !0 },
                    showIncomingTransactions: { persist: !0, anonymous: !0 },
                    useNftDetection: { persist: !0, anonymous: !0 },
                    useTokenDetection: { persist: !0, anonymous: !0 },
                    smartTransactionsOptInStatus: { persist: !0, anonymous: !1 },
                    useTransactionSimulations: { persist: !0, anonymous: !0 },
                    useMultiRpcMigration: { persist: !0, anonymous: !0 },
                    useSafeChainsListValidation: { persist: !0, anonymous: !0 },
                    tokenSortConfig: { persist: !0, anonymous: !0 },
                    privacyMode: { persist: !0, anonymous: !0 },
                  };
                function d() {
                  return {
                    featureFlags: {},
                    identities: {},
                    ipfsGateway: 'https://ipfs.io/ipfs/',
                    isIpfsGatewayEnabled: !0,
                    isMultiAccountBalancesEnabled: !0,
                    lostIdentities: {},
                    openSeaEnabled: !1,
                    securityAlertsEnabled: !1,
                    selectedAddress: '',
                    showIncomingTransactions: {
                      [c.ETHERSCAN_SUPPORTED_CHAIN_IDS.MAINNET]: !0,
                      [c.ETHERSCAN_SUPPORTED_CHAIN_IDS.GOERLI]: !0,
                      [c.ETHERSCAN_SUPPORTED_CHAIN_IDS.BSC]: !0,
                      [c.ETHERSCAN_SUPPORTED_CHAIN_IDS.BSC_TESTNET]: !0,
                      [c.ETHERSCAN_SUPPORTED_CHAIN_IDS.OPTIMISM]: !0,
                      [c.ETHERSCAN_SUPPORTED_CHAIN_IDS.OPTIMISM_SEPOLIA]: !0,
                      [c.ETHERSCAN_SUPPORTED_CHAIN_IDS.POLYGON]: !0,
                      [c.ETHERSCAN_SUPPORTED_CHAIN_IDS.POLYGON_TESTNET]: !0,
                      [c.ETHERSCAN_SUPPORTED_CHAIN_IDS.AVALANCHE]: !0,
                      [c.ETHERSCAN_SUPPORTED_CHAIN_IDS.AVALANCHE_TESTNET]: !0,
                      [c.ETHERSCAN_SUPPORTED_CHAIN_IDS.FANTOM]: !0,
                      [c.ETHERSCAN_SUPPORTED_CHAIN_IDS.FANTOM_TESTNET]: !0,
                      [c.ETHERSCAN_SUPPORTED_CHAIN_IDS.SEPOLIA]: !0,
                      [c.ETHERSCAN_SUPPORTED_CHAIN_IDS.LINEA_GOERLI]: !0,
                      [c.ETHERSCAN_SUPPORTED_CHAIN_IDS.LINEA_SEPOLIA]: !0,
                      [c.ETHERSCAN_SUPPORTED_CHAIN_IDS.LINEA_MAINNET]: !0,
                      [c.ETHERSCAN_SUPPORTED_CHAIN_IDS.MOONBEAM]: !0,
                      [c.ETHERSCAN_SUPPORTED_CHAIN_IDS.MOONBEAM_TESTNET]: !0,
                      [c.ETHERSCAN_SUPPORTED_CHAIN_IDS.MOONRIVER]: !0,
                      [c.ETHERSCAN_SUPPORTED_CHAIN_IDS.GNOSIS]: !0,
                    },
                    showTestNetworks: !1,
                    useNftDetection: !1,
                    useTokenDetection: !0,
                    useMultiRpcMigration: !0,
                    smartTransactionsOptInStatus: !0,
                    useTransactionSimulations: !0,
                    useSafeChainsListValidation: !0,
                    tokenSortConfig: {
                      key: 'tokenFiatAmount',
                      order: 'dsc',
                      sortCallback: 'stringNumeric',
                    },
                    privacyMode: !1,
                  };
                }
                n.getDefaultPreferencesState = d;
                class u extends o.BaseController {
                  constructor({ messenger: e, state: t }) {
                    super({
                      name: 'PreferencesController',
                      metadata: l,
                      messenger: e,
                      state: { ...d(), ...t },
                    }),
                      r.add(this),
                      e.subscribe('KeyringController:stateChange', e => {
                        const t = new Set();
                        for (const n of e.keyrings) for (const e of n.accounts) t.add(e);
                        t.size > 0 && a(this, r, 'm', s).call(this, Array.from(t));
                      });
                  }
                  addIdentities(e) {
                    const t = e.map(e => (0, i.toChecksumHexAddress)(e));
                    this.update(e => {
                      const { identities: n } = e;
                      for (const e of t) {
                        if (n[e]) continue;
                        const t = Object.keys(n).length;
                        n[e] = { name: `Account ${t + 1}`, address: e, importTime: Date.now() };
                      }
                    });
                  }
                  removeIdentity(e) {
                    e = (0, i.toChecksumHexAddress)(e);
                    const { identities: t } = this.state;
                    t[e] &&
                      this.update(t => {
                        delete t.identities[e],
                          e === t.selectedAddress &&
                            (t.selectedAddress = Object.keys(t.identities)[0]);
                      });
                  }
                  setAccountLabel(e, t) {
                    (e = (0, i.toChecksumHexAddress)(e)),
                      this.update(n => {
                        const r = n.identities[e] || {};
                        (r.name = t), (n.identities[e] = r);
                      });
                  }
                  setFeatureFlag(e, t) {
                    this.update(n => {
                      n.featureFlags[e] = t;
                    });
                  }
                  setSelectedAddress(e) {
                    this.update(t => {
                      t.selectedAddress = (0, i.toChecksumHexAddress)(e);
                    });
                  }
                  setIpfsGateway(e) {
                    this.update(t => {
                      t.ipfsGateway = e;
                    });
                  }
                  setUseTokenDetection(e) {
                    this.update(t => {
                      t.useTokenDetection = e;
                    });
                  }
                  setUseNftDetection(e) {
                    if (e && !this.state.openSeaEnabled)
                      throw new Error(
                        'useNftDetection cannot be enabled if openSeaEnabled is false'
                      );
                    this.update(t => {
                      t.useNftDetection = e;
                    });
                  }
                  setOpenSeaEnabled(e) {
                    this.update(t => {
                      (t.openSeaEnabled = e), e || (t.useNftDetection = !1);
                    });
                  }
                  setSecurityAlertsEnabled(e) {
                    this.update(t => {
                      t.securityAlertsEnabled = e;
                    });
                  }
                  setIsMultiAccountBalancesEnabled(e) {
                    this.update(t => {
                      t.isMultiAccountBalancesEnabled = e;
                    });
                  }
                  setShowTestNetworks(e) {
                    this.update(t => {
                      t.showTestNetworks = e;
                    });
                  }
                  setIsIpfsGatewayEnabled(e) {
                    this.update(t => {
                      t.isIpfsGatewayEnabled = e;
                    });
                  }
                  setEnableNetworkIncomingTransactions(e, t) {
                    Object.values(c.ETHERSCAN_SUPPORTED_CHAIN_IDS).includes(e) &&
                      this.update(n => {
                        n.showIncomingTransactions = {
                          ...this.state.showIncomingTransactions,
                          [e]: t,
                        };
                      });
                  }
                  setUseMultiRpcMigration(e) {
                    this.update(t => {
                      (t.useMultiRpcMigration = e), e || (t.useMultiRpcMigration = !1);
                    });
                  }
                  setSmartTransactionsOptInStatus(e) {
                    this.update(t => {
                      t.smartTransactionsOptInStatus = e;
                    });
                  }
                  setUseTransactionSimulations(e) {
                    this.update(t => {
                      t.useTransactionSimulations = e;
                    });
                  }
                  setTokenSortConfig(e) {
                    this.update(t => {
                      t.tokenSortConfig = e;
                    });
                  }
                  setUseSafeChainsListValidation(e) {
                    this.update(t => {
                      t.useSafeChainsListValidation = e;
                    });
                  }
                  setPrivacyMode(e) {
                    this.update(t => {
                      t.privacyMode = e;
                    });
                  }
                }
                (n.PreferencesController = u),
                  (r = new WeakSet()),
                  (s = function (e) {
                    (e = e.map(e => (0, i.toChecksumHexAddress)(e))),
                      this.update(t => {
                        const { identities: n } = t,
                          r = {};
                        for (const [t, s] of Object.entries(n))
                          e.includes(t) || ((r[t] = s), delete n[t]);
                        for (const [e, n] of Object.entries(r)) t.lostIdentities[e] = n;
                      }),
                      this.addIdentities(e),
                      e.includes(this.state.selectedAddress) ||
                        this.update(t => {
                          t.selectedAddress = e[0];
                        });
                  }),
                  (n.default = u);
              };
            };
      },
      {
        package: '@metamask/preferences-controller',
        file: 'node_modules/@metamask/preferences-controller/dist/PreferencesController.cjs',
      },
    ],
    [
      2458,
      {},
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.ETHERSCAN_SUPPORTED_CHAIN_IDS = void 0),
                  (n.ETHERSCAN_SUPPORTED_CHAIN_IDS = {
                    MAINNET: '0x1',
                    GOERLI: '0x5',
                    BSC: '0x38',
                    BSC_TESTNET: '0x61',
                    OPTIMISM: '0xa',
                    OPTIMISM_SEPOLIA: '0xaa37dc',
                    POLYGON: '0x89',
                    POLYGON_TESTNET: '0x13881',
                    AVALANCHE: '0xa86a',
                    AVALANCHE_TESTNET: '0xa869',
                    FANTOM: '0xfa',
                    FANTOM_TESTNET: '0xfa2',
                    SEPOLIA: '0xaa36a7',
                    LINEA_GOERLI: '0xe704',
                    LINEA_SEPOLIA: '0xe705',
                    LINEA_MAINNET: '0xe708',
                    MOONBEAM: '0x504',
                    MOONBEAM_TESTNET: '0x507',
                    MOONRIVER: '0x505',
                    GNOSIS: '0x64',
                  });
              };
            };
      },
      {
        package: '@metamask/preferences-controller',
        file: 'node_modules/@metamask/preferences-controller/dist/constants.cjs',
      },
    ],
    [
      2459,
      { './PreferencesController.cjs': 2457, './constants.cjs': 2458 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                var r =
                    (this && this.__createBinding) ||
                    (Object.create
                      ? function (e, t, n, r) {
                          r === undefined && (r = n);
                          var s = Object.getOwnPropertyDescriptor(t, n);
                          (s && !('get' in s ? !t.__esModule : s.writable || s.configurable)) ||
                            (s = {
                              enumerable: !0,
                              get: function () {
                                return t[n];
                              },
                            }),
                            Object.defineProperty(e, r, s);
                        }
                      : function (e, t, n, r) {
                          r === undefined && (r = n), (e[r] = t[n]);
                        }),
                  s =
                    (this && this.__exportStar) ||
                    function (e, t) {
                      for (var n in e)
                        'default' === n || Object.prototype.hasOwnProperty.call(t, n) || r(t, e, n);
                    };
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.ETHERSCAN_SUPPORTED_CHAIN_IDS = void 0),
                  s(e('./PreferencesController.cjs'), n);
                var a = e('./constants.cjs');
                Object.defineProperty(n, 'ETHERSCAN_SUPPORTED_CHAIN_IDS', {
                  enumerable: !0,
                  get: function () {
                    return a.ETHERSCAN_SUPPORTED_CHAIN_IDS;
                  },
                });
              };
            };
      },
      {
        package: '@metamask/preferences-controller',
        file: 'node_modules/@metamask/preferences-controller/dist/index.cjs',
      },
    ],
    [
      246,
      { lodash: 4921 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = void 0);
                var r = e('lodash');
                n.default = {
                  version: 42,
                  async migrate(e) {
                    const t = (0, r.cloneDeep)(e);
                    t.meta.version = 42;
                    const n = t.data;
                    return (
                      (t.data = (function (e) {
                        e.AppStateController
                          ? (e.AppStateController.connectedStatusPopoverHasBeenShown = !1)
                          : (e.AppStateController = { connectedStatusPopoverHasBeenShown: !1 });
                        return e;
                      })(n)),
                      t
                    );
                  },
                };
              };
            };
      },
      { package: '$root$', file: 'app/scripts/migrations/042.js' },
    ],
    [
      2460,
      {},
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                t.exports = {
                  snapId: 'npm:@metamask/preinstalled-example-snap',
                  manifest: {
                    version: '0.3.0',
                    description: 'MetaMask example snap demonstrating preinstalled Snaps.',
                    proposedName: 'Preinstalled Example Snap',
                    repository: { type: 'git', url: 'https://github.com/MetaMask/snaps.git' },
                    source: {
                      shasum: 'gl+ot55mLgaYlRg5Psp2IvNg+N+nKcsLWP0aZ5+a5zY=',
                      location: {
                        npm: {
                          filePath: 'dist/bundle.js',
                          packageName: '@metamask/preinstalled-example-snap',
                          registry: 'https://registry.npmjs.org/',
                        },
                      },
                    },
                    initialPermissions: {
                      'endowment:rpc': { dapps: !0 },
                      snap_dialog: {},
                      'endowment:page-settings': {},
                      snap_manageState: {},
                    },
                    platformVersion: '6.14.0',
                    manifestVersion: '0.1',
                  },
                  files: [
                    {
                      path: 'dist/bundle.js',
                      value:
                        '(()=>{var e={12:e=>{e.exports=a,a.default=a,a.stable=d,a.stableStringify=d;var t="[...]",n="[Circular]",r=[],o=[];function i(){return{depthLimit:Number.MAX_SAFE_INTEGER,edgesLimit:Number.MAX_SAFE_INTEGER}}function a(e,t,n,a){var s;void 0===a&&(a=i()),c(e,"",0,[],void 0,0,a);try{s=0===o.length?JSON.stringify(e,t,n):JSON.stringify(e,f(t),n)}catch(e){return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]")}finally{for(;0!==r.length;){var u=r.pop();4===u.length?Object.defineProperty(u[0],u[1],u[3]):u[0][u[1]]=u[2]}}return s}function s(e,t,n,i){var a=Object.getOwnPropertyDescriptor(i,n);void 0!==a.get?a.configurable?(Object.defineProperty(i,n,{value:e}),r.push([i,n,t,a])):o.push([t,n,e]):(i[n]=e,r.push([i,n,t]))}function c(e,r,o,i,a,u,d){var l;if(u+=1,"object"==typeof e&&null!==e){for(l=0;l<i.length;l++)if(i[l]===e)return void s(n,e,r,a);if(void 0!==d.depthLimit&&u>d.depthLimit)return void s(t,e,r,a);if(void 0!==d.edgesLimit&&o+1>d.edgesLimit)return void s(t,e,r,a);if(i.push(e),Array.isArray(e))for(l=0;l<e.length;l++)c(e[l],l,l,i,e,u,d);else{var f=Object.keys(e);for(l=0;l<f.length;l++){var p=f[l];c(e[p],p,l,i,e,u,d)}}i.pop()}}function u(e,t){return e<t?-1:e>t?1:0}function d(e,t,n,a){void 0===a&&(a=i());var s,c=l(e,"",0,[],void 0,0,a)||e;try{s=0===o.length?JSON.stringify(c,t,n):JSON.stringify(c,f(t),n)}catch(e){return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]")}finally{for(;0!==r.length;){var u=r.pop();4===u.length?Object.defineProperty(u[0],u[1],u[3]):u[0][u[1]]=u[2]}}return s}function l(e,o,i,a,c,d,f){var p;if(d+=1,"object"==typeof e&&null!==e){for(p=0;p<a.length;p++)if(a[p]===e)return void s(n,e,o,c);try{if("function"==typeof e.toJSON)return}catch(e){return}if(void 0!==f.depthLimit&&d>f.depthLimit)return void s(t,e,o,c);if(void 0!==f.edgesLimit&&i+1>f.edgesLimit)return void s(t,e,o,c);if(a.push(e),Array.isArray(e))for(p=0;p<e.length;p++)l(e[p],p,p,a,e,d,f);else{var h={},m=Object.keys(e).sort(u);for(p=0;p<m.length;p++){var g=m[p];l(e[g],g,p,a,e,d,f),h[g]=e[g]}if(void 0===c)return h;r.push([c,o,e]),c[o]=h}a.pop()}}function f(e){return e=void 0!==e?e:function(e,t){return t},function(t,n){if(o.length>0)for(var r=0;r<o.length;r++){var i=o[r];if(i[1]===t&&i[0]===n){n=i[2],o.splice(r,1);break}}return e.call(this,t,n)}}}},t={};function n(r){var o=t[r];if(void 0!==o)return o.exports;var i=t[r]={exports:{}};return e[r](i,i.exports,n),i.exports}n.d=(e,t)=>{for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var r={};(()=>{"use strict";function e(e,t,n){if("string"==typeof e)throw new Error(`An HTML element ("${String(e)}") was used in a Snap component, which is not supported by Snaps UI. Please use one of the supported Snap components.`);if(!e)throw new Error("A JSX fragment was used in a Snap component, which is not supported by Snaps UI. Please use one of the supported Snap components.");return e({...t,key:n})}function t(t,n,r){return e(t,n,r)}function o(e){return Boolean(e)&&"object"==typeof e&&!Array.isArray(e)}n.r(r),n.d(r,{onRpcRequest:()=>dt,onSettingsPage:()=>lt,onUserInput:()=>ft});const i=(e,t)=>Object.hasOwnProperty.call(e,t);var a;!function(e){e[e.Null=4]="Null",e[e.Comma=1]="Comma",e[e.Wrapper=1]="Wrapper",e[e.True=4]="True",e[e.False=5]="False",e[e.Quote=1]="Quote",e[e.Colon=1]="Colon",e[e.Date=24]="Date"}(a=a||(a={}));var s=n(12);class c extends TypeError{constructor(e,t){let n;const{message:r,explanation:o,...i}=e,{path:a}=e,s=0===a.length?r:`At path: ${a.join(".")} -- ${r}`;super(o??s),null!=o&&(this.cause=s),Object.assign(this,i),this.name=this.constructor.name,this.failures=()=>n??(n=[e,...t()])}}function u(e){return"object"==typeof e&&null!==e}function d(e){return"symbol"==typeof e?e.toString():"string"==typeof e?JSON.stringify(e):`${e}`}function l(e,t,n,r){if(!0===e)return;!1===e?e={}:"string"==typeof e&&(e={message:e});const{path:o,branch:i}=t,{type:a}=n,{refinement:s,message:c=`Expected a value of type \\`${a}\\`${s?` with refinement \\`${s}\\``:""}, but received: \\`${d(r)}\\``}=e;return{value:r,type:a,refinement:s,key:o[o.length-1],path:o,branch:i,...e,message:c}}function*f(e,t,n,r){(function(e){return u(e)&&"function"==typeof e[Symbol.iterator]})(e)||(e=[e]);for(const o of e){const e=l(o,t,n,r);e&&(yield e)}}function*p(e,t,n={}){const{path:r=[],branch:o=[e],coerce:i=!1,mask:a=!1}=n,s={path:r,branch:o};if(i&&(e=t.coercer(e,s),a&&"type"!==t.type&&u(t.schema)&&u(e)&&!Array.isArray(e)))for(const n in e)void 0===t.schema[n]&&delete e[n];let c="valid";for(const r of t.validator(e,s))r.explanation=n.message,c="not_valid",yield[r,void 0];for(let[d,l,f]of t.entries(e,s)){const t=p(l,f,{path:void 0===d?r:[...r,d],branch:void 0===d?o:[...o,l],coerce:i,mask:a,message:n.message});for(const n of t)n[0]?(c=null===n[0].refinement||void 0===n[0].refinement?"not_valid":"not_refined",yield[n[0],void 0]):i&&(l=n[1],void 0===d?e=l:e instanceof Map?e.set(d,l):e instanceof Set?e.add(l):u(e)&&(void 0!==l||d in e)&&(e[d]=l))}if("not_valid"!==c)for(const r of t.refiner(e,s))r.explanation=n.message,c="not_refined",yield[r,void 0];"valid"===c&&(yield[void 0,e])}class h{constructor(e){const{type:t,schema:n,validator:r,refiner:o,coercer:i=(e=>e),entries:a=function*(){}}=e;this.type=t,this.schema=n,this.entries=a,this.coercer=i,this.validator=r?(e,t)=>f(r(e,t),t,this,e):()=>[],this.refiner=o?(e,t)=>f(o(e,t),t,this,e):()=>[]}assert(e,t){return m(e,this,t)}create(e,t){return g(e,this,t)}is(e){return v(e,this)}mask(e,t){return function(e,t,n){const r=y(e,t,{coerce:!0,mask:!0,message:n});if(r[0])throw r[0];return r[1]}(e,this,t)}validate(e,t={}){return y(e,this,t)}}function m(e,t,n){const r=y(e,t,{message:n});if(r[0])throw r[0]}function g(e,t,n){const r=y(e,t,{coerce:!0,message:n});if(r[0])throw r[0];return r[1]}function v(e,t){return!y(e,t)[0]}function y(e,t,n={}){const r=p(e,t,n),o=function(e){const{done:t,value:n}=e.next();return t?void 0:n}(r);if(o[0]){return[new c(o[0],(function*(){for(const e of r)e[0]&&(yield e[0])})),void 0]}return[void 0,o[1]]}function b(...e){const t="type"===e[0]?.type,n=e.map((({schema:e})=>e)),r=Object.assign({},...n);return t?function(e){const t=Object.keys(e);return new h({type:"type",schema:e,*entries(n){if(u(n))for(const r of t)yield[r,n[r],e[r]]},validator:e=>u(e)||`Expected an object, but received: ${d(e)}`,coercer:e=>u(e)?{...e}:e})}(r):k(r)}function w(e,t){return new h({type:e,schema:null,validator:t})}function S(){return w("boolean",(e=>"boolean"==typeof e))}function E(e){const t=d(e),n=typeof e;return new h({type:"literal",schema:"string"===n||"number"===n||"boolean"===n?e:null,validator:n=>n===e||`Expected the literal \\`${t}\\`, but received: ${d(n)}`})}function O(){return w("never",(()=>!1))}function j(e){return new h({...e,validator:(t,n)=>null===t||e.validator(t,n),refiner:(t,n)=>null===t||e.refiner(t,n)})}function N(){return w("number",(e=>"number"==typeof e&&!isNaN(e)||`Expected a number, but received: ${d(e)}`))}function k(e){const t=e?Object.keys(e):[],n=O();return new h({type:"object",schema:e??null,*entries(r){if(e&&u(r)){const o=new Set(Object.keys(r));for(const n of t)o.delete(n),yield[n,r[n],e[n]];for(const e of o)yield[e,r[e],n]}},validator:e=>u(e)||`Expected an object, but received: ${d(e)}`,coercer:e=>u(e)?{...e}:e})}function x(e){return new h({...e,validator:(t,n)=>void 0===t||e.validator(t,n),refiner:(t,n)=>void 0===t||e.refiner(t,n)})}function P(e,t){return new h({type:"record",schema:null,*entries(n){if(u(n))for(const r in n){const o=n[r];yield[r,r,e],yield[r,o,t]}},validator:e=>u(e)||`Expected an object, but received: ${d(e)}`})}function I(){return w("string",(e=>"string"==typeof e||`Expected a string, but received: ${d(e)}`))}function A(e){const t=e.map((e=>e.type)).join(" | ");return new h({type:"union",schema:null,coercer(t){for(const n of e){const[e,r]=n.validate(t,{coerce:!0});if(!e)return r}return t},validator(n,r){const o=[];for(const t of e){const[...e]=p(n,t,r),[i]=e;if(!i?.[0])return[];for(const[t]of e)t&&o.push(t)}return[`Expected the value to satisfy a union of \\`${t}\\`, but received: ${d(n)}`,...o]}})}function C(e,t,n){return new h({...e,coercer:(r,o)=>v(r,t)?e.coercer(n(r,o),o):e.coercer(r,o)})}function T(e){return function(e){return function(e){return"object"==typeof e&&null!==e&&"message"in e}(e)&&"string"==typeof e.message?e.message:null==e?"":String(e)}(e).replace(/\\.$/u,"")}function R(e,t){return n=e,Boolean("string"==typeof n?.prototype?.constructor?.name)?new e({message:t}):e({message:t});var n}class _ extends Error{constructor(e){super(e.message),this.code="ERR_ASSERTION"}}const J=e=>k(e);function $({path:e,branch:t}){const n=e[e.length-1];return i(t[t.length-2],n)}function F(e){return new h({...e,type:`optional ${e.type}`,validator:(t,n)=>!$(n)||e.validator(t,n),refiner:(t,n)=>!$(n)||e.refiner(t,n)})}function q(e){if(null===e||"boolean"==typeof e||"string"==typeof e)return!0;if("number"==typeof e&&Number.isFinite(e))return!0;if("object"==typeof e){let t=!0;if(Array.isArray(e)){for(let n=0;n<e.length;n++)if(!q(e[n])){t=!1;break}return t}const n=Object.entries(e);for(let e=0;e<n.length;e++)if("string"!=typeof n[e][0]||!q(n[e][1])){t=!1;break}return t}return!1}const M=w("JSON",(e=>q(e))),z=C(M,w("any",(()=>!0)),(e=>(function(e,t,n="Assertion failed",r=_){try{m(e,t)}catch(e){throw R(r,`${n}: ${T(e)}.`)}}(e,M),JSON.parse(JSON.stringify(e,((e,t)=>{if("__proto__"!==e&&"constructor"!==e)return t}))))));function L(e){try{return function(e){g(e,z)}(e),!0}catch{return!1}}const U=E("2.0"),D=j(A([N(),I()])),B=J({code:w("integer",(e=>"number"==typeof e&&!isNaN(e)&&Number.isInteger(e)||`Expected an integer, but received: ${d(e)}`)),message:I(),data:F(z),stack:F(I())}),W=A([P(I(),z),(G=z,new h({type:"array",schema:G,*entries(e){if(G&&Array.isArray(e))for(const[t,n]of e.entries())yield[t,n,G]},coercer:e=>Array.isArray(e)?e.slice():e,validator:e=>Array.isArray(e)||`Expected an array value, but received: ${d(e)}`}))]);var G;J({id:D,jsonrpc:U,method:I(),params:F(W)}),J({jsonrpc:U,method:I(),params:F(W)});k({id:D,jsonrpc:U,result:x(w("unknown",(()=>!0))),error:x(B)});const X=J({id:D,jsonrpc:U,result:z}),H=J({id:D,jsonrpc:U,error:B});A([X,H]);const Q={invalidInput:-32e3,resourceNotFound:-32001,resourceUnavailable:-32002,transactionRejected:-32003,methodNotSupported:-32004,limitExceeded:-32005,parse:-32700,invalidRequest:-32600,methodNotFound:-32601,invalidParams:-32602,internal:-32603},K={userRejectedRequest:4001,unauthorized:4100,unsupportedMethod:4200,disconnected:4900,chainDisconnected:4901},V={"-32700":{standard:"JSON RPC 2.0",message:"Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."},"-32600":{standard:"JSON RPC 2.0",message:"The JSON sent is not a valid Request object."},"-32601":{standard:"JSON RPC 2.0",message:"The method does not exist / is not available."},"-32602":{standard:"JSON RPC 2.0",message:"Invalid method parameter(s)."},"-32603":{standard:"JSON RPC 2.0",message:"Internal JSON-RPC error."},"-32000":{standard:"EIP-1474",message:"Invalid input."},"-32001":{standard:"EIP-1474",message:"Resource not found."},"-32002":{standard:"EIP-1474",message:"Resource unavailable."},"-32003":{standard:"EIP-1474",message:"Transaction rejected."},"-32004":{standard:"EIP-1474",message:"Method not supported."},"-32005":{standard:"EIP-1474",message:"Request limit exceeded."},4001:{standard:"EIP-1193",message:"User rejected the request."},4100:{standard:"EIP-1193",message:"The requested account and/or method has not been authorized by the user."},4200:{standard:"EIP-1193",message:"The requested method is not supported by this Ethereum provider."},4900:{standard:"EIP-1193",message:"The provider is disconnected from all chains."},4901:{standard:"EIP-1193",message:"The provider is disconnected from the specified chain."}},Y=Q.internal,Z="Unspecified error message. This is a bug, please report it.",ee=(te(Y),"Unspecified server error.");function te(e,t=Z){if(function(e){return Number.isInteger(e)}(e)){const t=e.toString();if(i(V,t))return V[t].message;if(function(e){return e>=-32099&&e<=-32e3}(e))return ee}return t}function ne(e){return Array.isArray(e)?e.map((e=>L(e)?e:o(e)?re(e):null)):o(e)?re(e):L(e)?e:null}function re(e){return Object.getOwnPropertyNames(e).reduce(((t,n)=>{const r=e[n];return L(r)&&(t[n]=r),t}),{})}const oe=function(e){return e?.__esModule?e.default:e}(s);class ie extends Error{constructor(e,t,n){if(!Number.isInteger(e))throw new Error(\'"code" must be an integer.\');if(!t||"string"!=typeof t)throw new Error(\'"message" must be a non-empty string.\');!function(e){return o(e)&&i(e,"cause")&&o(e.cause)}(n)?super(t):(super(t,{cause:n.cause}),i(this,"cause")||Object.assign(this,{cause:n.cause})),void 0!==n&&(this.data=n),this.code=e}serialize(){const e={code:this.code,message:this.message};return void 0!==this.data&&(e.data=this.data,function(e){if("object"!=typeof e||null===e)return!1;try{let t=e;for(;null!==Object.getPrototypeOf(t);)t=Object.getPrototypeOf(t);return Object.getPrototypeOf(e)===t}catch(e){return!1}}(this.data)&&(e.data.cause=ne(this.data.cause))),this.stack&&(e.stack=this.stack),e}toString(){return oe(this.serialize(),se,2)}}class ae extends ie{constructor(e,t,n){if(!function(e){return Number.isInteger(e)&&e>=1e3&&e<=4999}(e))throw new Error(\'"code" must be an integer such that: 1000 <= code <= 4999\');super(e,t,n)}}function se(e,t){if("[Circular]"!==t)return t}const ce=e=>je(Q.parse,e),ue=e=>je(Q.invalidRequest,e),de=e=>je(Q.invalidParams,e),le=e=>je(Q.methodNotFound,e),fe=e=>je(Q.internal,e),pe=e=>je(Q.invalidInput,e),he=e=>je(Q.resourceNotFound,e),me=e=>je(Q.resourceUnavailable,e),ge=e=>je(Q.transactionRejected,e),ve=e=>je(Q.methodNotSupported,e),ye=e=>je(Q.limitExceeded,e),be=e=>Ne(K.userRejectedRequest,e),we=e=>Ne(K.unauthorized,e),Se=e=>Ne(K.unsupportedMethod,e),Ee=e=>Ne(K.disconnected,e),Oe=e=>Ne(K.chainDisconnected,e);function je(e,t){const[n,r]=ke(t);return new ie(e,n??te(e),r)}function Ne(e,t){const[n,r]=ke(t);return new ae(e,n??te(e),r)}function ke(e){if(e){if("string"==typeof e)return[e];if("object"==typeof e&&!Array.isArray(e)){const{message:t,data:n}=e;if(t&&"string"!=typeof t)throw new Error("Must specify string message.");return[t??void 0,n]}}return[]}function xe(e){return o(e)&&i(e,"data")&&"object"==typeof e.data&&null!==e.data&&L(e.data)&&!Array.isArray(e.data)?e.data:{}}var Pe,Ie,Ae,Ce,Te=function(e,t,n,r,o){if("m"===r)throw new TypeError("Private method is not writable");if("a"===r&&!o)throw new TypeError("Private accessor was defined without a setter");if("function"==typeof t?e!==t||!o:!t.has(e))throw new TypeError("Cannot write private member to an object whose class did not declare it");return"a"===r?o.call(e,n):o?o.value=n:t.set(e,n),n},Re=function(e,t,n,r){if("a"===n&&!r)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof t?e!==t||!r:!t.has(e))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===n?r:"a"===n?r.call(e):r?r.value:t.get(e)};class _e extends Error{constructor(e,t={}){const n=function(e){return o(e)&&i(e,"message")&&"string"==typeof e.message?e.message:String(e)}(e);super(n),Pe.set(this,void 0),Ie.set(this,void 0),Ae.set(this,void 0),Ce.set(this,void 0),Te(this,Ie,n,"f"),Te(this,Pe,function(e){return o(e)&&i(e,"code")&&"number"==typeof e.code&&Number.isInteger(e.code)?e.code:-32603}(e),"f");const r={...xe(e),...t};Object.keys(r).length>0&&Te(this,Ae,r,"f"),Te(this,Ce,super.stack,"f")}get name(){return"SnapError"}get code(){return Re(this,Pe,"f")}get message(){return Re(this,Ie,"f")}get data(){return Re(this,Ae,"f")}get stack(){return Re(this,Ce,"f")}toJSON(){return{code:-31002,message:"Snap Error",data:{cause:{code:this.code,message:this.message,stack:this.stack,...this.data?{data:this.data}:{}}}}}serialize(){return this.toJSON()}}function Je(e){return class extends _e{constructor(t,n){if("object"==typeof t){const n=e();return void super({code:n.code,message:n.message,data:t})}const r=e(t);super({code:r.code,message:r.message,data:n})}}}Pe=new WeakMap,Ie=new WeakMap,Ae=new WeakMap,Ce=new WeakMap;Je(fe),Je(pe),Je(de),Je(ue),Je(ye);const $e=Je(le);Je(ve),Je(ce),Je(he),Je(me),Je(ge),Je(Oe),Je(Ee),Je(we),Je(Se),Je(be);var Fe;!function(e){e.ButtonClickEvent="ButtonClickEvent",e.FormSubmitEvent="FormSubmitEvent",e.InputChangeEvent="InputChangeEvent",e.FileUploadEvent="FileUploadEvent"}(Fe||(Fe={}));const qe=k({type:I(),name:x(I())}),Me=b(qe,k({type:E(Fe.ButtonClickEvent),name:x(I())})),ze=k({name:I(),size:N(),contentType:I(),contents:I()}),Le=b(qe,k({type:E(Fe.FormSubmitEvent),value:P(I(),j(A([I(),ze,S()]))),name:I()})),Ue=b(qe,k({type:E(Fe.InputChangeEvent),name:I(),value:A([I(),S()])}));A([Me,Le,Ue,b(qe,k({type:E(Fe.FileUploadEvent),name:I(),file:j(ze)}))]);function De(e){return Object.fromEntries(Object.entries(e).filter((([,e])=>void 0!==e)))}function Be(e){return t=>{const{key:n=null,...r}=t;return{type:e,props:De(r),key:n}}}const We=Be("Container"),Ge=Be("Box"),Xe=Be("Heading"),He=Be("Text"),Qe=Be("Form"),Ke=Be("Field"),Ve=Be("Input"),Ye=Be("Footer"),Ze=Be("Button"),et=()=>t(We,{children:[t(Ge,{children:[e(Xe,{children:"Custom Dialog"}),e(He,{children:"This is a custom dialog. It has a custom footer and can be resolved to any value."}),e(Qe,{name:"form",children:e(Ke,{label:"Field",children:e(Ve,{name:"custom-input",placeholder:"Enter something..."})})})]}),t(Ye,{children:[e(Ze,{name:"cancel",children:"Cancel"}),e(Ze,{name:"confirm",type:"submit",form:"form",children:"Confirm"})]})]}),tt=Be("Section"),nt=Be("Checkbox"),rt=Be("RadioGroup"),ot=Be("Radio"),it=Be("Dropdown"),at=Be("Option"),st=({setting1:n,setting2:r,setting3:o})=>t(Ge,{children:[t(tt,{children:[e(He,{children:"Setting 1"}),e(He,{color:"alternative",children:"This is the first setting"}),e(nt,{name:"setting1",variant:"toggle",checked:n})]}),t(tt,{children:[e(He,{children:"Setting 2"}),e(He,{color:"alternative",children:"This is the second setting"}),t(rt,{name:"setting2",value:r,children:[e(ot,{value:"option1",children:"Option 1"}),e(ot,{value:"option2",children:"Option 2"})]})]}),t(tt,{children:[e(He,{children:"Setting 3"}),e(He,{color:"alternative",children:"This is the third setting"}),t(it,{name:"setting3",value:o,children:[e(at,{value:"option1",children:"Option 1"}),e(at,{value:"option2",children:"Option 2"})]})]})]}),ct=Be("Copyable"),ut=({value:n})=>t(We,{children:[t(Ge,{children:[e(Xe,{children:"Custom Dialog"}),e(He,{children:"The form was submitted with the following value:"}),e(ct,{value:n})]}),e(Ye,{children:e(Ze,{name:"ok",children:"Ok"})})]}),dt=async({request:t})=>{switch(t.method){case"showDialog":return await snap.request({method:"snap_dialog",params:{content:e(et,{})}});case"getSettings":return await snap.request({method:"snap_manageState",params:{operation:"get",encrypted:!1}});default:throw new $e({method:t.method})}},lt=async()=>{var t,n,r;const o=await snap.request({method:"snap_manageState",params:{operation:"get",encrypted:!1}});return{content:e(st,{setting1:null===(t=o)||void 0===t?void 0:t.setting1,setting2:null===(n=o)||void 0===n?void 0:n.setting2,setting3:null===(r=o)||void 0===r?void 0:r.setting3})}},ft=async({event:t,id:n,context:r})=>{var o;t.type===Fe.ButtonClickEvent&&("cancel"===t.name&&await snap.request({method:"snap_resolveInterface",params:{id:n,value:null}}),"ok"===t.name&&await snap.request({method:"snap_resolveInterface",params:{id:n,value:String(null===(o=r)||void 0===o?void 0:o.value)}}));if(t.type===Fe.FormSubmitEvent&&"form"===t.name){const r=String(t.value["custom-input"]);await snap.request({method:"snap_updateInterface",params:{id:n,ui:e(ut,{value:r}),context:{value:r}}})}if(t.type===Fe.InputChangeEvent&&("setting1"===t.name||"setting2"===t.name||"setting3"===t.name)){const e=await snap.request({method:"snap_manageState",params:{operation:"get",encrypted:!1}});await snap.request({method:"snap_manageState",params:{operation:"update",encrypted:!1,newState:{...e,[t.name]:t.value}}})}}})(),module.exports=r})();',
                    },
                  ],
                  removable: !1,
                  hideSnapBranding: !0,
                };
              };
            };
      },
      {
        package: '@metamask/preinstalled-example-snap',
        file: 'node_modules/@metamask/preinstalled-example-snap/dist/preinstalled-snap.json',
      },
    ],
    [
      247,
      { lodash: 4921 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = void 0);
                var r = e('lodash');
                n.default = {
                  version: 43,
                  async migrate(e) {
                    const t = (0, r.cloneDeep)(e);
                    t.meta.version = 43;
                    const n = t.data;
                    return (
                      (t.data = (function (e) {
                        var t;
                        null != e &&
                          null !== (t = e.PreferencesController) &&
                          void 0 !== t &&
                          t.currentAccountTab &&
                          delete e.PreferencesController.currentAccountTab;
                        return e;
                      })(n)),
                      t
                    );
                  },
                };
              };
            };
      },
      { package: '$root$', file: 'app/scripts/migrations/043.js' },
    ],
    [
      248,
      { lodash: 4921 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = void 0);
                var r = e('lodash');
                n.default = {
                  version: 44,
                  async migrate(e) {
                    const t = (0, r.cloneDeep)(e);
                    t.meta.version = 44;
                    const n = t.data;
                    return (
                      (t.data = (function (e) {
                        var t;
                        void 0 !==
                          (null == e || null === (t = e.AppStateController) || void 0 === t
                            ? void 0
                            : t.mkrMigrationReminderTimestamp) &&
                          delete e.AppStateController.mkrMigrationReminderTimestamp;
                        return e;
                      })(n)),
                      t
                    );
                  },
                };
              };
            };
      },
      { package: '$root$', file: 'app/scripts/migrations/044.js' },
    ],
    [
      249,
      { lodash: 4921 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = void 0);
                var r = e('lodash');
                n.default = {
                  version: 45,
                  async migrate(e) {
                    const t = (0, r.cloneDeep)(e);
                    t.meta.version = 45;
                    const n = t.data;
                    return (
                      (t.data = (function (e) {
                        var t;
                        s.includes(
                          null == e || null === (t = e.PreferencesController) || void 0 === t
                            ? void 0
                            : t.ipfsGateway
                        ) && (e.PreferencesController.ipfsGateway = 'dweb.link');
                        return e;
                      })(n)),
                      t
                    );
                  },
                };
                const s = ['ipfs.io', 'ipfs.dweb.link'];
              };
            };
      },
      { package: '$root$', file: 'app/scripts/migrations/045.js' },
    ],
    [
      25,
      {},
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.getTokenRatesControllerMessenger = function (e) {
                    return e.getRestricted({
                      name: 'TokenRatesController',
                      allowedActions: [
                        'TokensController:getState',
                        'NetworkController:getNetworkClientById',
                        'NetworkController:getState',
                        'AccountsController:getAccount',
                        'AccountsController:getSelectedAccount',
                      ],
                      allowedEvents: [
                        'NetworkController:stateChange',
                        'AccountsController:selectedEvmAccountChange',
                        'PreferencesController:stateChange',
                        'TokensController:stateChange',
                      ],
                    });
                  });
              };
            };
      },
      {
        package: '$root$',
        file: 'app/scripts/controller-init/messengers/assets/token-rates-controller-messenger.ts',
      },
    ],
    [
      250,
      { lodash: 4921 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = void 0);
                var r = e('lodash');
                n.default = {
                  version: 46,
                  async migrate(e) {
                    const t = (0, r.cloneDeep)(e);
                    t.meta.version = 46;
                    const n = t.data;
                    return (
                      (t.data = (function (e) {
                        void 0 !== (null == e ? void 0 : e.ABTestController) &&
                          delete e.ABTestController;
                        return e;
                      })(n)),
                      t
                    );
                  },
                };
              };
            };
      },
      { package: '$root$', file: 'app/scripts/migrations/046.js' },
    ],
    [
      251,
      { lodash: 4921 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = void 0);
                var r = e('lodash');
                n.default = {
                  version: 47,
                  async migrate(e) {
                    const t = (0, r.cloneDeep)(e);
                    t.meta.version = 47;
                    const n = t.data;
                    return (
                      (t.data = (function (e) {
                        var t;
                        const n =
                          null == e || null === (t = e.TransactionController) || void 0 === t
                            ? void 0
                            : t.transactions;
                        Array.isArray(n) &&
                          n.forEach(e => {
                            'number' == typeof e.metamaskNetworkId &&
                              (e.metamaskNetworkId = e.metamaskNetworkId.toString());
                          });
                        return e;
                      })(n)),
                      t
                    );
                  },
                };
              };
            };
      },
      { package: '$root$', file: 'app/scripts/migrations/047.js' },
    ],
    [
      252,
      { lodash: 4921 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = void 0);
                var r = e('lodash');
                n.default = {
                  version: 48,
                  async migrate(e) {
                    const t = (0, r.cloneDeep)(e);
                    t.meta.version = 48;
                    const n = t.data;
                    return (
                      (t.data = (function (e = {}) {
                        var t, n, r, o, i, c, l, d;
                        null === (t = e.NetworkController) || void 0 === t || delete t.settings;
                        const u =
                          (null === (n = e.NetworkController) || void 0 === n
                            ? void 0
                            : n.provider) || {};
                        if (
                          ('rpc' !== u.type ||
                            ('string' == typeof u.chainId && a.test(u.chainId))) &&
                          'localhost' !== u.type
                        ) {
                          if (null !== (r = e.NetworkController) && void 0 !== r && r.provider) {
                            var h;
                            if ('rpcTarget' in e.NetworkController.provider) {
                              const t = e.NetworkController.provider.rpcTarget;
                              e.NetworkController.provider.rpcUrl = t;
                            }
                            null === (h = e.NetworkController) ||
                              void 0 === h ||
                              null === (h = h.provider) ||
                              void 0 === h ||
                              delete h.rpcTarget;
                          }
                        } else
                          e.NetworkController.provider = {
                            type: 'rinkeby',
                            rpcUrl: '',
                            chainId: '0x4',
                            nickname: '',
                            rpcPrefs: {},
                            ticker: 'ETH',
                          };
                        e.PreferencesController || (e.PreferencesController = {});
                        e.PreferencesController.frequentRpcListDetail ||
                          (e.PreferencesController.frequentRpcListDetail = []);
                        e.PreferencesController.frequentRpcListDetail.unshift({
                          rpcUrl: 'http://localhost:8545',
                          chainId: '0x539',
                          ticker: 'ETH',
                          nickname: 'Localhost 8545',
                          rpcPrefs: {},
                        }),
                          null === (o = e.CachedBalancesController) ||
                            void 0 === o ||
                            delete o.cachedBalances;
                        const p =
                          null === (i = e.TransactionController) || void 0 === i
                            ? void 0
                            : i.transactions;
                        Array.isArray(p) &&
                          p.forEach(e => {
                            const t = null == e ? void 0 : e.metamaskNetworkId;
                            'string' == typeof t &&
                              s.test(t) &&
                              (e.metamaskNetworkId = parseInt(t, 16).toString(10));
                          });
                        const m =
                          (null === (c = e.AddressBookController) || void 0 === c
                            ? void 0
                            : c.addressBook) || {};
                        Object.keys(m).forEach(e => {
                          if (/^\d+$/iu.test(e)) {
                            const t = `0x${parseInt(e, 10).toString(16)}`;
                            !(function (e, t) {
                              Object.values(e).forEach(e => {
                                e && 'object' == typeof e && (e.chainId = t);
                              });
                            })(m[e], t),
                              m[t]
                                ? (function (e, t, n) {
                                    const r = e[t] || {},
                                      s = { ...e[n] };
                                    Object.keys(r).forEach(e => {
                                      if (s[e] && 'object' == typeof s[e]) {
                                        const t = {};
                                        new Set([
                                          ...Object.keys(s[e]),
                                          ...Object.keys(r[e] || {}),
                                        ]).forEach(n => {
                                          var a;
                                          t[n] =
                                            s[e][n] ||
                                            (null === (a = r[e]) || void 0 === a ? void 0 : a[n]) ||
                                            '';
                                        }),
                                          (s[e] = t);
                                      } else r[e] && 'object' == typeof r[e] && (s[e] = r[e]);
                                    }),
                                      (e[n] = s);
                                  })(m, e, t)
                                : (m[t] = m[e]),
                              delete m[e];
                          }
                        }),
                          null === (l = e.IncomingTransactionsController) ||
                            void 0 === l ||
                            null === (l = l.incomingTxLastFetchedBlocksByNetwork) ||
                            void 0 === l ||
                            delete l.localhost;
                        const f =
                          null === (d = e.PreferencesController) || void 0 === d
                            ? void 0
                            : d.accountTokens;
                        f &&
                          Object.keys(f).forEach(e => {
                            var t, n;
                            const r =
                              (null === (t = f[e]) || void 0 === t ? void 0 : t.localhost) || [];
                            if (r.length > 0) {
                              const t = f[e].rpc || [];
                              t.length > 0
                                ? (f[e].rpc = (function (e, t) {
                                    const n = a(e),
                                      r = a(t),
                                      s = [];
                                    return (
                                      new Set([...Object.keys(n), ...Object.keys(r)]).forEach(e => {
                                        s.push({ ...n[e], ...r[e] });
                                      }),
                                      s
                                    );
                                    function a(e) {
                                      return e.reduce(
                                        (e, t) => (
                                          null != t &&
                                            t.address &&
                                            'string' == typeof (null == t ? void 0 : t.address) &&
                                            (e[t.address] = t),
                                          e
                                        ),
                                        {}
                                      );
                                    }
                                  })(r, t))
                                : (f[e].rpc = r);
                            }
                            null === (n = f[e]) || void 0 === n || delete n.localhost;
                          });
                        return e;
                      })(n)),
                      t
                    );
                  },
                };
                const s = /^0x[0-9a-f]+$/iu,
                  a = /^0x[1-9a-f]+[0-9a-f]*$/iu;
              };
            };
      },
      { package: '$root$', file: 'app/scripts/migrations/048.js' },
    ],
    [
      253,
      { lodash: 4921 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = void 0);
                var r = e('lodash');
                n.default = {
                  version: 49,
                  async migrate(e) {
                    const t = (0, r.cloneDeep)(e);
                    t.meta.version = 49;
                    const n = t.data;
                    return (
                      (t.data = (function (e = {}) {
                        if (e.PreferencesController) {
                          const {
                            metaMetricsId: t,
                            participateInMetaMetrics: n,
                            metaMetricsSendCount: r,
                          } = e.PreferencesController;
                          (e.MetaMetricsController = e.MetaMetricsController ?? {}),
                            t !== undefined &&
                              ((e.MetaMetricsController.metaMetricsId = t),
                              delete e.PreferencesController.metaMetricsId),
                            n !== undefined &&
                              ((e.MetaMetricsController.participateInMetaMetrics = n),
                              delete e.PreferencesController.participateInMetaMetrics),
                            r !== undefined &&
                              ((e.MetaMetricsController.metaMetricsSendCount = r),
                              delete e.PreferencesController.metaMetricsSendCount);
                        }
                        return e;
                      })(n)),
                      t
                    );
                  },
                };
              };
            };
      },
      { package: '$root$', file: 'app/scripts/migrations/049.js' },
    ],
    [
      254,
      { lodash: 4921 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = void 0);
                var r = e('lodash');
                const s = [
                  'METASWAP_GAS_PRICE_ESTIMATES_LAST_RETRIEVED',
                  'METASWAP_GAS_PRICE_ESTIMATES',
                  'cachedFetch',
                  'BASIC_PRICE_ESTIMATES_LAST_RETRIEVED',
                  'BASIC_PRICE_ESTIMATES',
                  'BASIC_GAS_AND_TIME_API_ESTIMATES',
                  'BASIC_GAS_AND_TIME_API_ESTIMATES_LAST_RETRIEVED',
                  'GAS_API_ESTIMATES_LAST_RETRIEVED',
                  'GAS_API_ESTIMATES',
                ];
                n.default = {
                  version: 50,
                  async migrate(e) {
                    const t = (0, r.cloneDeep)(e);
                    return (
                      (t.meta.version = 50),
                      s.forEach(e => {
                        var t;
                        return null === (t = window.localStorage) || void 0 === t
                          ? void 0
                          : t.removeItem(e);
                      }),
                      t
                    );
                  },
                };
              };
            };
      },
      { package: '$root$', file: 'app/scripts/migrations/050.js' },
    ],
    [
      2545,
      {
        '@metamask/base-controller': 2552,
        '@metamask/selected-network-controller': 2602,
        '@metamask/utils': 2563,
      },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                var r,
                  s,
                  a,
                  o,
                  i,
                  c,
                  l,
                  d,
                  u,
                  h,
                  p,
                  m,
                  f,
                  g,
                  b,
                  y,
                  w =
                    (this && this.__classPrivateFieldSet) ||
                    function (e, t, n, r, s) {
                      if ('m' === r) throw new TypeError('Private method is not writable');
                      if ('a' === r && !s)
                        throw new TypeError('Private accessor was defined without a setter');
                      if ('function' == typeof t ? e !== t || !s : !t.has(e))
                        throw new TypeError(
                          'Cannot write private member to an object whose class did not declare it'
                        );
                      return 'a' === r ? s.call(e, n) : s ? (s.value = n) : t.set(e, n), n;
                    },
                  v =
                    (this && this.__classPrivateFieldGet) ||
                    function (e, t, n, r) {
                      if ('a' === n && !r)
                        throw new TypeError('Private accessor was defined without a getter');
                      if ('function' == typeof t ? e !== t || !r : !t.has(e))
                        throw new TypeError(
                          'Cannot read private member from an object whose class did not declare it'
                        );
                      return 'm' === n ? r : 'a' === n ? r.call(e) : r ? r.value : t.get(e);
                    };
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.QueuedRequestController =
                    n.QueuedRequestControllerEventTypes =
                    n.QueuedRequestControllerActionTypes =
                    n.controllerName =
                      void 0);
                const C = e('@metamask/base-controller'),
                  k = e('@metamask/selected-network-controller'),
                  S = e('@metamask/utils');
                (n.controllerName = 'QueuedRequestController'),
                  (n.QueuedRequestControllerActionTypes = {
                    enqueueRequest: `${n.controllerName}:enqueueRequest`,
                    getState: `${n.controllerName}:getState`,
                  }),
                  (n.QueuedRequestControllerEventTypes = {
                    networkSwitched: `${n.controllerName}:networkSwitched`,
                    stateChange: `${n.controllerName}:stateChange`,
                  });
                class _ extends C.BaseController {
                  constructor({
                    messenger: e,
                    shouldRequestSwitchNetwork: t,
                    canRequestSwitchNetworkWithoutApproval: p,
                    clearPendingConfirmations: m,
                    showApprovalRequest: f,
                  }) {
                    super({
                      name: n.controllerName,
                      metadata: { queuedRequestCount: { anonymous: !0, persist: !1 } },
                      messenger: e,
                      state: { queuedRequestCount: 0 },
                    }),
                      r.add(this),
                      s.set(this, void 0),
                      a.set(this, void 0),
                      o.set(this, []),
                      i.set(this, 0),
                      c.set(this, void 0),
                      l.set(this, void 0),
                      d.set(this, void 0),
                      u.set(this, void 0),
                      w(this, c, t, 'f'),
                      w(this, l, p, 'f'),
                      w(this, d, m, 'f'),
                      w(this, u, f, 'f'),
                      v(this, r, 'm', h).call(this);
                  }
                  async enqueueRequest(e, t) {
                    if (e.networkClientId === undefined)
                      throw new Error(
                        'Error while attempting to enqueue request: networkClientId is required.'
                      );
                    v(this, s, 'f') === undefined && w(this, s, e.origin, 'f'),
                      v(this, a, 'f') === undefined && w(this, a, e.networkClientId, 'f');
                    try {
                      let n;
                      const o = v(this, i, 'f') > 0 && v(this, l, 'f').call(this, e);
                      if (
                        this.state.queuedRequestCount > 0 ||
                        v(this, s, 'f') !== e.origin ||
                        v(this, a, 'f') !== e.networkClientId ||
                        o
                      ) {
                        v(this, u, 'f').call(this);
                        const t = v(this, r, 'm', b).call(this, e);
                        (n = t.requestHasEnded), await t.dequeuedPromise;
                      } else
                        v(this, c, 'f').call(this, e) &&
                          (await v(this, r, 'm', f).call(this, e.networkClientId));
                      w(this, i, v(this, i, 'f') + 1, 'f');
                      try {
                        await t();
                      } finally {
                        n?.(), w(this, i, v(this, i, 'f') - 1, 'f');
                      }
                      return undefined;
                    } finally {
                      v(this, r, 'm', y).call(this);
                    }
                  }
                }
                (n.QueuedRequestController = _),
                  (s = new WeakMap()),
                  (a = new WeakMap()),
                  (o = new WeakMap()),
                  (i = new WeakMap()),
                  (c = new WeakMap()),
                  (l = new WeakMap()),
                  (d = new WeakMap()),
                  (u = new WeakMap()),
                  (r = new WeakSet()),
                  (h = function () {
                    this.messagingSystem.registerActionHandler(
                      `${n.controllerName}:enqueueRequest`,
                      this.enqueueRequest.bind(this)
                    ),
                      this.messagingSystem.subscribe(
                        k.SelectedNetworkControllerEventTypes.stateChange,
                        (e, t) => {
                          t.forEach(({ op: e, path: t }) => {
                            if (2 === t.length && 'domains' === t[0] && 'string' == typeof t[1]) {
                              const n = t[1];
                              v(this, r, 'm', p).call(this, n),
                                'remove' === e &&
                                  n === v(this, s, 'f') &&
                                  v(this, d, 'f').call(this);
                            }
                          });
                        }
                      );
                  }),
                  (p = function (e) {
                    v(this, o, 'f')
                      .filter(({ request: t }) => t.origin === e)
                      .forEach(({ processRequest: e }) => {
                        e(
                          new Error(
                            'The request has been rejected due to a change in selected network. Please verify the selected network and retry the request.'
                          )
                        );
                      }),
                      w(
                        this,
                        o,
                        v(this, o, 'f').filter(({ request: t }) => t.origin !== e),
                        'f'
                      ),
                      v(this, r, 'm', g).call(this);
                  }),
                  (m = async function () {
                    const e = v(this, o, 'f').shift();
                    w(this, s, e.request.origin, 'f'), w(this, a, e.request.networkClientId, 'f');
                    const t = [e];
                    let n;
                    try {
                      await v(this, r, 'm', f).call(this, e.request.networkClientId);
                    } catch (e) {
                      n = e;
                    }
                    if (v(this, l, 'f').call(this, e.request)) {
                      w(this, i, v(this, i, 'f') + 1, 'f');
                      try {
                        e.processRequest(n),
                          v(this, r, 'm', g).call(this),
                          await e.requestHasBeenProcessed;
                      } finally {
                        w(this, i, v(this, i, 'f') - 1, 'f');
                      }
                      const { selectedNetworkClientId: t } = this.messagingSystem.call(
                        'NetworkController:getState'
                      );
                      return (
                        v(this, a, 'f') !== t && v(this, r, 'm', p).call(this, v(this, s, 'f')),
                        void v(this, r, 'm', y).call(this)
                      );
                    }
                    for (
                      ;
                      v(this, o, 'f')[0]?.request.networkClientId === v(this, a, 'f') &&
                      v(this, o, 'f')[0]?.request.origin === v(this, s, 'f') &&
                      !v(this, l, 'f').call(this, v(this, o, 'f')[0]?.request);

                    ) {
                      const e = v(this, o, 'f').shift();
                      t.push(e);
                    }
                    for (const { processRequest: e } of t) e(n);
                    v(this, r, 'm', g).call(this);
                  }),
                  (f = async function (e) {
                    const { selectedNetworkClientId: t } = this.messagingSystem.call(
                      'NetworkController:getState'
                    );
                    e !== t &&
                      (await this.messagingSystem.call('NetworkController:setActiveNetwork', e),
                      this.messagingSystem.publish('QueuedRequestController:networkSwitched', e));
                  }),
                  (g = function () {
                    this.update(e => {
                      e.queuedRequestCount = v(this, o, 'f').length;
                    });
                  }),
                  (b = function (e) {
                    const {
                        promise: t,
                        reject: n,
                        resolve: s,
                      } = (0, S.createDeferredPromise)({ suppressUnhandledRejection: !0 }),
                      { promise: a, resolve: i } = (0, S.createDeferredPromise)({
                        suppressUnhandledRejection: !0,
                      });
                    return (
                      v(this, o, 'f').push({
                        request: e,
                        processRequest: e => {
                          e ? n(e) : s();
                        },
                        requestHasBeenProcessed: a,
                      }),
                      v(this, r, 'm', g).call(this),
                      { dequeuedPromise: t, requestHasEnded: i }
                    );
                  }),
                  (y = function () {
                    0 === v(this, i, 'f') &&
                      (w(this, s, undefined, 'f'),
                      w(this, a, undefined, 'f'),
                      v(this, o, 'f').length > 0 && v(this, r, 'm', m).call(this));
                  });
              };
            };
      },
      {
        package: '@metamask/queued-request-controller',
        file: 'node_modules/@metamask/queued-request-controller/dist/QueuedRequestController.cjs',
      },
    ],
    [
      2546,
      { '@metamask/json-rpc-engine': 1964, '@metamask/rpc-errors': 2585 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.createQueuedRequestMiddleware = void 0);
                const r = e('@metamask/json-rpc-engine'),
                  s = e('@metamask/rpc-errors');
                n.createQueuedRequestMiddleware = ({
                  enqueueRequest: e,
                  useRequestQueue: t,
                  shouldEnqueueRequest: n,
                }) =>
                  (0, r.createAsyncMiddleware)(async (r, a, o) => {
                    if (
                      ((function (e) {
                        if (!e.origin) throw new Error("Request object is lacking an 'origin'");
                        if ('string' != typeof e.origin)
                          throw new Error(
                            `Request object has an invalid origin of type '${typeof e.origin}'`
                          );
                        if (!e.networkClientId)
                          throw new Error("Request object is lacking a 'networkClientId'");
                        if ('string' != typeof e.networkClientId)
                          throw new Error(
                            `Request object has an invalid networkClientId of type '${typeof e.networkClientId}'`
                          );
                      })(r),
                      !t() || !n(r))
                    )
                      return await o();
                    try {
                      await e(r, o);
                    } catch (e) {
                      a.error = (0, s.serializeError)(e);
                    }
                    return undefined;
                  });
              };
            };
      },
      {
        package: '@metamask/queued-request-controller',
        file: 'node_modules/@metamask/queued-request-controller/dist/QueuedRequestMiddleware.cjs',
      },
    ],
    [
      2547,
      { './QueuedRequestController.cjs': 2545, './QueuedRequestMiddleware.cjs': 2546 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.createQueuedRequestMiddleware =
                    n.QueuedRequestController =
                    n.QueuedRequestControllerEventTypes =
                    n.QueuedRequestControllerActionTypes =
                      void 0);
                var r = e('./QueuedRequestController.cjs');
                Object.defineProperty(n, 'QueuedRequestControllerActionTypes', {
                  enumerable: !0,
                  get: function () {
                    return r.QueuedRequestControllerActionTypes;
                  },
                }),
                  Object.defineProperty(n, 'QueuedRequestControllerEventTypes', {
                    enumerable: !0,
                    get: function () {
                      return r.QueuedRequestControllerEventTypes;
                    },
                  }),
                  Object.defineProperty(n, 'QueuedRequestController', {
                    enumerable: !0,
                    get: function () {
                      return r.QueuedRequestController;
                    },
                  });
                var s = e('./QueuedRequestMiddleware.cjs');
                Object.defineProperty(n, 'createQueuedRequestMiddleware', {
                  enumerable: !0,
                  get: function () {
                    return s.createQueuedRequestMiddleware;
                  },
                });
              };
            };
      },
      {
        package: '@metamask/queued-request-controller',
        file: 'node_modules/@metamask/queued-request-controller/dist/index.cjs',
      },
    ],
    [
      2548,
      {},
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.BaseControllerV1 = n.isBaseControllerV1 = void 0),
                  (n.isBaseControllerV1 = function (e) {
                    return (
                      'name' in e &&
                      'string' == typeof e.name &&
                      'config' in e &&
                      'object' == typeof e.config &&
                      'defaultConfig' in e &&
                      'object' == typeof e.defaultConfig &&
                      'state' in e &&
                      'object' == typeof e.state &&
                      'defaultState' in e &&
                      'object' == typeof e.defaultState &&
                      'disabled' in e &&
                      'boolean' == typeof e.disabled &&
                      'subscribe' in e &&
                      'function' == typeof e.subscribe
                    );
                  });
                class r {
                  constructor(e = {}, t = {}) {
                    (this.defaultConfig = {}),
                      (this.defaultState = {}),
                      (this.disabled = !1),
                      (this.name = 'BaseController'),
                      (this.internalConfig = this.defaultConfig),
                      (this.internalState = this.defaultState),
                      (this.internalListeners = []),
                      (this.initialState = t),
                      (this.initialConfig = e);
                  }
                  initialize() {
                    return (
                      (this.internalState = this.defaultState),
                      (this.internalConfig = this.defaultConfig),
                      this.configure(this.initialConfig),
                      this.update(this.initialState),
                      this
                    );
                  }
                  get config() {
                    return this.internalConfig;
                  }
                  get state() {
                    return this.internalState;
                  }
                  configure(e, t = !1, n = !0) {
                    if (n) {
                      this.internalConfig = t ? e : Object.assign(this.internalConfig, e);
                      for (const e of Object.keys(this.internalConfig)) {
                        const t = this.internalConfig[e];
                        t !== undefined && (this[e] = t);
                      }
                    } else
                      for (const t of Object.keys(e))
                        if (this.internalConfig[t] !== undefined) {
                          const n = e[t];
                          (this.internalConfig[t] = n), (this[t] = n);
                        }
                  }
                  notify() {
                    this.disabled ||
                      this.internalListeners.forEach(e => {
                        e(this.internalState);
                      });
                  }
                  subscribe(e) {
                    this.internalListeners.push(e);
                  }
                  unsubscribe(e) {
                    const t = this.internalListeners.findIndex(t => e === t);
                    return t > -1 && this.internalListeners.splice(t, 1), t > -1;
                  }
                  update(e, t = !1) {
                    (this.internalState = t
                      ? Object.assign({}, e)
                      : Object.assign({}, this.internalState, e)),
                      this.notify();
                  }
                }
                (n.BaseControllerV1 = r), (n.default = r);
              };
            };
      },
      {
        package: '@metamask/queued-request-controller>@metamask/base-controller',
        file: 'node_modules/@metamask/queued-request-controller/node_modules/@metamask/base-controller/dist/BaseControllerV1.cjs',
      },
    ],
    [
      2549,
      { immer: 4715 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                var r,
                  s =
                    (this && this.__classPrivateFieldSet) ||
                    function (e, t, n, r, s) {
                      if ('m' === r) throw new TypeError('Private method is not writable');
                      if ('a' === r && !s)
                        throw new TypeError('Private accessor was defined without a setter');
                      if ('function' == typeof t ? e !== t || !s : !t.has(e))
                        throw new TypeError(
                          'Cannot write private member to an object whose class did not declare it'
                        );
                      return 'a' === r ? s.call(e, n) : s ? (s.value = n) : t.set(e, n), n;
                    },
                  a =
                    (this && this.__classPrivateFieldGet) ||
                    function (e, t, n, r) {
                      if ('a' === n && !r)
                        throw new TypeError('Private accessor was defined without a getter');
                      if ('function' == typeof t ? e !== t || !r : !t.has(e))
                        throw new TypeError(
                          'Cannot read private member from an object whose class did not declare it'
                        );
                      return 'm' === n ? r : 'a' === n ? r.call(e) : r ? r.value : t.get(e);
                    };
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.getPersistentState =
                    n.getAnonymizedState =
                    n.BaseController =
                    n.isBaseController =
                      void 0);
                const o = e('immer');
                (0, o.enablePatches)(),
                  (n.isBaseController = function (e) {
                    return (
                      'name' in e &&
                      'string' == typeof e.name &&
                      'state' in e &&
                      'object' == typeof e.state &&
                      'metadata' in e &&
                      'object' == typeof e.metadata
                    );
                  });
                function i(e, t, n) {
                  return Object.keys(e).reduce((r, s) => {
                    try {
                      const a = t[s];
                      if (!a) throw new Error(`No metadata found for '${String(s)}'`);
                      const o = a[n],
                        i = e[s];
                      return 'function' == typeof o ? (r[s] = o(i)) : o && (r[s] = i), r;
                    } catch (e) {
                      return (
                        setTimeout(() => {
                          throw e;
                        }),
                        r
                      );
                    }
                  }, {});
                }
                (n.BaseController = class {
                  constructor({ messenger: e, metadata: t, name: n, state: a }) {
                    r.set(this, void 0),
                      (this.messagingSystem = e),
                      (this.name = n),
                      s(this, r, (0, o.freeze)(a, !0), 'f'),
                      (this.metadata = t),
                      this.messagingSystem.registerActionHandler(`${n}:getState`, () => this.state),
                      this.messagingSystem.registerInitialEventPayload({
                        eventType: `${n}:stateChange`,
                        getPayload: () => [this.state, []],
                      });
                  }
                  get state() {
                    return a(this, r, 'f');
                  }
                  set state(e) {
                    throw new Error(
                      "Controller state cannot be directly mutated; use 'update' method instead."
                    );
                  }
                  update(e) {
                    const [t, n, i] = o.produceWithPatches(a(this, r, 'f'), e);
                    return (
                      s(this, r, t, 'f'),
                      this.messagingSystem.publish(`${this.name}:stateChange`, t, n),
                      { nextState: t, patches: n, inversePatches: i }
                    );
                  }
                  applyPatches(e) {
                    const t = (0, o.applyPatches)(a(this, r, 'f'), e);
                    s(this, r, t, 'f'),
                      this.messagingSystem.publish(`${this.name}:stateChange`, t, e);
                  }
                  destroy() {
                    this.messagingSystem.clearEventSubscriptions(`${this.name}:stateChange`);
                  }
                }),
                  (r = new WeakMap()),
                  (n.getAnonymizedState = function (e, t) {
                    return i(e, t, 'anonymous');
                  }),
                  (n.getPersistentState = function (e, t) {
                    return i(e, t, 'persist');
                  });
              };
            };
      },
      {
        package: '@metamask/queued-request-controller>@metamask/base-controller',
        file: 'node_modules/@metamask/queued-request-controller/node_modules/@metamask/base-controller/dist/BaseControllerV2.cjs',
      },
    ],
    [
      255,
      { '../../../shared/constants/network': 5804, lodash: 4921 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.default = void 0);
                var r = e('lodash'),
                  s = e('../../../shared/constants/network');
                n.default = {
                  version: 51,
                  async migrate(e) {
                    const t = (0, r.cloneDeep)(e);
                    t.meta.version = 51;
                    const n = t.data;
                    return (
                      (t.data = (function (e) {
                        var t, n;
                        const { chainId: r, type: a } =
                            (null == e || null === (t = e.NetworkController) || void 0 === t
                              ? void 0
                              : t.provider) || {},
                          o =
                            null === (n = s.BUILT_IN_NETWORKS[a]) || void 0 === n
                              ? void 0
                              : n.chainId;
                        o && r !== o && (e.NetworkController.provider.chainId = o);
                        return e;
                      })(n)),
                      t
                    );
                  },
                };
              };
            };
      },
      { package: '$root$', file: 'app/scripts/migrations/051.js' },
    ],
    [
      2550,
      { './RestrictedMessenger.cjs': 2551 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                var r,
                  s,
                  a,
                  o,
                  i =
                    (this && this.__classPrivateFieldGet) ||
                    function (e, t, n, r) {
                      if ('a' === n && !r)
                        throw new TypeError('Private accessor was defined without a getter');
                      if ('function' == typeof t ? e !== t || !r : !t.has(e))
                        throw new TypeError(
                          'Cannot read private member from an object whose class did not declare it'
                        );
                      return 'm' === n ? r : 'a' === n ? r.call(e) : r ? r.value : t.get(e);
                    };
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.ControllerMessenger = n.Messenger = void 0);
                const c = e('./RestrictedMessenger.cjs');
                class l {
                  constructor() {
                    r.set(this, new Map()),
                      s.set(this, new Map()),
                      a.set(this, new Map()),
                      o.set(this, new Map());
                  }
                  registerActionHandler(e, t) {
                    if (i(this, r, 'f').has(e))
                      throw new Error(`A handler for ${e} has already been registered`);
                    i(this, r, 'f').set(e, t);
                  }
                  unregisterActionHandler(e) {
                    i(this, r, 'f').delete(e);
                  }
                  clearActions() {
                    i(this, r, 'f').clear();
                  }
                  call(e, ...t) {
                    const n = i(this, r, 'f').get(e);
                    if (!n) throw new Error(`A handler for ${e} has not been registered`);
                    return n(...t);
                  }
                  registerInitialEventPayload({ eventType: e, getPayload: t }) {
                    i(this, a, 'f').set(e, t);
                  }
                  publish(e, ...t) {
                    const n = i(this, s, 'f').get(e);
                    if (n)
                      for (const [e, r] of n.entries())
                        try {
                          if (r) {
                            const n = i(this, o, 'f').get(e),
                              s = r(...t);
                            s !== n && (i(this, o, 'f').set(e, s), e(s, n));
                          } else e(...t);
                        } catch (e) {
                          setTimeout(() => {
                            throw e;
                          });
                        }
                  }
                  subscribe(e, t, n) {
                    let r = i(this, s, 'f').get(e);
                    if ((r || ((r = new Map()), i(this, s, 'f').set(e, r)), r.set(t, n), n)) {
                      const r = i(this, a, 'f').get(e);
                      if (r) {
                        const e = n(...r());
                        i(this, o, 'f').set(t, e);
                      }
                    }
                  }
                  unsubscribe(e, t) {
                    const n = i(this, s, 'f').get(e);
                    if (!n || !n.has(t)) throw new Error(`Subscription not found for event: ${e}`);
                    n.get(t) && i(this, o, 'f').delete(t), n.delete(t);
                  }
                  clearEventSubscriptions(e) {
                    i(this, s, 'f').delete(e);
                  }
                  clearSubscriptions() {
                    i(this, s, 'f').clear();
                  }
                  getRestricted({ name: e, allowedActions: t, allowedEvents: n }) {
                    return new c.RestrictedMessenger({
                      messenger: this,
                      name: e,
                      allowedActions: t,
                      allowedEvents: n,
                    });
                  }
                }
                (n.Messenger = l),
                  (n.ControllerMessenger = l),
                  (r = new WeakMap()),
                  (s = new WeakMap()),
                  (a = new WeakMap()),
                  (o = new WeakMap());
              };
            };
      },
      {
        package: '@metamask/queued-request-controller>@metamask/base-controller',
        file: 'node_modules/@metamask/queued-request-controller/node_modules/@metamask/base-controller/dist/Messenger.cjs',
      },
    ],
    [
      2551,
      {},
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                var r,
                  s,
                  a,
                  o,
                  i,
                  c,
                  l,
                  d,
                  u =
                    (this && this.__classPrivateFieldSet) ||
                    function (e, t, n, r, s) {
                      if ('m' === r) throw new TypeError('Private method is not writable');
                      if ('a' === r && !s)
                        throw new TypeError('Private accessor was defined without a setter');
                      if ('function' == typeof t ? e !== t || !s : !t.has(e))
                        throw new TypeError(
                          'Cannot write private member to an object whose class did not declare it'
                        );
                      return 'a' === r ? s.call(e, n) : s ? (s.value = n) : t.set(e, n), n;
                    },
                  h =
                    (this && this.__classPrivateFieldGet) ||
                    function (e, t, n, r) {
                      if ('a' === n && !r)
                        throw new TypeError('Private accessor was defined without a getter');
                      if ('function' == typeof t ? e !== t || !r : !t.has(e))
                        throw new TypeError(
                          'Cannot read private member from an object whose class did not declare it'
                        );
                      return 'm' === n ? r : 'a' === n ? r.call(e) : r ? r.value : t.get(e);
                    };
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.RestrictedControllerMessenger = n.RestrictedMessenger = void 0);
                class p {
                  constructor({
                    controllerMessenger: e,
                    messenger: t,
                    name: n,
                    allowedActions: c,
                    allowedEvents: l,
                  }) {
                    if (
                      (r.add(this),
                      s.set(this, void 0),
                      a.set(this, void 0),
                      o.set(this, void 0),
                      i.set(this, void 0),
                      t && e)
                    )
                      throw new Error(
                        "Both messenger properties provided. Provide message using only 'messenger' option, 'controllerMessenger' is deprecated"
                      );
                    if (!t && !e) throw new Error('Messenger not provided');
                    u(this, s, t ?? e, 'f'),
                      u(this, a, n, 'f'),
                      u(this, o, c, 'f'),
                      u(this, i, l, 'f');
                  }
                  registerActionHandler(e, t) {
                    if (!h(this, r, 'm', d).call(this, e))
                      throw new Error(
                        `Only allowed registering action handlers prefixed by '${h(this, a, 'f')}:'`
                      );
                    h(this, s, 'f').registerActionHandler(e, t);
                  }
                  unregisterActionHandler(e) {
                    if (!h(this, r, 'm', d).call(this, e))
                      throw new Error(
                        `Only allowed unregistering action handlers prefixed by '${h(this, a, 'f')}:'`
                      );
                    h(this, s, 'f').unregisterActionHandler(e);
                  }
                  call(e, ...t) {
                    if (!h(this, r, 'm', l).call(this, e))
                      throw new Error(`Action missing from allow list: ${e}`);
                    return h(this, s, 'f').call(e, ...t);
                  }
                  registerInitialEventPayload({ eventType: e, getPayload: t }) {
                    if (!h(this, r, 'm', d).call(this, e))
                      throw new Error(
                        `Only allowed publishing events prefixed by '${h(this, a, 'f')}:'`
                      );
                    h(this, s, 'f').registerInitialEventPayload({ eventType: e, getPayload: t });
                  }
                  publish(e, ...t) {
                    if (!h(this, r, 'm', d).call(this, e))
                      throw new Error(
                        `Only allowed publishing events prefixed by '${h(this, a, 'f')}:'`
                      );
                    h(this, s, 'f').publish(e, ...t);
                  }
                  subscribe(e, t, n) {
                    if (!h(this, r, 'm', c).call(this, e))
                      throw new Error(`Event missing from allow list: ${e}`);
                    return n ? h(this, s, 'f').subscribe(e, t, n) : h(this, s, 'f').subscribe(e, t);
                  }
                  unsubscribe(e, t) {
                    if (!h(this, r, 'm', c).call(this, e))
                      throw new Error(`Event missing from allow list: ${e}`);
                    h(this, s, 'f').unsubscribe(e, t);
                  }
                  clearEventSubscriptions(e) {
                    if (!h(this, r, 'm', d).call(this, e))
                      throw new Error(
                        `Only allowed clearing events prefixed by '${h(this, a, 'f')}:'`
                      );
                    h(this, s, 'f').clearEventSubscriptions(e);
                  }
                }
                (n.RestrictedMessenger = p),
                  (n.RestrictedControllerMessenger = p),
                  (s = new WeakMap()),
                  (a = new WeakMap()),
                  (o = new WeakMap()),
                  (i = new WeakMap()),
                  (r = new WeakSet()),
                  (c = function (e) {
                    const t = h(this, i, 'f');
                    return h(this, r, 'm', d).call(this, e) || (null !== t && t.includes(e));
                  }),
                  (l = function (e) {
                    const t = h(this, o, 'f');
                    return h(this, r, 'm', d).call(this, e) || (null !== t && t.includes(e));
                  }),
                  (d = function (e) {
                    return e.startsWith(`${h(this, a, 'f')}:`);
                  });
              };
            };
      },
      {
        package: '@metamask/queued-request-controller>@metamask/base-controller',
        file: 'node_modules/@metamask/queued-request-controller/node_modules/@metamask/base-controller/dist/RestrictedMessenger.cjs',
      },
    ],
    [
      2552,
      {
        './BaseControllerV1.cjs': 2548,
        './BaseControllerV2.cjs': 2549,
        './Messenger.cjs': 2550,
        './RestrictedMessenger.cjs': 2551,
      },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.RestrictedMessenger =
                    n.RestrictedControllerMessenger =
                    n.Messenger =
                    n.ControllerMessenger =
                    n.isBaseController =
                    n.getPersistentState =
                    n.getAnonymizedState =
                    n.BaseController =
                    n.isBaseControllerV1 =
                    n.BaseControllerV1 =
                      void 0);
                var r = e('./BaseControllerV1.cjs');
                Object.defineProperty(n, 'BaseControllerV1', {
                  enumerable: !0,
                  get: function () {
                    return r.BaseControllerV1;
                  },
                }),
                  Object.defineProperty(n, 'isBaseControllerV1', {
                    enumerable: !0,
                    get: function () {
                      return r.isBaseControllerV1;
                    },
                  });
                var s = e('./BaseControllerV2.cjs');
                Object.defineProperty(n, 'BaseController', {
                  enumerable: !0,
                  get: function () {
                    return s.BaseController;
                  },
                }),
                  Object.defineProperty(n, 'getAnonymizedState', {
                    enumerable: !0,
                    get: function () {
                      return s.getAnonymizedState;
                    },
                  }),
                  Object.defineProperty(n, 'getPersistentState', {
                    enumerable: !0,
                    get: function () {
                      return s.getPersistentState;
                    },
                  }),
                  Object.defineProperty(n, 'isBaseController', {
                    enumerable: !0,
                    get: function () {
                      return s.isBaseController;
                    },
                  });
                var a = e('./Messenger.cjs');
                Object.defineProperty(n, 'ControllerMessenger', {
                  enumerable: !0,
                  get: function () {
                    return a.ControllerMessenger;
                  },
                }),
                  Object.defineProperty(n, 'Messenger', {
                    enumerable: !0,
                    get: function () {
                      return a.Messenger;
                    },
                  });
                var o = e('./RestrictedMessenger.cjs');
                Object.defineProperty(n, 'RestrictedControllerMessenger', {
                  enumerable: !0,
                  get: function () {
                    return o.RestrictedControllerMessenger;
                  },
                }),
                  Object.defineProperty(n, 'RestrictedMessenger', {
                    enumerable: !0,
                    get: function () {
                      return o.RestrictedMessenger;
                    },
                  });
              };
            };
      },
      {
        package: '@metamask/queued-request-controller>@metamask/base-controller',
        file: 'node_modules/@metamask/queued-request-controller/node_modules/@metamask/base-controller/dist/index.cjs',
      },
    ],
    [
      2553,
      { './errors.cjs': 2561, '@metamask/superstruct': 2913 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }),
                  (n.assertExhaustive = n.assertStruct = n.assert = n.AssertionError = void 0);
                const r = e('@metamask/superstruct'),
                  s = e('./errors.cjs');
                function a(e, t) {
                  return (
                    (n = e),
                    Boolean('string' == typeof n?.prototype?.constructor?.name)
                      ? new e({ message: t })
                      : e({ message: t })
                  );
                  var n;
                }
                class o extends Error {
                  constructor(e) {
                    super(e.message), (this.code = 'ERR_ASSERTION');
                  }
                }
                (n.AssertionError = o),
                  (n.assert = function (e, t = 'Assertion failed.', n = o) {
                    if (!e) {
                      if (t instanceof Error) throw t;
                      throw a(n, t);
                    }
                  }),
                  (n.assertStruct = function (e, t, n = 'Assertion failed', i = o) {
                    try {
                      (0, r.assert)(e, t);
                    } catch (e) {
                      throw a(
                        i,
                        `${n}: ${(function (e) {
                          return (0, s.getErrorMessage)(e).replace(/\.$/u, '');
                        })(e)}.`
                      );
                    }
                  }),
                  (n.assertExhaustive = function (e) {
                    throw new Error(
                      'Invalid branch reached. Should be detected during compilation.'
                    );
                  });
              };
            };
      },
      {
        package: '@metamask/queued-request-controller>@metamask/utils',
        file: 'node_modules/@metamask/queued-request-controller/node_modules/@metamask/utils/dist/assert.cjs',
      },
    ],
    [
      2554,
      { './assert.cjs': 2553, '@metamask/superstruct': 2913 },
      function () {
        with (this.scopeTerminator)
          with (this.globalThis)
            return function () {
              'use strict';
              return function (e, t, n) {
                Object.defineProperty(n, '__esModule', { value: !0 }), (n.base64 = void 0);
                const r = e('@metamask/superstruct'),
                  s = e('./assert.cjs');
                n.base64 = (e, t = {}) => {
                  const n = t.paddingRequired ?? !1,
                    a = t.characterSet ?? 'base64';
                  let o, i;
                  return (
                    'base64' === a
                      ? (o = String.raw`[A-Za-z0-9+\/]`)
                      : ((0, s.assert)('base64url' === a), (o = String.raw`[-_A-Za-z0-9]`)),
                    (i = n
                      ? new RegExp(`^(?:${o}{4})*(?:${o}{3}=|${o}{2}==)?$`, 'u')
                      : new RegExp(`^(?:${o}{4})*(?:${o}{2,3}|${o}{3}=|${o}{2}==)?$`, 'u')),
                    (0, r.pattern)(e, i)
                  );
                };
              };
            };
      },
      {
        package: '@metamask/queued-request-controller>@metamask/utils',
        file: 'node_modules/@metamask/queued-request-controller/node_modules/@metamask/utils/dist/base64.cjs',
      },
    ],
  ],
  [],
  {}
);
