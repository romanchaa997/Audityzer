// @ts-nocheck
import { test, expect, Page } from '@playwright/test';
import { connectWallet, getWalletState } from '../../tests/utils/walletMock';

/**
 * Security bug: Access Control Vulnerabilities
 *
 * Vulnerability explanation:
 * Access control vulnerabilities occur when a Web3 application doesn't properly restrict
 * access to functions or data based on user roles or permissions. This can result in:
 * 1. Unauthorized users accessing privileged functions/data
 * 2. Missing owner/admin checks in smart contract interactions
 * 3. Improper access control checks in the frontend that can be bypassed
 * 4. Contracts relying only on front-end checks without on-chain validation
 *
 * This test checks for:
 * - Missing or insufficient access control checks
 * - Unauthorized access attempts that succeed
 * - Admin-only functions accessible by regular users
 * - Front-end checks that can be bypassed via direct contract calls
 */

// Create a mock dApp page for testing
async function createMockDappPage(page: Page) {
  await page.setContent(`
    <html>
      <body>
        <h1>Test dApp - Access Control Vulnerability</h1>
        <button id="connect-wallet">Connect Wallet</button>
        <div id="access-controls">
          <h2>Access Control Tests</h2>
          <button id="regular-function">Call Regular Function</button>
          <button id="admin-function">Call Admin Function</button>
          <button id="owner-function">Call Owner Function</button>
          <button id="bypass-frontend">Bypass Frontend Check</button>
        </div>
        <div id="result"></div>
        <div id="status"></div>
        
        <script>
          // Mock roles and addresses
          const mockOwner = '0x742d35Cc6634C0532925a3b844Bc454e4438f44e';
          const mockAdmins = ['0x742d35Cc6634C0532925a3b844Bc454e4438f44e', '0xAnotherAdminAddress'];
          let currentAccount = '';
          
          // Mock contract ABI and interface (simulated)
          const mockContract = {
            address: '0xContractAddressMock',
            isOwner: (address) => address.toLowerCase() === mockOwner.toLowerCase(),
            isAdmin: (address) => mockAdmins.some(admin => admin.toLowerCase() === address.toLowerCase()),
            
            // Regular accessible function
            regularFunction: async () => {
              return { success: true, result: 'Regular function executed successfully' };
            },
            
            // Should only be accessible by admin
            adminFunction: async (address) => {
              // VULNERABILITY: Missing access control check in implementation
              // Should check if address is admin but doesn't
              return { success: true, result: 'Admin function executed successfully' };
            },
            
            // Should only be accessible by owner
            ownerFunction: async (address) => {
              // Proper check
              if (address.toLowerCase() !== mockOwner.toLowerCase()) {
                return { success: false, error: 'Unauthorized: Only owner can call this function' };
              }
              return { success: true, result: 'Owner function executed successfully' };
            },
            
            // Function with frontend-only check (bypassed through direct call)
            vulnerableFunction: async () => {
              // No on-chain check at all
              return { success: true, result: 'Vulnerability: Function with no access control executed' };
            }
          };
          
          // Connect wallet function
          document.getElementById('connect-wallet').addEventListener('click', async () => {
            if (window.ethereum) {
              try {
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                currentAccount = accounts[0];
                document.getElementById('result').textContent = 'Connected: ' + currentAccount;
                
                // Show access check
                const isAdmin = mockContract.isAdmin(currentAccount);
                const isOwner = mockContract.isOwner(currentAccount);
                document.getElementById('status').textContent = 
                  'Roles: ' + (isOwner ? 'Owner, ' : '') + (isAdmin ? 'Admin, ' : '') + 'User';
              } catch (error) {
                document.getElementById('result').textContent = 'Error: ' + error.message;
              }
            } else {
              document.getElementById('result').textContent = 'No wallet detected';
            }
          });
          
          // Regular function - accessible by anyone
          document.getElementById('regular-function').addEventListener('click', async () => {
            if (!currentAccount) {
              document.getElementById('status').textContent = 'Please connect wallet first';
              return;
            }
            
            const response = await mockContract.regularFunction();
            document.getElementById('status').textContent = response.success ? 
              response.result : response.error;
          });
          
          // Admin function - should only be accessible by admins
          document.getElementById('admin-function').addEventListener('click', async () => {
            if (!currentAccount) {
              document.getElementById('status').textContent = 'Please connect wallet first';
              return;
            }
            
            // SECURE: Frontend check before calling contract
            if (!mockContract.isAdmin(currentAccount)) {
              document.getElementById('status').textContent = 
                'Frontend check: Only admins can access this function';
              return;
            }
            
            // Call contract method (which should also verify but doesn't)
            const response = await mockContract.adminFunction(currentAccount);
            document.getElementById('status').textContent = response.success ? 
              response.result : response.error;
          });
          
          // Owner function - should only be accessible by owner
          document.getElementById('owner-function').addEventListener('click', async () => {
            if (!currentAccount) {
              document.getElementById('status').textContent = 'Please connect wallet first';
              return;
            }
            
            // SECURE: Both frontend and contract verify
            if (!mockContract.isOwner(currentAccount)) {
              document.getElementById('status').textContent = 
                'Frontend check: Only owner can access this function';
              return;
            }
            
            const response = await mockContract.ownerFunction(currentAccount);
            document.getElementById('status').textContent = response.success ? 
              response.result : response.error;
          });
          
          // Bypass frontend - simulates direct contract call bypassing frontend checks
          document.getElementById('bypass-frontend').addEventListener('click', async () => {
            if (!currentAccount) {
              document.getElementById('status').textContent = 'Please connect wallet first';
              return;
            }
            
            // Direct contract call bypassing frontend check
            // Simulates making a direct call to the contract
            
            // Direct call to admin function (frontend check bypassed)
            const response = await mockContract.adminFunction(currentAccount);
            document.getElementById('status').textContent = 'BYPASS ATTEMPT: ' + 
              (response.success ? response.result : response.error);
              
            if (response.success) {
            }
          });
          
          // Expose for testing
          window.mockContract = mockContract;
          window.isConnected = () => !!currentAccount;
          window.getCurrentAccount = () => currentAccount;
        </script>
      </body>
    </html>
  `);
}

test.describe('Access Control Vulnerability Detection', () => {
  test('detects missing access controls in contract functions', async ({ page }) => {
    // Set up a mock dApp page
    await createMockDappPage(page);
    
    // Connect wallet with non-admin account
    await connectWallet(page, {
      provider: 'metamask',
      address: '0xNonAdminUserAddress123456789abcdef',
      chainId: '0x1', // Ethereum mainnet
    });
    
    // Connect to the app
    await page.click('#connect-wallet');
    await page.waitForTimeout(500);
    
    const statusText = await page.textContent('#status');
    expect(statusText).toContain('Roles: User');
    
    // Track detected vulnerabilities
    let accessControlVulnerabilityDetected = false;
    
    // Monitor for vulnerability log messages
    page.on('console', msg => {
      const text = msg.text();
      if (text.includes('VULNERABILITY_DETECTED')) {
        accessControlVulnerabilityDetected = true;
      } else if (text.includes('SECURITY_BYPASS')) {
      }
    });
    
    // Try to access admin function through frontend
    await page.click('#admin-function');
    await page.waitForTimeout(500);
    
    // Frontend should block this
    let result = await page.textContent('#status');
    expect(result).toContain('Only admins can access');
    
    // Try to bypass frontend checks
    await page.click('#bypass-frontend');
    await page.waitForTimeout(500);
    
    // Check if we could bypass
    result = await page.textContent('#status');
    expect(result).toContain('Admin function executed successfully');
    
    // Verify that we flagged the vulnerability
    expect(accessControlVulnerabilityDetected).toBe(true);
  });

  test('verifies proper access control implementations', async ({ page }) => {
    // Set up a mock dApp page
    await createMockDappPage(page);
    
    // Connect as owner/admin
    await connectWallet(page, {
      provider: 'metamask',
      address: '0x742d35Cc6634C0532925a3b844Bc454e4438f44e', // Owner address
      chainId: '0x1',
    });
    
    // Connect to the app
    await page.click('#connect-wallet');
    await page.waitForTimeout(500);
    
    const statusText = await page.textContent('#status');
    expect(statusText).toContain('Owner');
    expect(statusText).toContain('Admin');
    
    // Access regular function
    await page.click('#regular-function');
    await page.waitForTimeout(500);
    let result = await page.textContent('#status');
    expect(result).toContain('Regular function executed successfully');
    
    // Access admin function
    await page.click('#admin-function');
    await page.waitForTimeout(500);
    result = await page.textContent('#status');
    expect(result).toContain('Admin function executed successfully');
    
    // Access owner function
    await page.click('#owner-function');
    await page.waitForTimeout(500);
    result = await page.textContent('#status');
    expect(result).toContain('Owner function executed successfully');
    
    // Verify contract-level protections
    const hasOwnerCheck = await page.evaluate(async () => {
      const randomAddress = '0xRandomUserAddress123456789abcdef';
      const response = await window.mockContract.ownerFunction(randomAddress);
      return !response.success;
    });
    
    expect(hasOwnerCheck).toBe(true);
  });

  test('recommends fixes for access control vulnerabilities', async ({ page }) => {
    // Set up a mock dApp page
    await createMockDappPage(page);
    
    // Connect with non-privileged account
    await connectWallet(page, {
      provider: 'metamask',
      address: '0xNonPrivilegedUser123456789abcdef',
      chainId: '0x1',
    });
    
    // Connect to the app
    await page.click('#connect-wallet');
    await page.waitForTimeout(500);
    
    // Try the bypass
    await page.click('#bypass-frontend');
    await page.waitForTimeout(500);
    
    // Verify the vulnerability
    const result = await page.textContent('#status');
    expect(result).toContain('BYPASS ATTEMPT');
    expect(result).toContain('Admin function executed successfully');
    
    // Check contract implementation
    const adminFunctionImplementation = await page.evaluate(() => {
      return window.mockContract.adminFunction.toString();
    });
    
    // Recommendation: The contract should perform access control checks
    const recommendation = `
    Fix recommendations:
    1. Add on-chain access control checks to the adminFunction: 
       if (!isAdmin(address)) revert("Not authorized");
    2. Use OpenZeppelin AccessControl or Roles library
    3. Add events for admin actions for transparency
    4. Implement two-step verification for critical functions
    5. Never rely solely on frontend access control checks
    `;
    
    
    // This test passes - it's documenting the vulnerability and recommendations
    expect(true).toBe(true);
  });
}); 