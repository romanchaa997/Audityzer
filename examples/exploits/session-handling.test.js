/* global describe, it, expect, beforeEach, afterEach, jest */
/**
 * Test case description: DApp session handling vulnerability detection
 * Vulnerability: Session management, error leaks, and authentication issues
 * Manual reproduction steps:
 *   1. Connect to a dApp and establish a session
 *   2. Test session persistence and invalidation
 *   3. Analyze error messages for sensitive information
 *   4. Test cross-site request forgery protections
 * Security impact: Could result in account takeover, session hijacking or leak of sensitive data
 */

const { test, expect } = require('@playwright/test');
const { connectWallet, setupWalletState } = require('../../utils/wallet-helpers');

test.describe('DApp Session Handling Vulnerability Tests', () => {
  const USER_ADDRESS = '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266';

  test.beforeEach(async ({ page, context }) => {
    // Setup wallet state for testing
    await setupWalletState(page, {
      chainId: '0x1',
      networkName: 'Ethereum Mainnet',
      accounts: [USER_ADDRESS],
      balance: '100000000000000000000', // 100 ETH
    });

    // Navigate to the DApp
    await page.goto(process.env.DAPP_URL || 'https://app.example.org');
    await connectWallet(page);

    // Initialize testing environment
    await page.addInitScript(() => {
      // Storage for vulnerability findings
      window._vulnerabilityFindings = [];
      window._errorMessages = [];
      window._sessionData = null;

      // Function to record vulnerability
      window.recordVulnerability = function (finding) {
        window._vulnerabilityFindings.push({
          timestamp: Date.now(),
          ...finding,
        });

        console.log('Vulnerability recorded:', finding);
        return window._vulnerabilityFindings;
      };

      // Function to get vulnerability report
      window.getVulnerabilityReport = function () {
        return {
          findings: window._vulnerabilityFindings,
          summary: {
            total: window._vulnerabilityFindings.length,
            byType: window._vulnerabilityFindings.reduce((acc, finding) => {
              acc[finding.type] = (acc[finding.type] || 0) + 1;
              return acc;
            }, {}),
            bySeverity: window._vulnerabilityFindings.reduce((acc, finding) => {
              acc[finding.severity] = (acc[finding.severity] || 0) + 1;
              return acc;
            }, {}),
          },
        };
      };

      // Intercept error messages
      const originalConsoleError = console.error;
      console.error = function (...args) {
        window._errorMessages.push({
          timestamp: Date.now(),
          message: args.join(' '),
        });
        originalConsoleError.apply(console, args);
      };

      // Scan for session tokens in storage
      window.scanForSessionTokens = function () {
        const tokens = {
          localStorage: {},
          sessionStorage: {},
          cookies: document.cookie.split(';').reduce((acc, cookie) => {
            const [key, value] = cookie.trim().split('=');
            if (key) acc[key] = value;
            return acc;
          }, {}),
        };

        // Check localStorage
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          tokens.localStorage[key] = localStorage.getItem(key);
        }

        // Check sessionStorage
        for (let i = 0; i < sessionStorage.length; i++) {
          const key = sessionStorage.key(i);
          tokens.sessionStorage[key] = sessionStorage.getItem(key);
        }

        window._sessionData = tokens;
        return tokens;
      };
    });
  });

  test('should detect insecure session token storage', async ({ page }) => {
    // First, scan for session tokens
    const sessionTokens = await page.evaluate(() => {
      return window.scanForSessionTokens();
    });

    // Check for JWT tokens in localStorage (insecure)
    const vulnerableStorage = await page.evaluate(tokens => {
      const insecurePatterns = [
        /eyJ[a-zA-Z0-9_-]+\.[a-zA-Z0-9_-]+\.[a-zA-Z0-9_-]+/, // JWT token
        /^[a-f0-9]{32,}$/, // Potential API key or auth token
        /^bearer\s+[a-zA-Z0-9_.-]+$/i, // Bearer token
      ];

      const vulnerableTokens = [];

      // Check localStorage
      for (const [key, value] of Object.entries(tokens.localStorage)) {
        if (typeof value === 'string') {
          for (const pattern of insecurePatterns) {
            if (pattern.test(value)) {
              vulnerableTokens.push({
                storageType: 'localStorage',
                key,
                value: value.slice(0, 10) + '...', // Don't store full token for security
              });

              window.recordVulnerability({
                type: 'SESSION_STORAGE_VULNERABILITY',
                subType: 'Insecure Token Storage',
                severity: 'HIGH',
                description: 'Authentication token stored in localStorage',
                details: {
                  storageType: 'localStorage',
                  tokenKey: key,
                  tokenPrefix: value.slice(0, 10) + '...',
                },
                impact: 'Vulnerable to XSS attacks leading to account takeover',
              });

              break;
            }
          }
        }
      }

      return vulnerableTokens;
    }, sessionTokens);

    console.log('Session Storage Test Result:', JSON.stringify(vulnerableStorage, null, 2));

    // Get vulnerability report
    const report = await page.evaluate(() => window.getVulnerabilityReport());
    console.log('Session Storage Vulnerability Report:', JSON.stringify(report, null, 2));
  });

  test('should detect sensitive error message leaks', async ({ page }) => {
    // Trigger various error conditions by manipulating the application
    await page
      .evaluate(() => {
        // Mock functions to trigger errors
        const triggerErrors = () => {
          // Simulate API errors
          console.error(
            'Error connecting to API endpoint: https://api.example.org/v1/transactions'
          );
          console.error(
            'Error: Unable to fetch user data for address 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266'
          );

          // Simulate database errors
          console.error('PG error: relation "user_balances" does not exist');
          console.error(
            'SQL Error: SELECT * FROM users WHERE wallet_address = "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266"'
          );

          // Simulate stack traces
          console.error(`Error: Invalid signature
          at signTransaction (/app/src/utils/crypto.js:42:18)
          at processTransaction (/app/src/services/transaction.js:111:22)
          at async Object.sendTransaction (/app/src/controllers/wallet.js:89:12)`);
        };

        // Trigger the errors
        triggerErrors();

        // Analyze captured error messages for sensitive information
        const sensitivePatterns = [
          /api\..*\/(v[0-9]+)\//, // API endpoints
          /PG error|SQL Error|SELECT|INSERT|UPDATE|DELETE FROM/, // SQL queries
          /at\s+\S+\s+\(.*\.js/, // Stack traces
          /((25[0-5]|(2[0-4]|1\d|[1-9]|)\d)\.?\b){4}/, // IP addresses
          /mongodb:\/\/.*@/, // Database connection strings
          /(password|secret|key|token|auth).*[=:]\s*['"][^\s'"]+['"]/, // Credentials
        ];

        const sensitiveFinding = window._errorMessages.some(error => {
          for (const pattern of sensitivePatterns) {
            if (pattern.test(error.message)) {
              window.recordVulnerability({
                type: 'ERROR_LEAK_VULNERABILITY',
                subType: 'Sensitive Information Exposure',
                severity: 'MEDIUM',
                description: 'Application error messages expose sensitive technical details',
                details: {
                  errorMessage: error.message,
                  matchedPattern: pattern.toString(),
                  timestamp: error.timestamp,
                },
                impact:
                  'Attackers can gather information about internal systems for targeted attacks',
              });
              return true;
            }
          }
          return false;
        });

        return {
          errorCount: window._errorMessages.length,
          sensitiveErrors: sensitiveFinding,
        };
      })
      .then(result => {
        console.log('Error Leak Detection Test:', JSON.stringify(result, null, 2));
      });

    // Get vulnerability report
    const report = await page.evaluate(() => window.getVulnerabilityReport());
    console.log('Error Leak Vulnerability Report:', JSON.stringify(report, null, 2));
  });

  test('should test for CSRF vulnerabilities', async ({ page, context }) => {
    // First, establish a session with the dApp
    await page.evaluate(() => window.scanForSessionTokens());

    // Create a new page to simulate CSRF attack
    const csrfPage = await context.newPage();
    await csrfPage.goto('about:blank');

    // Create a CSRF attack simulation
    await csrfPage.setContent(`
      <!DOCTYPE html>
      <html>
        <head><title>CSRF Test</title></head>
        <body>
          <h1>CSRF Test Page</h1>
          <form id="csrfForm" method="POST" action="${process.env.DAPP_URL || 'https://app.example.org'}/api/transfer" style="display:none">
            <input type="hidden" name="to" value="0x71C7656EC7ab88b098defB751B7401B5f6d8976F" />
            <input type="hidden" name="amount" value="1000000000000000000" />
            <input type="submit" value="Submit" />
          </form>
          <script>
            // In a real attack, this would happen automatically
            // document.getElementById('csrfForm').submit();
          </script>
        </body>
      </html>
    `);

    // Check if the original page has CSRF protections
    const csrfProtection = await page.evaluate(() => {
      // Look for common CSRF protection headers
      const headers = fetch('', { method: 'HEAD' })
        .then(response => {
          return {
            hasCsrfTokenHeader:
              response.headers.has('X-CSRF-Token') || response.headers.has('X-XSRF-Token'),
            hasSameSiteAttribute:
              document.cookie.includes('SameSite=Strict') ||
              document.cookie.includes('SameSite=Lax'),
          };
        })
        .catch(() => {
          return { hasCsrfTokenHeader: false, hasSameSiteAttribute: false };
        });

      // Check if the page has CSRF tokens in forms
      const formTokens = Array.from(document.forms).some(form => {
        return Array.from(form.elements).some(
          element =>
            element.name &&
            (element.name.toLowerCase().includes('csrf') ||
              element.name.toLowerCase().includes('xsrf') ||
              element.name.toLowerCase().includes('token'))
        );
      });

      return headers.then(headerProtection => {
        const hasProtection =
          headerProtection.hasCsrfTokenHeader ||
          headerProtection.hasSameSiteAttribute ||
          formTokens;

        if (!hasProtection) {
          window.recordVulnerability({
            type: 'CSRF_VULNERABILITY',
            subType: 'Missing CSRF Protection',
            severity: 'HIGH',
            description: 'Application lacks CSRF protection mechanisms',
            details: {
              hasCsrfTokenHeader: headerProtection.hasCsrfTokenHeader,
              hasSameSiteAttribute: headerProtection.hasSameSiteAttribute,
              hasFormTokens: formTokens,
            },
            impact: 'Attackers could perform unauthorized actions on behalf of authenticated users',
          });
        }

        return {
          hasProtection,
          protectionDetails: {
            hasCsrfTokenHeader: headerProtection.hasCsrfTokenHeader,
            hasSameSiteAttribute: headerProtection.hasSameSiteAttribute,
            hasFormTokens: formTokens,
          },
        };
      });
    });

    console.log('CSRF Protection Test:', JSON.stringify(csrfProtection, null, 2));

    // Get vulnerability report
    const report = await page.evaluate(() => window.getVulnerabilityReport());
    console.log('CSRF Vulnerability Report:', JSON.stringify(report, null, 2));

    // Close the CSRF test page
    await csrfPage.close();
  });

  test('should test for session fixation vulnerabilities', async ({ page, context }) => {
    // Test if the application properly regenerates session IDs after login

    // First, capture the pre-auth session identifier
    const preAuthSession = await page.evaluate(() => {
      // Simulate logout
      if (typeof window.ethereum !== 'undefined') {
        // Disconnect wallet if possible
        console.log('Simulating wallet disconnection');
      }

      // Clear any stored accounts
      localStorage.removeItem('walletconnect');
      localStorage.removeItem('connectedWallets');

      // Scan for session identifiers before authentication
      return window.scanForSessionTokens();
    });

    // Now, perform authentication
    await connectWallet(page);

    // Capture post-auth session identifier
    const postAuthSession = await page.evaluate(() => {
      // Scan for session identifiers after authentication
      return window.scanForSessionTokens();
    });

    // Compare sessions to check for proper session regeneration
    const sessionFixationTest = await page.evaluate(
      (preAuth, postAuth) => {
        // Function to find session identifiers
        const findSessionIds = storage => {
          const sessionIds = {};

          for (const [storageType, tokens] of Object.entries(storage)) {
            for (const [key, value] of Object.entries(tokens)) {
              if (
                key.toLowerCase().includes('session') ||
                key.toLowerCase().includes('id') ||
                key.toLowerCase().includes('token')
              ) {
                if (!sessionIds[storageType]) sessionIds[storageType] = {};
                sessionIds[storageType][key] = value;
              }
            }
          }

          return sessionIds;
        };

        const preAuthIds = findSessionIds(preAuth);
        const postAuthIds = findSessionIds(postAuth);

        // Check if any pre-auth session IDs are reused after auth
        let isVulnerable = false;
        const reusedIds = {};

        for (const [storageType, tokens] of Object.entries(preAuthIds)) {
          for (const [key, value] of Object.entries(tokens)) {
            if (
              postAuthIds[storageType] &&
              postAuthIds[storageType][key] &&
              postAuthIds[storageType][key] === value
            ) {
              if (!reusedIds[storageType]) reusedIds[storageType] = {};
              reusedIds[storageType][key] = value;
              isVulnerable = true;
            }
          }
        }

        if (isVulnerable) {
          window.recordVulnerability({
            type: 'SESSION_FIXATION_VULNERABILITY',
            subType: 'Reused Session Identifier',
            severity: 'HIGH',
            description:
              'Application reuses session identifiers across authentication state changes',
            details: {
              reusedSessionIds: Object.keys(reusedIds).reduce((acc, type) => {
                acc[type] = Object.keys(reusedIds[type]);
                return acc;
              }, {}),
            },
            impact: 'Attackers could perform session fixation attacks, leading to account takeover',
          });
        }

        return {
          isVulnerable,
          reusedIds,
        };
      },
      preAuthSession,
      postAuthSession
    );

    console.log('Session Fixation Test:', JSON.stringify(sessionFixationTest, null, 2));

    // Get vulnerability report
    const report = await page.evaluate(() => window.getVulnerabilityReport());
    console.log('Session Fixation Vulnerability Report:', JSON.stringify(report, null, 2));
  });
});
