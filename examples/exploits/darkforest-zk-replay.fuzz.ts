/**
 * Test case description: ZK-SNARK manipulation and reentrancy attack detection for Dark Forest style games
 * Vulnerability: ZK proof manipulation, replay attacks, and reentrancy vulnerabilities
 * Manual reproduction steps:
 *   1. Connect to a Dark Forest game instance
 *   2. Generate and test manipulated ZK proofs
 *   3. Attempt proof replay attacks
 *   4. Test for reentrancy in move/reveal mechanics
 *   5. Test invalid elliptic curve points
 *   6. Test ZK circuit constraint validation
 *   7. Test hardcoded proof detection
 * Security impact: Could result in game state manipulation, illegal moves, or resource theft
 */

import { test, expect, Page } from '@playwright/test';
import { connectWallet, setupWalletState } from '../../utils/wallet-helpers';

// Mock ZK-SNARK proof structure (simplified for testing)
interface ZKProof {
  a: [string, string];
  b: [[string, string], [string, string]];
  c: [string, string];
  publicSignals: string[];
}

// Game move types
enum MoveType {
  REVEAL_LOCATION = 'REVEAL_LOCATION',
  MOVE = 'MOVE',
  UPGRADE = 'UPGRADE',
  MINE = 'MINE',
  CAPTURE = 'CAPTURE',
}

// Elliptic curve point helpers for advanced ZK security testing
class EllipticCurvePoint {
  x: string;
  y: string;

  constructor(x: string, y: string) {
    this.x = x;
    this.y = y;
  }

  // Check if point is on curve y^2 = x^3 + ax + b (simplified)
  isOnCurve(a = 0, b = 7): boolean {
    // This is a simplified check for the secp256k1 curve
    // In a real implementation, this would use proper big integer arithmetic
    try {
      const xBigInt = BigInt(this.x);
      const yBigInt = BigInt(this.y);
      const aBigInt = BigInt(a);
      const bBigInt = BigInt(b);

      const xCubed = xBigInt ** 3n;
      const ax = aBigInt * xBigInt;
      const right =
        (xCubed + ax + bBigInt) %
        BigInt('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F');
      const left =
        yBigInt ** 2n %
        BigInt('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F');

      return left === right;
    } catch (e) {
      return false;
    }
  }

  static generateInvalidPoint(): EllipticCurvePoint {
    // Generate point that is not on the curve
    const x = '0x' + Math.floor(Math.random() * 10 ** 50).toString(16);
    // Intentionally generate y that doesn't satisfy curve equation
    const y = '0x' + Math.floor(Math.random() * 10 ** 50).toString(16);
    return new EllipticCurvePoint(x, y);
  }
}

// Generate a mock valid ZK proof
function generateMockProof(publicSignals: string[]): ZKProof {
  return {
    a: [
      '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef',
      '0xfedcba0987654321fedcba0987654321fedcba0987654321fedcba0987654321',
    ],
    b: [
      [
        '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef',
        '0xfedcba0987654321fedcba0987654321fedcba0987654321fedcba0987654321',
      ],
      [
        '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef',
        '0xfedcba0987654321fedcba0987654321fedcba0987654321fedcba0987654321',
      ],
    ],
    c: [
      '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef',
      '0xfedcba0987654321fedcba0987654321fedcba0987654321fedcba0987654321',
    ],
    publicSignals,
  };
}

// Generate proof with invalid elliptic curve points
function generateProofWithInvalidCurvePoints(publicSignals: string[]): ZKProof {
  const invalidPoint = EllipticCurvePoint.generateInvalidPoint();
  return {
    a: [invalidPoint.x, invalidPoint.y],
    b: [
      [
        '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef',
        '0xfedcba0987654321fedcba0987654321fedcba0987654321fedcba0987654321',
      ],
      [
        '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef',
        '0xfedcba0987654321fedcba0987654321fedcba0987654321fedcba0987654321',
      ],
    ],
    c: [
      '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef',
      '0xfedcba0987654321fedcba0987654321fedcba0987654321fedcba0987654321',
    ],
    publicSignals,
  };
}

// Generate a proof with hardcoded values that might pass naive verification
function generateHardcodedProof(publicSignals: string[]): ZKProof {
  return {
    a: [
      '0x0000000000000000000000000000000000000000000000000000000000000001',
      '0x0000000000000000000000000000000000000000000000000000000000000001',
    ],
    b: [
      [
        '0x0000000000000000000000000000000000000000000000000000000000000001',
        '0x0000000000000000000000000000000000000000000000000000000000000000',
      ],
      [
        '0x0000000000000000000000000000000000000000000000000000000000000000',
        '0x0000000000000000000000000000000000000000000000000000000000000001',
      ],
    ],
    c: [
      '0x0000000000000000000000000000000000000000000000000000000000000001',
      '0x0000000000000000000000000000000000000000000000000000000000000000',
    ],
    publicSignals,
  };
}

// Helper function to modify a proof (for attack simulation)
function modifyProof(proof: ZKProof, index: number, newValue: string): ZKProof {
  const modifiedProof = JSON.parse(JSON.stringify(proof)) as ZKProof;

  if (index < modifiedProof.publicSignals.length) {
    modifiedProof.publicSignals[index] = newValue;
  }

  return modifiedProof;
}

// Helper function to modify a proof to violate circuit constraints
function modifyProofForConstraintViolation(proof: ZKProof): ZKProof {
  const modifiedProof = JSON.parse(JSON.stringify(proof)) as ZKProof;

  // Create an extremely large coordinate value that should violate constraints
  const oversizedCoordinate = '900719925474099200000000000000000000000000000';

  // Modify x coordinate to violate constraints
  if (modifiedProof.publicSignals.length > 1) {
    modifiedProof.publicSignals[1] = oversizedCoordinate;
  }

  return modifiedProof;
}

test.describe('Dark Forest ZK-SNARK and Reentrancy Vulnerability Tests', () => {
  const GAME_ADDRESS = '0xDF00DF00DF00DF00DF00DF00DF00DF00DF00DF00';
  const PLAYER_ADDRESS = '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266';

  test.beforeEach(async ({ page }) => {
    // Setup wallet state for testing
    await setupWalletState(page, {
      chainId: '0x1',
      networkName: 'Ethereum Mainnet',
      accounts: [PLAYER_ADDRESS],
      balance: '100000000000000000000', // 100 ETH
    });

    // Initialize test environment
    await page.addInitScript(() => {
      // Storage for ZK proofs and vulnerability findings
      window._zkProofs = [];
      window._usedProofs = new Set();
      window._validatedProofs = new Set();
      window._vulnerabilityFindings = [];
      window._gameState = {
        playerPlanets: {},
        moves: [],
        revealedCoordinates: new Set(),
        pendingMoves: {},
      };

      // Function to record vulnerability
      window.recordVulnerability = function (finding) {
        window._vulnerabilityFindings.push({
          timestamp: Date.now(),
          ...finding,
        });

        console.log('Vulnerability recorded:', finding);
        return window._vulnerabilityFindings;
      };

      // Function to get vulnerability report
      window.getVulnerabilityReport = function () {
        return {
          findings: window._vulnerabilityFindings,
          summary: {
            total: window._vulnerabilityFindings.length,
            byType: window._vulnerabilityFindings.reduce((acc, finding) => {
              acc[finding.type] = (acc[finding.type] || 0) + 1;
              return acc;
            }, {}),
            bySeverity: window._vulnerabilityFindings.reduce((acc, finding) => {
              acc[finding.severity] = (acc[finding.severity] || 0) + 1;
              return acc;
            }, {}),
          },
        };
      };

      // Mock ZK proof verification (simplified)
      window.verifyProof = function (proof, expectedPublicSignals) {
        // Create a unique string representation of the proof
        const proofKey = JSON.stringify(proof);

        // Check if this exact proof has been used before (replay attack)
        if (window._usedProofs.has(proofKey)) {
          return {
            verified: false,
            error: 'PROOF_ALREADY_USED',
          };
        }

        // Very basic validation (in a real system, this would use actual cryptographic verification)
        const publicSignalsMatch =
          JSON.stringify(proof.publicSignals) === JSON.stringify(expectedPublicSignals);

        // Record proof usage (to prevent replays)
        window._usedProofs.add(proofKey);

        // Record validation result
        if (publicSignalsMatch) {
          window._validatedProofs.add(proofKey);
        }

        return {
          verified: publicSignalsMatch,
          error: publicSignalsMatch ? null : 'INVALID_PUBLIC_SIGNALS',
        };
      };

      // Simulate a game move with ZK proof
      window.makeMove = function (moveType, proofData, additionalData = {}) {
        const moveId = Date.now().toString() + Math.random().toString().slice(2, 8);

        // Store the move
        window._gameState.moves.push({
          id: moveId,
          type: moveType,
          proof: proofData,
          additionalData,
          timestamp: Date.now(),
          status: 'PENDING',
        });

        // Store pending move
        window._gameState.pendingMoves[moveId] = true;

        return {
          moveId,
          success: true,
        };
      };

      // Function to simulate move mining (commit to blockchain)
      window.submitMove = function (moveId) {
        // Get the move
        const move = window._gameState.moves.find(m => m.id === moveId);

        if (!move) {
          return {
            success: false,
            error: 'MOVE_NOT_FOUND',
          };
        }

        // Update move status
        move.status = 'MINED';
        delete window._gameState.pendingMoves[moveId];

        // Update game state based on move type
        if (move.type === 'REVEAL_LOCATION') {
          const { planetId, coords } = move.additionalData;

          // Record revealed coordinates
          const coordKey = `${coords.x},${coords.y}`;
          window._gameState.revealedCoordinates.add(coordKey);

          // Assign planet to player
          window._gameState.playerPlanets[planetId] = {
            owner: window.ethereum.selectedAddress,
            coords,
          };
        }

        return {
          success: true,
          txHash:
            '0x' +
            Array(64)
              .fill(0)
              .map(() => Math.floor(Math.random() * 16).toString(16))
              .join(''),
        };
      };
    });

    // Navigate to the mock game page
    await page.goto('about:blank');
    await connectWallet(page);
  });

  test('should detect ZK proof replay attacks', async ({ page }) => {
    // First, create a valid ZK proof for revealing a planet
    await page
      .evaluate(() => {
        // Mock coordinates that would be used to generate ZK proof
        const coords = { x: '123456789', y: '987654321' };
        const planetId =
          '0x' +
          Array(64)
            .fill(0)
            .map(() => Math.floor(Math.random() * 16).toString(16))
            .join('');

        // Create a valid proof
        const validProof = {
          a: [
            '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef',
            '0xfedcba0987654321fedcba0987654321fedcba0987654321fedcba0987654321',
          ],
          b: [
            [
              '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef',
              '0xfedcba0987654321fedcba0987654321fedcba0987654321fedcba0987654321',
            ],
            [
              '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef',
              '0xfedcba0987654321fedcba0987654321fedcba0987654321fedcba0987654321',
            ],
          ],
          c: [
            '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef',
            '0xfedcba0987654321fedcba0987654321fedcba0987654321fedcba0987654321',
          ],
          publicSignals: [planetId, coords.x, coords.y, window.ethereum.selectedAddress],
        };

        // Use the proof for the first time (should be valid)
        const firstMove = window.makeMove('REVEAL_LOCATION', validProof, { planetId, coords });
        window.submitMove(firstMove.moveId);

        // Try to use the exact same proof again (replay attack)
        const replayMove = window.makeMove('REVEAL_LOCATION', validProof, { planetId, coords });

        // Check if the game contract properly detects the replay
        const expectedPublicSignals = [
          planetId,
          coords.x,
          coords.y,
          window.ethereum.selectedAddress,
        ];

        const replayVerification = window.verifyProof(validProof, expectedPublicSignals);

        // Check for vulnerability if replay succeeds
        if (replayVerification.verified || replayVerification.error !== 'PROOF_ALREADY_USED') {
          window.recordVulnerability({
            type: 'ZK_PROOF_VULNERABILITY',
            subType: 'Replay Attack',
            severity: 'CRITICAL',
            description: 'Game allows reuse of the same ZK proof',
            details: {
              originalMoveId: firstMove.moveId,
              replayMoveId: replayMove.moveId,
              replayVerificationResult: replayVerification,
            },
            impact:
              'Player could claim multiple planets with the same proof or perform duplicate actions',
          });

          return {
            isVulnerable: true,
            replayAccepted: true,
            replayAttemptResult: replayVerification,
          };
        }

        return {
          isVulnerable: false,
          replayAccepted: false,
          replayAttemptResult: replayVerification,
        };
      })
      .then(result => {
        // Log the result
        console.log('ZK Proof Replay Test:', JSON.stringify(result, null, 2));

        // Verify findings
        if (result.isVulnerable) {
          expect(result.replayAccepted).toBe(true);
        } else {
          expect(result.replayAccepted).toBe(false);
        }
      });

    // Get vulnerability report
    const report = await page.evaluate(() => window.getVulnerabilityReport());
    console.log('ZK Proof Replay Vulnerability Report:', JSON.stringify(report, null, 2));
  });

  test('should detect ZK proof manipulation vulnerabilities', async ({ page }) => {
    // Test modifying public signals to claim different coordinates or planets
    await page
      .evaluate(() => {
        // Original coordinates and planet
        const originalCoords = { x: '123456789', y: '987654321' };
        const originalPlanetId =
          '0x' +
          Array(64)
            .fill(0)
            .map(() => Math.floor(Math.random() * 16).toString(16))
            .join('');

        // Create a valid proof for the original planet
        const originalProof = {
          a: [
            '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef',
            '0xfedcba0987654321fedcba0987654321fedcba0987654321fedcba0987654321',
          ],
          b: [
            [
              '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef',
              '0xfedcba0987654321fedcba0987654321fedcba0987654321fedcba0987654321',
            ],
            [
              '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef',
              '0xfedcba0987654321fedcba0987654321fedcba0987654321fedcba0987654321',
            ],
          ],
          c: [
            '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef',
            '0xfedcba0987654321fedcba0987654321fedcba0987654321fedcba0987654321',
          ],
          publicSignals: [
            originalPlanetId,
            originalCoords.x,
            originalCoords.y,
            window.ethereum.selectedAddress,
          ],
        };

        // Modify the public signals to claim a different planet/coordinates
        // but keep the cryptographic proof the same (which should invalidate the proof)
        const manipulatedProof = JSON.parse(JSON.stringify(originalProof));
        const newPlanetId =
          '0x' +
          Array(64)
            .fill(0)
            .map(() => Math.floor(Math.random() * 16).toString(16))
            .join('');
        manipulatedProof.publicSignals[0] = newPlanetId;

        // Try to use the manipulated proof
        const manipulatedMove = window.makeMove('REVEAL_LOCATION', manipulatedProof, {
          planetId: newPlanetId,
          coords: originalCoords,
        });

        // Verify the manipulated proof
        const expectedPublicSignals = [
          newPlanetId,
          originalCoords.x,
          originalCoords.y,
          window.ethereum.selectedAddress,
        ];

        const verificationResult = window.verifyProof(manipulatedProof, expectedPublicSignals);

        // Check for vulnerability if manipulation succeeds
        if (verificationResult.verified) {
          window.recordVulnerability({
            type: 'ZK_PROOF_VULNERABILITY',
            subType: 'Public Signal Manipulation',
            severity: 'CRITICAL',
            description: 'Game accepts ZK proofs with manipulated public signals',
            details: {
              originalPlanetId,
              newPlanetId,
              coordinates: originalCoords,
              verificationResult,
            },
            impact: 'Players could claim arbitrary planets or perform unauthorized actions',
          });

          return {
            isVulnerable: true,
            manipulationAccepted: true,
            verificationResult,
          };
        }

        return {
          isVulnerable: false,
          manipulationAccepted: false,
          verificationResult,
        };
      })
      .then(result => {
        // Log the result
        console.log('ZK Proof Manipulation Test:', JSON.stringify(result, null, 2));

        // Verify findings
        if (result.isVulnerable) {
          expect(result.manipulationAccepted).toBe(true);
        } else {
          expect(result.manipulationAccepted).toBe(false);
        }
      });

    // Get vulnerability report
    const report = await page.evaluate(() => window.getVulnerabilityReport());
    console.log('ZK Proof Manipulation Vulnerability Report:', JSON.stringify(report, null, 2));
  });

  test('should detect reentrancy vulnerabilities in game actions', async ({ page }) => {
    // Test for reentrancy in move/reveal mechanics
    await page
      .evaluate(() => {
        // Simulate a planet with resources that can be mined
        const planetId =
          '0x' +
          Array(64)
            .fill(0)
            .map(() => Math.floor(Math.random() * 16).toString(16))
            .join('');
        const coords = { x: '123456789', y: '987654321' };

        // Add the planet to the player's planets
        window._gameState.playerPlanets[planetId] = {
          owner: window.ethereum.selectedAddress,
          coords,
          resources: {
            silver: 1000,
            energy: 2000,
          },
        };

        // Create a proof for mining resources
        const miningProof = {
          a: [
            '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef',
            '0xfedcba0987654321fedcba0987654321fedcba0987654321fedcba0987654321',
          ],
          b: [
            [
              '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef',
              '0xfedcba0987654321fedcba0987654321fedcba0987654321fedcba0987654321',
            ],
            [
              '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef',
              '0xfedcba0987654321fedcba0987654321fedcba0987654321fedcba0987654321',
            ],
          ],
          c: [
            '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef',
            '0xfedcba0987654321fedcba0987654321fedcba0987654321fedcba0987654321',
          ],
          publicSignals: [
            planetId,
            '1000', // Amount to mine
            window.ethereum.selectedAddress,
          ],
        };

        // Function to check if resources were removed during mining process
        // In a vulnerable contract, resources might not be removed until the transaction is mined
        function checkResourcesRemovedBeforeConfirmation(planetId, amount) {
          const planet = window._gameState.playerPlanets[planetId];
          // In a secure implementation, this should be updated immediately to prevent double spending
          return planet.resources.silver < 1000;
        }

        // Track mining attempts
        const miningAttempts = [];

        // First mining attempt
        const firstMining = window.makeMove('MINE', miningProof, {
          planetId,
          amount: 1000,
        });
        miningAttempts.push(firstMining);

        // Check if resources are reduced before confirmation (to prevent reentrancy)
        const resourcesRemovedImmediately = checkResourcesRemovedBeforeConfirmation(planetId, 1000);

        // Try to mine again before the first transaction is confirmed (reentrancy attack)
        const secondMining = window.makeMove('MINE', miningProof, {
          planetId,
          amount: 1000,
        });
        miningAttempts.push(secondMining);

        // Check if the second attempt was accepted
        const reentrancyPossible =
          secondMining.success &&
          !resourcesRemovedImmediately &&
          Object.keys(window._gameState.pendingMoves).length >= 2;

        // Record vulnerability if reentrancy is possible
        if (reentrancyPossible) {
          window.recordVulnerability({
            type: 'REENTRANCY_VULNERABILITY',
            subType: 'Double Mining',
            severity: 'HIGH',
            description:
              'Game allows multiple mining operations before previous ones are confirmed',
            details: {
              planetId,
              resourcesRemovedImmediately,
              miningAttempts,
            },
            impact: 'Players could extract more resources than actually available on a planet',
          });

          return {
            isVulnerable: true,
            reentrancyPossible,
            resourcesRemovedImmediately,
          };
        }

        return {
          isVulnerable: false,
          reentrancyPossible,
          resourcesRemovedImmediately,
        };
      })
      .then(result => {
        // Log the result
        console.log('Game Reentrancy Test:', JSON.stringify(result, null, 2));

        // Verify findings
        if (result.isVulnerable) {
          expect(result.reentrancyPossible).toBe(true);
          expect(result.resourcesRemovedImmediately).toBe(false);
        }
      });

    // Get vulnerability report
    const report = await page.evaluate(() => window.getVulnerabilityReport());
    console.log('Reentrancy Vulnerability Report:', JSON.stringify(report, null, 2));
  });

  test('should detect ZK circuit implementation vulnerabilities', async ({ page }) => {
    // Test for weak circuit implementations that allow illegal game moves
    await page
      .evaluate(() => {
        // Original coordinates and planet
        const coords = { x: '123456789', y: '987654321' };
        const planetId =
          '0x' +
          Array(64)
            .fill(0)
            .map(() => Math.floor(Math.random() * 16).toString(16))
            .join('');

        // Create a planet that's supposed to be too far to move to
        const farCoords = { x: '999999999', y: '999999999' };
        const farPlanetId =
          '0x' +
          Array(64)
            .fill(0)
            .map(() => Math.floor(Math.random() * 16).toString(16))
            .join('');

        // Add source planet to player's planets
        window._gameState.playerPlanets[planetId] = {
          owner: window.ethereum.selectedAddress,
          coords,
          resources: {
            silver: 1000,
            energy: 2000,
          },
        };

        // Create a valid proof for move
        const moveProof = {
          a: [
            '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef',
            '0xfedcba0987654321fedcba0987654321fedcba0987654321fedcba0987654321',
          ],
          b: [
            [
              '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef',
              '0xfedcba0987654321fedcba0987654321fedcba0987654321fedcba0987654321',
            ],
            [
              '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef',
              '0xfedcba0987654321fedcba0987654321fedcba0987654321fedcba0987654321',
            ],
          ],
          c: [
            '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef',
            '0xfedcba0987654321fedcba0987654321fedcba0987654321fedcba0987654321',
          ],
          publicSignals: [
            planetId, // From planet
            farPlanetId, // To planet
            '1000', // Energy used
            window.ethereum.selectedAddress,
          ],
        };

        // Function to check if move distance constraints are properly verified
        function checkMoveDistanceConstraints(fromCoords, toCoords, proof) {
          // Calculate distance between planets (simplified Euclidean distance)
          const dx = Number(toCoords.x) - Number(fromCoords.x);
          const dy = Number(toCoords.y) - Number(fromCoords.y);
          const distance = Math.sqrt(dx * dx + dy * dy);

          // In a properly implemented game, there should be a maximum allowed move distance
          // and the ZK circuit should verify this constraint
          const maxAllowedDistance = 50000;

          // Check if the distance exceeds max allowed (this would be part of ZK circuit)
          return distance <= maxAllowedDistance;
        }

        // Attempt the move that should be impossible (too far)
        const moveAttempt = window.makeMove('MOVE', moveProof, {
          fromPlanetId: planetId,
          toPlanetId: farPlanetId,
          fromCoords: coords,
          toCoords: farCoords,
          energy: 1000,
        });

        // Check if move distance constraints are properly enforced
        const distanceConstraintEnforced = checkMoveDistanceConstraints(
          coords,
          farCoords,
          moveProof
        );
        const moveAccepted = moveAttempt.success && !distanceConstraintEnforced;

        // Record vulnerability if illegal move is accepted
        if (moveAccepted) {
          window.recordVulnerability({
            type: 'ZK_CIRCUIT_VULNERABILITY',
            subType: 'Missing Distance Constraint',
            severity: 'CRITICAL',
            description: 'ZK circuit does not properly enforce movement distance constraints',
            details: {
              fromPlanet: planetId,
              toPlanet: farPlanetId,
              distance: Math.sqrt(
                Math.pow(Number(farCoords.x) - Number(coords.x), 2) +
                  Math.pow(Number(farCoords.y) - Number(coords.y), 2)
              ),
              moveAccepted,
            },
            impact:
              'Players could move to any planet regardless of distance, breaking game mechanics',
          });

          return {
            isVulnerable: true,
            moveAccepted,
            distanceConstraintEnforced,
          };
        }

        return {
          isVulnerable: false,
          moveAccepted,
          distanceConstraintEnforced,
        };
      })
      .then(result => {
        // Log the result
        console.log('ZK Circuit Implementation Test:', JSON.stringify(result, null, 2));

        // Verify findings
        if (result.isVulnerable) {
          expect(result.moveAccepted).toBe(true);
          expect(result.distanceConstraintEnforced).toBe(false);
        }
      });

    // Get vulnerability report
    const report = await page.evaluate(() => window.getVulnerabilityReport());
    console.log('ZK Circuit Vulnerability Report:', JSON.stringify(report, null, 2));
  });
});
