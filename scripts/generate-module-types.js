#!/usr/bin/env node

/**
 * Module Type Generator
 *
 * This script generates TypeScript declaration files for JavaScript modules
 * to improve type support when importing these modules in TypeScript files.
 */

const fs = require('fs');
const path = require('path');
const util = require('util');
const readFile = util.promisify(fs.readFile);
const writeFile = util.promisify(fs.writeFile);
const exec = util.promisify(require('child_process').exec);

// Configuration
const CONFIG = {
  filePatterns: ['utils/walletconnect-provider.js', 'utils/coinbase-provider.js'],
  outputDir: 'utils',
};

/**
 * Generate a TypeScript declaration file for a JavaScript module
 * @param {string} filePath - Path to the JavaScript file
 */
async function generateDeclarationFile(filePath) {
  try {
    console.log(`Generating declaration file for ${filePath}...`);

    // Read the source file
    const source = await readFile(filePath, 'utf8');

    // Determine the output path
    const outputPath = path.join(path.dirname(filePath), path.basename(filePath, '.js') + '.d.ts');

    // Extract class and export names
    const classMatches = source.match(/class\s+(\w+)/g) || [];
    const classNames = classMatches.map(match => match.replace('class ', ''));

    // Build declaration content
    let declaration = '/**\n';
    declaration += ' * TypeScript declaration for ' + path.basename(filePath) + '\n';
    declaration += ' * Auto-generated by generate-module-types.js\n';
    declaration += ' */\n\n';

    // Add class declarations
    for (const className of classNames) {
      declaration += `declare class ${className} {\n`;
      declaration += '  constructor(options?: any);\n';

      // Common methods based on source inspection
      if (source.includes(`${className}.prototype.init`) || source.includes('async init(')) {
        declaration += '  init(): Promise<this>;\n';
      }

      if (source.includes(`${className}.prototype.request`) || source.includes('async request(')) {
        declaration += '  request(args: { method: string; params?: any[] }): Promise<any>;\n';
      }

      if (source.includes(`${className}.prototype.on`) || source.includes('on(')) {
        declaration += '  on(eventName: string, listener: (...args: any[]) => void): void;\n';
      }

      if (
        source.includes(`${className}.prototype.removeListener`) ||
        source.includes('removeListener(')
      ) {
        declaration +=
          '  removeListener(eventName: string, listener: (...args: any[]) => void): void;\n';
      }

      if (
        source.includes(`${className}.prototype.disconnect`) ||
        source.includes('async disconnect(')
      ) {
        declaration += '  disconnect(): Promise<boolean>;\n';
      }

      if (
        source.includes(`${className}.prototype.captureState`) ||
        source.includes('captureState(')
      ) {
        declaration += '  captureState(): any;\n';
      }

      if (
        source.includes(`${className}.prototype.restoreState`) ||
        source.includes('restoreState(')
      ) {
        declaration += '  restoreState(state: any): boolean;\n';
      }

      if (
        source.includes(`${className}.prototype.simulateConnection`) ||
        source.includes('async simulateConnection(')
      ) {
        declaration += '  simulateConnection(): Promise<boolean>;\n';
      }

      if (
        source.includes(`${className}.prototype.updateChainId`) ||
        source.includes('async updateChainId(')
      ) {
        declaration += '  updateChainId(chainId: string): Promise<boolean>;\n';
      }

      declaration += '}\n\n';
    }

    // Add export statements
    declaration += 'export {\n';
    for (const className of classNames) {
      declaration += `  ${className},\n`;
    }
    declaration += '};\n';

    // Write the declaration file
    await writeFile(outputPath, declaration);
    console.log(`Created ${outputPath}`);

    return outputPath;
  } catch (error) {
    console.error(`Error generating declaration for ${filePath}:`, error);
    return null;
  }
}

/**
 * Main function to process all files
 */
async function main() {
  try {
    console.log('Generating TypeScript declaration files...');

    let generatedCount = 0;

    for (const pattern of CONFIG.filePatterns) {
      const files = fs
        .readdirSync(path.dirname(pattern))
        .filter(file => file.endsWith('.js') && file.includes(path.basename(pattern, '.js')))
        .map(file => path.join(path.dirname(pattern), file));

      for (const file of files) {
        const result = await generateDeclarationFile(file);
        if (result) generatedCount++;
      }
    }

    console.log(`Successfully generated ${generatedCount} declaration files.`);
  } catch (error) {
    console.error('Error:', error);
    process.exit(1);
  }
}

// Run the script
main();
