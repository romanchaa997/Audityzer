// Security Test Suite - Generated by Audityzer
import { test, expect, Page } from '@playwright/test';

test.describe('Web3 Security Test Suite', () => {
  let page: Page;
  
  // Test configuration
  const config = {
    dappUrl: '{{dapp_url}}',
    walletAddress: '{{address}}',
    connectButtonSelector: '{{connect_button_selector}}',
    walletInfoSelector: '{{wallet_info_selector}}',
    walletAddressSelector: '{{wallet_address_selector}}',
    withdrawButtonSelector: '{{withdraw_button_selector}}',
    transferButtonSelector: '{{transfer_button_selector}}',
    signButtonSelector: '{{sign_button_selector}}',
    transactionStatusSelector: '{{transaction_status_selector}}',
    errorMessageSelector: '{{error_message_selector}}'
  };
  
  test.beforeEach(async ({ browser }) => {
    // Launch Metamask extension
    const context = await browser.newContext();
    page = await context.newPage();
    
    // Navigate to the dApp
    await page.goto(config.dappUrl);
    console.log(`Navigated to ${config.dappUrl}`);
    
    // Mock the ethereum provider and web3 connection
    await page.addInitScript(() => {
      interface EthereumProvider {
        isMetaMask: boolean;
        selectedAddress: string;
        chainId: string;
        networkVersion: string;
        request: (args: {method: string; params?: any[]}) => Promise<any>;
        on: (eventName: string, callback: (arg?: any) => void) => void;
      }
      
      interface Web3 {
        eth: {
          defaultAccount: string;
          accounts: string[];
          getAccounts: () => Promise<string[]>;
          net: {
            getId: () => Promise<number>;
          };
        };
      }
      
      // Add types to window
      declare global {
        interface Window {
          ethereum: EthereumProvider;
          web3: Web3;
          callInProgress?: boolean;
          reentryAttempts?: number;
          triggerReentrancy?: boolean;
          signatures?: Record<string, { signature: string; timestamp: number }>;
          malleableSignature?: string;
          errorLog?: {
            injected: number;
            handled: number;
            unhandled: number;
          };
        }
      }
      
      // Mock ethereum provider
      window.ethereum = {
        isMetaMask: true,
        selectedAddress: '{{address}}',
        chainId: '{{chain_id}}',
        networkVersion: '1',
        
        // Mock request method for ethereum interactions
        request: async ({ method, params }) => {
          console.log(`[Mock] Ethereum method called: ${method}`);
          
          if (method === 'eth_requestAccounts') {
            return ['{{address}}'];
          }
          
          if (method === 'eth_accounts') {
            return ['{{address}}'];
          }
          
          if (method === 'eth_chainId') {
            return '{{chain_id}}';
          }
          
          if (method === 'personal_sign') {
            return '0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890';
          }
          
          if (method === 'eth_sendTransaction') {
            console.log('[Mock] Transaction params:', params);
            return '{{transaction_hash}}';
          }
          
          return null;
        },
        
        // Event listeners
        on: (eventName, callback) => {
          console.log(`[Mock] Registered event listener for ${eventName}`);
        }
      };
      
      // Mock the window.web3 object if used by the app
      window.web3 = {
        eth: {
          defaultAccount: '{{address}}',
          accounts: ['{{address}}'],
          getAccounts: () => Promise.resolve(['{{address}}']),
          net: {
            getId: () => Promise.resolve(1)
          }
        }
      };
      
      console.log('[Mock] Ethereum provider and web3 initialized');
    });
  });
  
  test('Run reentrancy attack test', async () => {
    // Test for reentrancy vulnerabilities
    console.log('Starting reentrancy attack test');
    
    try {
      // Set up reentrancy attack monitoring
      await page.evaluate(() => {
        // Track function call state for reentrancy detection
        window.callInProgress = false;
        window.reentryAttempts = 0;
        
        // Intercept contract calls to detect reentrancy
        const originalRequest = window.ethereum.request;
        window.ethereum.request = async function(args) {
          if (args.method === 'eth_sendTransaction') {
            if (window.callInProgress) {
              window.reentryAttempts = (window.reentryAttempts || 0) + 1;
              console.log(`[VULNERABILITY] Reentrancy attempt detected! Count: ${window.reentryAttempts}`);
              document.body.innerHTML += `<div style="color:red; background:black; padding:10px; position:fixed; top:0; left:0; z-index:9999">
                REENTRANCY VULNERABILITY DETECTED
              </div>`;
            }
            
            window.callInProgress = true;
            const result = await originalRequest.call(this, args);
            
            // In vulnerable code, state would be updated after the call
            // Simulate a callback from the contract that could trigger reentrancy
            if (window.triggerReentrancy) {
              console.log('[Attack] Attempting to trigger reentrancy via callback');
              const vulnerableFunction = document.querySelector('{{withdraw_button_selector}}');
              if (vulnerableFunction && vulnerableFunction instanceof HTMLElement) {
                vulnerableFunction.click();
              }
            }
            
            window.callInProgress = false;
            return result;
          }
          
          return originalRequest.call(this, args);
        };
        
        window.triggerReentrancy = true;
      });
      
      // Find and click the withdraw button to test for reentrancy
      const withdrawButton = page.locator('{{withdraw_button_selector}}');
      if (await withdrawButton.isVisible()) {
        await withdrawButton.click();
        console.log('Clicked withdraw button to test for reentrancy');
        
        // Check if reentrancy was detected
        const reentryCount = await page.evaluate(() => window.reentryAttempts || 0);
        if (reentryCount > 0) {
          console.log(`[CRITICAL] Reentrancy vulnerability detected with ${reentryCount} reentry attempts`);
          await page.screenshot({ path: 'media/reentrancy-vulnerability-detected.png' });
        } else {
          console.log('No reentrancy vulnerability detected in this test');
        }
      } else {
        console.log('Withdraw button not found. Skipping reentrancy test.');
      }
    } catch (error) {
      console.error(`Error during reentrancy test: ${error}`);
      await page.screenshot({ path: 'media/reentrancy-test-error.png' });
    }
  });
  
  test('Run signature spoofing test', async () => {
    // Test for signature spoofing vulnerabilities
    console.log('Starting signature spoofing test');
    
    try {
      // Set up signature monitoring
      await page.evaluate(() => {
        // Track signatures to test for replay attacks
        window.signatures = {};
        
        // Intercept signing requests
        const originalRequest = window.ethereum.request;
        window.ethereum.request = async function(args) {
          if (args.method === 'personal_sign' || 
              args.method === 'eth_sign' || 
              args.method.startsWith('eth_signTypedData')) {
            
            const messageId = JSON.stringify(args.params);
            
            // Check for replay attacks
            if (window.signatures && window.signatures[messageId]) {
              console.log(`[VULNERABILITY] Signature replay attempt detected!`);
              console.log(`Original signature: ${window.signatures[messageId].signature}`);
              document.body.innerHTML += `<div style="color:red; background:black; padding:10px; position:fixed; top:0; left:0; z-index:9999">
                SIGNATURE REPLAY VULNERABILITY DETECTED
              </div>`;
              
              // Return the same signature as before
              return window.signatures[messageId].signature;
            }
            
            // Generate and store the signature
            const result = await originalRequest.call(this, args);
            
            // Initialize signatures object if it doesn't exist
            if (!window.signatures) {
              window.signatures = {};
            }
            
            window.signatures[messageId] = {
              signature: result,
              timestamp: Date.now()
            };
            
            // Test for malleable signatures (signature with different bytes but same meaning)
            if (args.method === 'personal_sign') {
              // Create a malleable signature version (modify the v value)
              window.malleableSignature = result.slice(0, -2) + 
                (parseInt(result.slice(-2), 16) ^ 1).toString(16).padStart(2, '0');
              console.log(`Original signature: ${result}`);
              console.log(`Malleable variant: ${window.malleableSignature}`);
            }
            
            return result;
          }
          
          return originalRequest.call(this, args);
        };
      });
      
      // Find and click the sign button to test for signature vulnerabilities
      const signButton = page.locator('{{sign_button_selector}}');
      if (await signButton.isVisible()) {
        await signButton.click();
        console.log('Clicked sign button to generate a signature');
        
        // Attempt a replay attack by clicking the execute button again
        const executeButton = page.locator('button:has-text("Execute")');
        if (await executeButton.isVisible()) {
          await executeButton.click();
          console.log('Clicked execute button to test for signature replay');
          
          // Check if replay was detected
          const replayDetected = await page.evaluate(() => 
            document.body.innerText.includes('SIGNATURE REPLAY VULNERABILITY DETECTED')
          );
          
          if (replayDetected) {
            console.log('[CRITICAL] Signature replay vulnerability detected');
            await page.screenshot({ path: 'media/signature-replay-detected.png' });
          } else {
            console.log('No signature replay vulnerability detected in this test');
          }
        } else {
          console.log('Execute button not found. Skipping signature replay test.');
        }
      } else {
        console.log('Sign button not found. Skipping signature vulnerability test.');
      }
    } catch (error) {
      console.error(`Error during signature spoofing test: ${error}`);
      await page.screenshot({ path: 'media/signature-test-error.png' });
    }
  });
  
  test('Run provider error handling test', async () => {
    // Test for unhandled provider errors
    console.log('Starting provider error handling test');
    
    try {
      // Set up error injection and monitoring
      await page.evaluate(() => {
        // Track error handling
        window.errorLog = {
          injected: 0,
          handled: 0,
          unhandled: 0
        };
        
        interface ProviderError {
          code: number;
          message: string;
        }
        
        // Common Ethereum provider errors
        const PROVIDER_ERRORS: Record<string, ProviderError> = {
          USER_REJECTED: { code: 4001, message: 'User rejected the request.' },
          UNAUTHORIZED: { code: 4100, message: 'The requested method and/or account has not been authorized.' },
          UNSUPPORTED_METHOD: { code: 4200, message: 'The Provider does not support the requested method.' },
          DISCONNECTED: { code: 4900, message: 'The Provider is disconnected from all chains.' },
          CHAIN_DISCONNECTED: { code: 4901, message: 'The Provider is not connected to the requested chain.' },
          RESOURCE_UNAVAILABLE: { code: -32002, message: 'Resource unavailable, request already pending' }
        };
        
        // Intercept and inject errors
        const originalRequest = window.ethereum.request;
        window.ethereum.request = async function(args) {
          // Skip error injection for some calls to allow basic functionality
          if (args.method === 'eth_chainId' || args.method === 'eth_accounts') {
            return originalRequest.call(this, args);
          }
          
          // Get random error type for injection
          const errorTypes = Object.keys(PROVIDER_ERRORS);
          const randomErrorType = errorTypes[Math.floor(Math.random() * errorTypes.length)];
          const errorToInject = PROVIDER_ERRORS[randomErrorType];
          
          console.log(`[Test] Injecting error for ${args.method}: ${errorToInject.message} (${errorToInject.code})`);
          window.errorLog!.injected++;
          
          // Create the error
          const error = new Error(errorToInject.message);
          (error as any).code = errorToInject.code;
          
          // Check for error handlers by hijacking the console.error
          const originalConsoleError = console.error;
          let errorHandled = false;
          
          console.error = function(...args) {
            errorHandled = true;
            originalConsoleError.apply(console, args);
          };
          
          // Throw the error
          try {
            throw error;
          } catch (err) {
            // Check if the UI reflects the error after a short delay
            setTimeout(() => {
              const errorDisplayed = document.querySelector('{{error_message_selector}}');
              if (errorDisplayed && errorDisplayed.textContent && errorDisplayed.textContent.length > 0) {
                window.errorLog!.handled++;
                console.log(`[Test] Error was handled in UI: ${errorDisplayed.textContent}`);
              } else if (errorHandled) {
                window.errorLog!.handled++;
                console.log(`[Test] Error was logged but not displayed in UI`);
              } else {
                window.errorLog!.unhandled++;
                console.log(`[VULNERABILITY] Unhandled provider error detected!`);
                document.body.innerHTML += `<div style="color:red; background:black; padding:10px; position:fixed; top:0; left:0; z-index:9999">
                  UNHANDLED PROVIDER ERROR: ${(err as Error).message} (${(err as any).code})
                </div>`;
              }
            }, 1000);
            
            // Restore original console.error
            console.error = originalConsoleError;
            throw err;
          }
        };
      });
      
      // Test various user interactions to see how errors are handled
      const buttons = [
        '{{connect_button_selector}}',
        '{{withdraw_button_selector}}',
        '{{transfer_button_selector}}',
        '{{sign_button_selector}}'
      ];
      
      for (const buttonSelector of buttons) {
        const button = page.locator(buttonSelector);
        if (await button.isVisible()) {
          try {
            await button.click();
            console.log(`Clicked ${buttonSelector} to test error handling`);
            
            // Wait for error handling check
            await page.waitForTimeout(1500);
          } catch (error) {
            console.log(`Error clicking ${buttonSelector}: ${(error as Error).message}`);
          }
        }
      }
      
      // Check final error handling stats
      const errorStats = await page.evaluate(() => window.errorLog);
      console.log(`Error handling statistics: ${JSON.stringify(errorStats)}`);
      
      if (errorStats && errorStats.unhandled > 0) {
        console.log(`[CRITICAL] ${errorStats.unhandled} unhandled provider errors detected`);
        await page.screenshot({ path: 'media/unhandled-provider-errors.png' });
      } else if (errorStats && errorStats.injected > 0) {
        console.log(`All ${errorStats.injected} provider errors were properly handled`);
      }
    } catch (error) {
      console.error(`Error during provider error test: ${error}`);
      await page.screenshot({ path: 'media/provider-error-test-error.png' });
    }
  });
}); 