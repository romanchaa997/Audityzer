/**
 * Vulnerability Library
 *
 * A comprehensive reference library of common web3 security vulnerabilities,
 * including descriptions, examples, detection methods, and mitigation strategies.
 */

const fs = require('fs-extra');
const path = require('path');

// Common vulnerability categories
const VULNERABILITY_CATEGORIES = {
  SMART_CONTRACT: 'smart_contract',
  BLOCKCHAIN: 'blockchain',
  WEB3_INTEGRATION: 'web3_integration',
  WALLET: 'wallet',
  DEFI: 'defi',
  NFT: 'nft',
  GOVERNANCE: 'governance',
  CROSS_CHAIN: 'cross_chain',
};

class VulnerabilityLibrary {
  /**
   * Create a new Vulnerability Library
   * @param {Object} config - Configuration options
   */
  constructor(config = {}) {
    this.config = {
      libraryDir:
        config.libraryDir ||
        path.join(process.cwd(), 'src', 'core', 'education', 'vulnerability-library'),
      examplesDir:
        config.examplesDir ||
        path.join(process.cwd(), 'src', 'core', 'education', 'vulnerability-examples'),
      defaultLanguage: config.defaultLanguage || 'en',
      ...config,
    };

    // Create necessary directories
    fs.ensureDirSync(this.config.libraryDir);
    fs.ensureDirSync(this.config.examplesDir);

    // Load vulnerability data
    this.vulnerabilities = this._loadVulnerabilities();
    this.categories = this._loadCategories();
  }

  /**
   * Load all vulnerability data
   * @returns {Object} Map of vulnerability IDs to vulnerability data
   * @private
   */
  _loadVulnerabilities() {
    const vulnerabilities = {};

    try {
      // Get index file
      const indexPath = path.join(this.config.libraryDir, 'index.json');

      if (fs.existsSync(indexPath)) {
        const index = fs.readJsonSync(indexPath);

        // Load vulnerabilities specified in the index
        if (index.vulnerabilities && Array.isArray(index.vulnerabilities)) {
          for (const vulnId of index.vulnerabilities) {
            const vulnPath = path.join(this.config.libraryDir, `${vulnId}.json`);

            if (fs.existsSync(vulnPath)) {
              try {
                const vulnerability = fs.readJsonSync(vulnPath);
                vulnerabilities[vulnId] = vulnerability;
              } catch (err) {
                console.error(`Error loading vulnerability ${vulnId}:`, err);
              }
            }
          }
        }
      } else {
        // Fallback to loading all JSON files in the directory
        const files = fs.readdirSync(this.config.libraryDir);

        for (const file of files) {
          if (file.endsWith('.json') && file !== 'index.json' && file !== 'categories.json') {
            try {
              const vulnPath = path.join(this.config.libraryDir, file);
              const vulnerability = fs.readJsonSync(vulnPath);
              const vulnId = file.replace('.json', '');

              vulnerabilities[vulnId] = vulnerability;
            } catch (err) {
              console.error(`Error loading vulnerability ${file}:`, err);
            }
          }
        }
      }
    } catch (err) {
      console.error('Error loading vulnerabilities:', err);
    }

    return vulnerabilities;
  }

  /**
   * Load category data
   * @returns {Object} Category data
   * @private
   */
  _loadCategories() {
    try {
      const categoriesPath = path.join(this.config.libraryDir, 'categories.json');

      if (fs.existsSync(categoriesPath)) {
        return fs.readJsonSync(categoriesPath);
      }
    } catch (err) {
      console.error('Error loading categories:', err);
    }

    // Default categories
    return {
      categories: Object.values(VULNERABILITY_CATEGORIES).map(id => ({
        id,
        name: id
          .split('_')
          .map(word => word.charAt(0).toUpperCase() + word.slice(1))
          .join(' '),
        description: `Vulnerabilities related to ${id.split('_').join(' ')}`,
      })),
    };
  }

  /**
   * Get all vulnerability categories
   * @param {string} language - Language to get categories in
   * @returns {Array} List of categories
   */
  getCategories(language = null) {
    const lang = language || this.config.defaultLanguage;

    // Return localized categories if available
    if (this.categories.localization?.[lang]?.categories) {
      return this.categories.localization[lang].categories;
    }

    return this.categories.categories;
  }

  /**
   * Get all vulnerabilities
   * @param {string} language - Language to get vulnerabilities in
   * @returns {Array} List of vulnerabilities
   */
  getAllVulnerabilities(language = null) {
    const lang = language || this.config.defaultLanguage;

    return Object.values(this.vulnerabilities).map(vuln => {
      // Get localized content if available
      const title = vuln.localization?.[lang]?.title || vuln.title;
      const summary = vuln.localization?.[lang]?.summary || vuln.summary;

      return {
        id: vuln.id,
        title,
        summary,
        category: vuln.category,
        severity: vuln.severity,
        cwe: vuln.cwe,
        tags: vuln.tags,
      };
    });
  }

  /**
   * Get vulnerabilities by category
   * @param {string} categoryId - Category ID
   * @param {string} language - Language to get vulnerabilities in
   * @returns {Array} List of vulnerabilities in the category
   */
  getVulnerabilitiesByCategory(categoryId, language = null) {
    const lang = language || this.config.defaultLanguage;

    return this.getAllVulnerabilities(lang).filter(vuln => vuln.category === categoryId);
  }

  /**
   * Get a specific vulnerability
   * @param {string} vulnId - Vulnerability ID
   * @param {string} language - Language to get vulnerability in
   * @returns {Object} Vulnerability data
   */
  getVulnerability(vulnId, language = null) {
    const vulnerability = this.vulnerabilities[vulnId];

    if (!vulnerability) {
      throw new Error(`Vulnerability with ID ${vulnId} not found`);
    }

    // Get localized content if available
    const lang = language || this.config.defaultLanguage;

    if (vulnerability.localization?.[lang]) {
      // Apply localized content
      return {
        ...vulnerability,
        title: vulnerability.localization[lang].title || vulnerability.title,
        summary: vulnerability.localization[lang].summary || vulnerability.summary,
        description: vulnerability.localization[lang].description || vulnerability.description,
        impact: vulnerability.localization[lang].impact || vulnerability.impact,
        mitigation: vulnerability.localization[lang].mitigation || vulnerability.mitigation,
        examples: vulnerability.localization[lang].examples || vulnerability.examples,
      };
    }

    return vulnerability;
  }

  /**
   * Search vulnerabilities
   * @param {string} query - Search query
   * @param {Object} filters - Additional filters
   * @param {string} language - Language to search in
   * @returns {Array} Search results
   */
  searchVulnerabilities(query, filters = {}, language = null) {
    const lang = language || this.config.defaultLanguage;
    const searchQuery = query.toLowerCase();

    // Get all vulnerabilities
    let results = this.getAllVulnerabilities(lang);

    // Apply search query
    if (searchQuery) {
      results = results.filter(
        vuln =>
          vuln.title.toLowerCase().includes(searchQuery) ||
          vuln.summary.toLowerCase().includes(searchQuery) ||
          (vuln.tags && vuln.tags.some(tag => tag.toLowerCase().includes(searchQuery)))
      );
    }

    // Apply category filter
    if (filters.category) {
      results = results.filter(vuln => vuln.category === filters.category);
    }

    // Apply severity filter
    if (filters.severity) {
      results = results.filter(vuln => vuln.severity === filters.severity);
    }

    // Apply tags filter
    if (filters.tags && Array.isArray(filters.tags) && filters.tags.length > 0) {
      results = results.filter(
        vuln => vuln.tags && filters.tags.some(tag => vuln.tags.includes(tag))
      );
    }

    // Sort results
    results.sort((a, b) => {
      // Sort by relevance (title match first)
      const titleMatchA = a.title.toLowerCase().includes(searchQuery);
      const titleMatchB = b.title.toLowerCase().includes(searchQuery);

      if (titleMatchA && !titleMatchB) return -1;
      if (!titleMatchA && titleMatchB) return 1;

      // Then sort by severity
      const severityOrder = { critical: 0, high: 1, medium: 2, low: 3, informational: 4 };
      return severityOrder[a.severity] - severityOrder[b.severity];
    });

    return results;
  }

  /**
   * Get vulnerability examples
   * @param {string} vulnId - Vulnerability ID
   * @returns {Object} Examples data
   */
  getVulnerabilityExamples(vulnId) {
    const vulnerability = this.getVulnerability(vulnId);

    // Check if vulnerability has embedded examples
    if (vulnerability.examples && vulnerability.examples.length > 0) {
      return {
        vulnId,
        embedded: true,
        examples: vulnerability.examples,
      };
    }

    // Check for example files
    const examplesPath = path.join(this.config.examplesDir, `${vulnId}.json`);

    if (fs.existsSync(examplesPath)) {
      try {
        const examples = fs.readJsonSync(examplesPath);
        return {
          vulnId,
          embedded: false,
          examples: examples.examples || [],
        };
      } catch (err) {
        console.error(`Error loading examples for ${vulnId}:`, err);
      }
    }

    // No examples found
    return {
      vulnId,
      embedded: false,
      examples: [],
    };
  }

  /**
   * Get related vulnerabilities
   * @param {string} vulnId - Vulnerability ID
   * @param {number} limit - Maximum number of related vulnerabilities to return
   * @returns {Array} Related vulnerabilities
   */
  getRelatedVulnerabilities(vulnId, limit = 5) {
    const vulnerability = this.getVulnerability(vulnId);

    // Get vulnerabilities in the same category
    const sameCategory = this.getVulnerabilitiesByCategory(vulnerability.category).filter(
      v => v.id !== vulnId
    );

    // Get vulnerabilities with same tags
    const allVulns = this.getAllVulnerabilities();
    const sameTags = allVulns.filter(
      v =>
        v.id !== vulnId &&
        v.category !== vulnerability.category &&
        v.tags &&
        vulnerability.tags &&
        v.tags.some(tag => vulnerability.tags.includes(tag))
    );

    // Combine and limit results
    const combined = [...sameCategory, ...sameTags];
    const unique = Array.from(new Map(combined.map(v => [v.id, v])).values());

    return unique.slice(0, limit);
  }

  /**
   * Add a new vulnerability
   * @param {Object} vulnData - Vulnerability data
   * @returns {Object} Added vulnerability
   */
  addVulnerability(vulnData) {
    if (!vulnData.id) {
      throw new Error('Vulnerability ID is required');
    }

    if (!vulnData.title) {
      throw new Error('Vulnerability title is required');
    }

    if (!vulnData.category) {
      throw new Error('Vulnerability category is required');
    }

    // Create vulnerability object
    const vulnerability = {
      ...vulnData,
      added: new Date().toISOString(),
      updated: new Date().toISOString(),
    };

    // Save vulnerability
    const vulnPath = path.join(this.config.libraryDir, `${vulnerability.id}.json`);
    fs.writeJsonSync(vulnPath, vulnerability, { spaces: 2 });

    // Update internal cache
    this.vulnerabilities[vulnerability.id] = vulnerability;

    // Update index
    this._updateIndex();

    return vulnerability;
  }

  /**
   * Update an existing vulnerability
   * @param {string} vulnId - Vulnerability ID
   * @param {Object} updates - Updated fields
   * @returns {Object} Updated vulnerability
   */
  updateVulnerability(vulnId, updates) {
    const vulnerability = this.getVulnerability(vulnId);

    if (!vulnerability) {
      throw new Error(`Vulnerability with ID ${vulnId} not found`);
    }

    // Update fields
    const updatedVulnerability = {
      ...vulnerability,
      ...updates,
      updated: new Date().toISOString(),
    };

    // Save updated vulnerability
    const vulnPath = path.join(this.config.libraryDir, `${vulnId}.json`);
    fs.writeJsonSync(vulnPath, updatedVulnerability, { spaces: 2 });

    // Update internal cache
    this.vulnerabilities[vulnId] = updatedVulnerability;

    return updatedVulnerability;
  }

  /**
   * Add examples for a vulnerability
   * @param {string} vulnId - Vulnerability ID
   * @param {Array} examples - Examples to add
   * @returns {Object} Updated examples
   */
  addVulnerabilityExamples(vulnId, examples) {
    if (!Array.isArray(examples)) {
      throw new Error('Examples must be an array');
    }

    // Verify vulnerability exists
    this.getVulnerability(vulnId);

    // Get existing examples if any
    let existingExamples = [];
    const examplesPath = path.join(this.config.examplesDir, `${vulnId}.json`);

    if (fs.existsSync(examplesPath)) {
      try {
        const existing = fs.readJsonSync(examplesPath);
        existingExamples = existing.examples || [];
      } catch (err) {
        console.error(`Error loading existing examples for ${vulnId}:`, err);
      }
    }

    // Combine examples
    const combinedExamples = {
      vulnId,
      updated: new Date().toISOString(),
      examples: [...existingExamples, ...examples],
    };

    // Save examples
    fs.writeJsonSync(examplesPath, combinedExamples, { spaces: 2 });

    return combinedExamples;
  }

  /**
   * Update the library index
   * @private
   */
  _updateIndex() {
    const indexPath = path.join(this.config.libraryDir, 'index.json');

    const index = {
      lastUpdated: new Date().toISOString(),
      vulnerabilities: Object.keys(this.vulnerabilities),
    };

    fs.writeJsonSync(indexPath, index, { spaces: 2 });
  }

  /**
   * Export the entire vulnerability library
   * @returns {Object} Exported library data
   */
  exportLibrary() {
    return {
      metadata: {
        exported: new Date().toISOString(),
        version: '1.0',
        itemCount: Object.keys(this.vulnerabilities).length,
      },
      categories: this.categories,
      vulnerabilities: this.vulnerabilities,
    };
  }

  /**
   * Import a vulnerability library
   * @param {Object} libraryData - Library data to import
   * @param {boolean} overwrite - Whether to overwrite existing vulnerabilities
   * @returns {Object} Import results
   */
  importLibrary(libraryData, overwrite = false) {
    const results = {
      imported: 0,
      skipped: 0,
      errors: [],
    };

    // Import categories
    if (libraryData.categories) {
      try {
        this.categories = libraryData.categories;
        const categoriesPath = path.join(this.config.libraryDir, 'categories.json');
        fs.writeJsonSync(categoriesPath, libraryData.categories, { spaces: 2 });
      } catch (err) {
        results.errors.push(`Error importing categories: ${err.message}`);
      }
    }

    // Import vulnerabilities
    if (libraryData.vulnerabilities) {
      for (const [vulnId, vulnerability] of Object.entries(libraryData.vulnerabilities)) {
        try {
          if (this.vulnerabilities[vulnId] && !overwrite) {
            results.skipped++;
            continue;
          }

          const vulnPath = path.join(this.config.libraryDir, `${vulnId}.json`);
          fs.writeJsonSync(vulnPath, vulnerability, { spaces: 2 });

          this.vulnerabilities[vulnId] = vulnerability;
          results.imported++;
        } catch (err) {
          results.errors.push(`Error importing vulnerability ${vulnId}: ${err.message}`);
        }
      }

      // Update index
      this._updateIndex();
    }

    return results;
  }
}

module.exports = {
  VulnerabilityLibrary,
  VULNERABILITY_CATEGORIES,
};
