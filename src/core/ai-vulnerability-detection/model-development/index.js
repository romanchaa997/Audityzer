/**
 * Phase 2: Model Development
 *
 * This module handles the development, training, and evaluation of
 * machine learning models for vulnerability detection.
 */

const fs = require('fs-extra');
const path = require('path');
const crypto = require('crypto');
const VulnerabilityClassifier = require('./vulnerability-classifier');

// Default model configurations
const DEFAULT_MODELS = [
  {
    id: 'vuln-classifier-base',
    type: 'classifier',
    algorithm: 'randomForest',
    target: 'hasVulnerability',
    features: ['codeMetrics', 'patternMatches', 'semanticEmbeddings'],
    hyperparameters: {
      numTrees: 100,
      maxDepth: 15,
      minSamplesLeaf: 3,
    },
    testMetrics: {},
    createdAt: null,
    updatedAt: null,
    status: 'inactive',
  },
  {
    id: 'severity-classifier',
    type: 'classifier',
    algorithm: 'xgboost',
    target: 'severityLevel',
    features: ['codeMetrics', 'patternMatches', 'semanticEmbeddings', 'contractType'],
    hyperparameters: {
      numRounds: 100,
      maxDepth: 6,
      eta: 0.3,
      subsample: 0.8,
    },
    testMetrics: {},
    createdAt: null,
    updatedAt: null,
    status: 'inactive',
  },
  {
    id: 'vulnerability-type-classifier',
    type: 'multiClassifier',
    algorithm: 'neuralNetwork',
    target: 'vulnerabilityType',
    features: [
      'codeMetrics',
      'patternMatches',
      'semanticEmbeddings',
      'contractType',
      'codeStructure',
    ],
    hyperparameters: {
      hiddenLayers: [64, 32],
      activation: 'relu',
      dropout: 0.2,
      learningRate: 0.001,
    },
    testMetrics: {},
    createdAt: null,
    updatedAt: null,
    status: 'inactive',
  },
];

class ModelDevelopment {
  constructor (userConfig = {}) {
    // Default configuration
    this.config = {
      dataStoragePath: null,
      modelStoragePath: null,
      defaultDatasetId: null,
      activeModels: {},
      models: [...DEFAULT_MODELS],
      featureEngineeringConfig: {
        codeMetrics: {
          enabled: true,
          complexityThreshold: 10,
        },
        patternMatches: {
          enabled: true,
          patternSets: ['reentrancy', 'access-control', 'arithmetic'],
        },
        semanticEmbeddings: {
          enabled: true,
          embeddingModel: 'code-davinci-002',
        },
      },
      batchSize: 32,
      ...userConfig,
    };

    // Set model storage path
    this.config.modelStoragePath =
      userConfig.modelStoragePath ||
      path.join(userConfig.dataStoragePath || '', 'ml-models');

    // Merge feature engineering config
    this.config.featureEngineeringConfig = {
      ...this.config.featureEngineeringConfig,
      ...userConfig.featureEngineeringConfig,
    };

    // Track initialization state
    this.initialized = false;

    // Initialize if config provided
    if (Object.keys(userConfig).length > 0) {
      this.initialize(userConfig);
    }
  }

  /**
   * Initialize the model development system
   * @param {Object} userConfig - Configuration options
   * @returns {Promise<boolean>} Success status
   */
  async initialize(userConfig = {}) {
    try {
      // Merge user config with defaults
      this.config = {
        ...this.config,
        ...userConfig,
        modelStoragePath:
          userConfig.modelStoragePath || path.join(userConfig.dataStoragePath || '', 'ml-models'),
        featureEngineeringConfig: {
          ...this.config.featureEngineeringConfig,
          ...userConfig.featureEngineeringConfig,
        },
      };

      // Ensure model directories exist
      await fs.ensureDir(this.config.modelStoragePath);
      await fs.ensureDir(path.join(this.config.modelStoragePath, 'trained-models'));
      await fs.ensureDir(path.join(this.config.modelStoragePath, 'model-metadata'));

      // Load existing models if any
      await this.loadExistingModels();

      this.initialized = true;
      return true;
    } catch (error) {
      console.error('Failed to initialize model development:', error);
      return false;
    }
  }

  /**
   * Load existing models from storage
   * @private
   */
  async loadExistingModels() {
    try {
      const metadataDir = path.join(this.config.modelStoragePath, 'model-metadata');
      const metadataFiles = await fs.readdir(metadataDir);

      for (const file of metadataFiles) {
        if (file.endsWith('.json')) {
          const metadata = await fs.readJson(path.join(metadataDir, file));
          const existingIndex = this.config.models.findIndex(m => m.id === metadata.id);

          if (existingIndex >= 0) {
            this.config.models[existingIndex] = metadata;
          } else {
            this.config.models.push(metadata);
          }
        }
      }
    } catch (error) {
      // No existing models or error reading - continue with defaults
    }
  }

  /**
   * Train a machine learning model
   * @param {string} modelId - Model identifier
   * @param {Array} trainingData - Training dataset
   * @param {Object} options - Training options
   * @returns {Promise<Object>} Training results
   */
  async trainModel(modelId, trainingData, options = {}) {
    if (!this.initialized) {
      throw new Error('Model development system not initialized');
    }

    const model = this.config.models.find(m => m.id === modelId);
    if (!model) {
      throw new Error(`Model ${modelId} not found`);
    }

    try {
      // Prepare training data
      const preparedData = await this.prepareTrainingData(trainingData, model);

      // Train the model based on its type
      let trainedModel;
      switch (model.algorithm) {
        case 'randomForest':
          trainedModel = await this.trainRandomForest(model, preparedData, options);
          break;
        case 'xgboost':
          trainedModel = await this.trainXGBoost(model, preparedData, options);
          break;
        case 'neuralNetwork':
          trainedModel = await this.trainNeuralNetwork(model, preparedData, options);
          break;
        default:
          throw new Error(`Unsupported algorithm: ${model.algorithm}`);
      }

      // Evaluate the model
      const evaluation = await this.evaluateModel(trainedModel, preparedData.testSet);

      // Save the model
      const modelPath = await this.saveModel(modelId, trainedModel, evaluation);

      // Update model metadata
      model.testMetrics = evaluation;
      model.updatedAt = new Date().toISOString();
      model.status = 'trained';
      model.modelPath = modelPath;

      await this.saveModelMetadata(model);

      return {
        modelId,
        evaluation,
        modelPath,
        trainingTime: evaluation.trainingTime,
      };
    } catch (error) {
      console.error(`Failed to train model ${modelId}:`, error);
      throw error;
    }
  }

  /**
   * Prepare training data for model training
   * @param {Array} rawData - Raw training data
   * @param {Object} model - Model configuration
   * @returns {Promise<Object>} Prepared data
   * @private
   */
  async prepareTrainingData(rawData, model) {
    // Split data into training and test sets
    const shuffled = [...rawData].sort(() => Math.random() - 0.5);
    const splitIndex = Math.floor(shuffled.length * 0.8);

    const trainingSet = shuffled.slice(0, splitIndex);
    const testSet = shuffled.slice(splitIndex);

    return {
      trainingSet,
      testSet,
      features: model.features,
      target: model.target,
    };
  }

  /**
   * Train a Random Forest model
   * @param {Object} model - Model configuration
   * @param {Object} data - Prepared training data
   * @param {Object} options - Training options
   * @returns {Promise<Object>} Trained model
   * @private
   */
  async trainRandomForest(model, data, options) {
    // Mock implementation - in real scenario, use ML library
    const startTime = Date.now();

    // Simulate training time
    await new Promise(resolve => setTimeout(resolve, 100));

    const trainedModel = {
      id: model.id,
      algorithm: 'randomForest',
      hyperparameters: model.hyperparameters,
      features: data.features,
      target: data.target,
      trainingSize: data.trainingSet.length,
      trainedAt: new Date().toISOString(),
    };

    return trainedModel;
  }

  /**
   * Train an XGBoost model
   * @param {Object} model - Model configuration
   * @param {Object} data - Prepared training data
   * @param {Object} options - Training options
   * @returns {Promise<Object>} Trained model
   * @private
   */
  async trainXGBoost(model, data, options) {
    // Mock implementation
    const startTime = Date.now();

    await new Promise(resolve => setTimeout(resolve, 150));

    const trainedModel = {
      id: model.id,
      algorithm: 'xgboost',
      hyperparameters: model.hyperparameters,
      features: data.features,
      target: data.target,
      trainingSize: data.trainingSet.length,
      trainedAt: new Date().toISOString(),
    };

    return trainedModel;
  }

  /**
   * Train a Neural Network model
   * @param {Object} model - Model configuration
   * @param {Object} data - Prepared training data
   * @param {Object} options - Training options
   * @returns {Promise<Object>} Trained model
   * @private
   */
  async trainNeuralNetwork(model, data, options) {
    // Mock implementation
    const startTime = Date.now();

    await new Promise(resolve => setTimeout(resolve, 200));

    const trainedModel = {
      id: model.id,
      algorithm: 'neuralNetwork',
      hyperparameters: model.hyperparameters,
      features: data.features,
      target: data.target,
      trainingSize: data.trainingSet.length,
      trainedAt: new Date().toISOString(),
    };

    return trainedModel;
  }

  /**
   * Evaluate a trained model
   * @param {Object} model - Trained model
   * @param {Array} testData - Test dataset
   * @returns {Promise<Object>} Evaluation metrics
   * @private
   */
  async evaluateModel(model, testData) {
    // Mock evaluation - in real scenario, use actual predictions
    const evaluation = {
      accuracy: 0.85 + Math.random() * 0.1,
      precision: 0.82 + Math.random() * 0.1,
      recall: 0.88 + Math.random() * 0.1,
      f1Score: 0.85 + Math.random() * 0.1,
      testSize: testData.length,
      trainingTime: 100 + Math.random() * 200,
      evaluatedAt: new Date().toISOString(),
    };

    return evaluation;
  }

  /**
   * Save a trained model to storage
   * @param {string} modelId - Model identifier
   * @param {Object} model - Trained model
   * @param {Object} evaluation - Evaluation metrics
   * @returns {Promise<string>} Model file path
   * @private
   */
  async saveModel(modelId, model, evaluation) {
    const modelPath = path.join(
      this.config.modelStoragePath,
      'trained-models',
      `${modelId}-${Date.now()}.json`
    );

    const modelData = {
      ...model,
      evaluation,
      savedAt: new Date().toISOString(),
    };

    await fs.writeJson(modelPath, modelData, { spaces: 2 });
    return modelPath;
  }

  /**
   * Save model metadata
   * @param {Object} model - Model metadata
   * @returns {Promise<void>}
   * @private
   */
  async saveModelMetadata(model) {
    const metadataPath = path.join(
      this.config.modelStoragePath,
      'model-metadata',
      `${model.id}.json`
    );

    await fs.writeJson(metadataPath, model, { spaces: 2 });
  }

  /**
   * Analyze a smart contract using trained models
   * @param {Object} contract - Contract to analyze
   * @param {Object} options - Analysis options
   * @returns {Promise<Object>} Analysis results
   */
  async analyzeContract(contract, options = {}) {
    if (!this.initialized) {
      throw new Error('Model development system not initialized');
    }

    const results = {
      contractId: contract.id || crypto.randomBytes(8).toString('hex'),
      vulnerabilities: [],
      confidence: 0,
      analysisTime: 0,
      modelsUsed: [],
    };

    const startTime = Date.now();

    try {
      // Use active models for analysis
      const activeModels = Object.values(this.config.activeModels);

      for (const modelId of activeModels) {
        const model = this.config.models.find(m => m.id === modelId);
        if (model && model.status === 'trained') {
          const prediction = await this.predictWithModel(model, contract);
          results.vulnerabilities.push(...prediction.vulnerabilities);
          results.modelsUsed.push(modelId);
        }
      }

      // Calculate overall confidence
      if (results.vulnerabilities.length > 0) {
        results.confidence = results.vulnerabilities.reduce(
          (sum, vuln) => sum + vuln.confidence, 0
        ) / results.vulnerabilities.length;
      }

      results.analysisTime = Date.now() - startTime;
      return results;
    } catch (error) {
      console.error('Contract analysis failed:', error);
      throw error;
    }
  }

  /**
   * Make predictions using a specific model
   * @param {Object} model - Model to use
   * @param {Object} contract - Contract to analyze
   * @returns {Promise<Object>} Prediction results
   * @private
   */
  async predictWithModel(model, contract) {
    // Mock prediction - in real scenario, load and use actual model
    const vulnerabilities = [];

    // Simulate model prediction based on contract content
    if (contract.code && contract.code.includes('call')) {
      vulnerabilities.push({
        type: 'reentrancy',
        severity: 'high',
        confidence: 0.85 + Math.random() * 0.1,
        line: 1,
        description: 'Potential reentrancy vulnerability detected',
        modelId: model.id,
      });
    }

    return { vulnerabilities };
  }

  /**
   * Create a vulnerability classifier instance
   * @param {Object} options - Classifier options
   * @returns {VulnerabilityClassifier} Classifier instance
   */
  createClassifier(options = {}) {
    const classifierOptions = {
      modelStoragePath: this.config.modelStoragePath,
      featureEngineeringConfig: this.config.featureEngineeringConfig,
      ...options,
    };

    return new VulnerabilityClassifier(classifierOptions);
  }

  /**
   * Get current configuration
   * @returns {Object} Current configuration
   */
  getConfig() {
    return { ...this.config };
  }

  /**
   * Check if module is initialized
   * @returns {boolean} Initialization status
   */
  isInitialized() {
    return this.initialized;
  }

  /**
   * Get available models
   * @returns {Array} Available models
   */
  getModels() {
    return [...this.config.models];
  }

  /**
   * Get active models
   * @returns {Object} Active models
   */
  getActiveModels() {
    return { ...this.config.activeModels };
  }
}

module.exports = ModelDevelopment;