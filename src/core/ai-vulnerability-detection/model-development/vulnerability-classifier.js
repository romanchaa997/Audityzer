/**
 * Vulnerability Classification System
 *
 * This module provides automatic vulnerability classification
 * capabilities using pattern matching and ML techniques.
 */

const fs = require('fs-extra');
const path = require('path');

// Classification categories based on Web3 security taxonomy
const VULNERABILITY_CATEGORIES = {
  REENTRANCY: {
    patterns: ['reentrancy', 'reentrant', 'external call after state', 'call after transfer'],
    severity: 'high',
    description:
      'Functions that could be called repeatedly before the first invocation is finished',
    cwe: 'CWE-841',
  },
  ACCESS_CONTROL: {
    patterns: [
      'unauthorized access',
      'missing authorization',
      'privilege escalation',
      'missing access control',
    ],
    severity: 'high',
    description: 'Missing or improper authorization checks',
    cwe: 'CWE-284',
  },
  ARITHMETIC: {
    patterns: ['overflow', 'underflow', 'division by zero', 'integer overflow'],
    severity: 'medium',
    description: 'Arithmetic issues like overflow or division by zero',
    cwe: 'CWE-682',
  },
  FRONT_RUNNING: {
    patterns: ['front-running', 'transaction ordering', 'miner extractable value', 'MEV'],
    severity: 'medium',
    description: 'Vulnerabilities in transaction ordering that can be exploited',
    cwe: 'CWE-362',
  },
  FLASH_LOAN_ATTACK: {
    patterns: ['flash loan', 'price manipulation', 'oracle manipulation'],
    severity: 'high',
    description: 'Vulnerabilities related to flash loan price manipulation',
    custom: 'WEB3-FL-01',
  },
  UNINITIALIZED_STORAGE: {
    patterns: ['uninitialized', 'storage slot', 'uninitialized storage'],
    severity: 'medium',
    description: 'Uninitialized storage variables',
    cwe: 'CWE-824',
  },
  CROSS_CHAIN: {
    patterns: ['bridge', 'cross-chain', 'message passing', 'layerzero'],
    severity: 'critical',
    description: 'Issues with cross-chain message passing or token bridging',
    custom: 'WEB3-CC-01',
  },
};

class VulnerabilityClassifier {
  constructor(config = {}) {
    this.config = {
      modelPath: config.modelPath || './models/vulnerability-classifier',
      taxonomyPath: config.taxonomyPath || './data/vulnerability-taxonomy.json',
      confidenceThreshold: config.confidenceThreshold || 0.7,
      useML: config.useML !== undefined ? config.useML : true,
      ...config,
    };

    this.modelLoaded = false;
    this.taxonomy = VULNERABILITY_CATEGORIES;

    // Load custom taxonomy if available
    this.loadTaxonomy();
  }

  /**
   * Load custom vulnerability taxonomy if available
   */
  loadTaxonomy() {
    try {
      if (fs.existsSync(this.config.taxonomyPath)) {
        const customTaxonomy = JSON.parse(fs.readFileSync(this.config.taxonomyPath, 'utf8'));
        this.taxonomy = { ...this.taxonomy, ...customTaxonomy };
        console.log(
          `Loaded custom vulnerability taxonomy with ${Object.keys(customTaxonomy).length} categories`
        );
      }
    } catch (error) {
      console.warn(`Could not load custom taxonomy: ${error.message}`);
    }
  }

  /**
   * Classify a vulnerability based on its description and context
   * @param {Object} vulnerability - The vulnerability to classify
   * @returns {Object} - Classification results
   */
  classifyVulnerability(vulnerability) {
    // Extract relevant information
    const description = vulnerability.description || '';
    const code = vulnerability.code || '';
    const name = vulnerability.name || '';

    // Combine text for classification
    const textToClassify = `${name} ${description} ${code}`.toLowerCase();

    // Initial classification result
    const result = {
      original: vulnerability,
      matches: [],
      classification: null,
      confidence: 0,
      severity: null,
      cweId: null,
      patternMatched: null,
    };

    // Pattern-based classification
    for (const [category, metadata] of Object.entries(this.taxonomy)) {
      // Check if any patterns match
      const matchedPatterns = metadata.patterns.filter(pattern =>
        textToClassify.includes(pattern.toLowerCase())
      );

      if (matchedPatterns.length > 0) {
        // Calculate confidence based on number of matched patterns
        const confidence = matchedPatterns.length / metadata.patterns.length;

        result.matches.push({
          category,
          confidence,
          patterns: matchedPatterns,
        });
      }
    }

    // Sort matches by confidence
    result.matches.sort((a, b) => b.confidence - a.confidence);

    // If we have matches above threshold, use the top match
    if (
      result.matches.length > 0 &&
      result.matches[0].confidence >= this.config.confidenceThreshold
    ) {
      const topMatch = result.matches[0];
      const categoryMetadata = this.taxonomy[topMatch.category];

      result.classification = topMatch.category;
      result.confidence = topMatch.confidence;
      result.severity = categoryMetadata.severity;
      result.cweId = categoryMetadata.cwe || categoryMetadata.custom;
      result.patternMatched = topMatch.patterns[0];
    } else {
      // Default to "UNKNOWN" if no good matches
      result.classification = 'UNKNOWN';
      result.severity = vulnerability.severity || 'medium';
      result.confidence = 0.5; // Medium confidence for unknown
    }

    return result;
  }

  /**
   * Classify a list of vulnerabilities
   * @param {Array} vulnerabilities - List of vulnerabilities to classify
   * @returns {Array} - List of classified vulnerabilities
   */
  classifyVulnerabilities(vulnerabilities) {
    return vulnerabilities.map(vuln => this.classifyVulnerability(vuln));
  }

  /**
   * Generate statistics about vulnerability classifications
   * @param {Array} classifiedVulnerabilities - List of classified vulnerabilities
   * @returns {Object} - Statistics about classifications
   */
  generateStatistics(classifiedVulnerabilities) {
    const stats = {
      total: classifiedVulnerabilities.length,
      bySeverity: {
        critical: 0,
        high: 0,
        medium: 0,
        low: 0,
        info: 0,
      },
      byCategory: {},
      averageConfidence: 0,
      unclassified: 0,
    };

    let totalConfidence = 0;

    // Count vulnerabilities by category and severity
    classifiedVulnerabilities.forEach(vuln => {
      // Count by severity
      const severity = vuln.severity || 'medium';
      if (stats.bySeverity.hasOwnProperty(severity)) {
        stats.bySeverity[severity]++;
      }

      // Count by category
      const category = vuln.classification || 'UNKNOWN';
      if (!stats.byCategory[category]) {
        stats.byCategory[category] = 0;
      }
      stats.byCategory[category]++;

      // Track unclassified
      if (category === 'UNKNOWN') {
        stats.unclassified++;
      }

      // Add to total confidence
      totalConfidence += vuln.confidence || 0;
    });

    // Calculate average confidence
    stats.averageConfidence = totalConfidence / (classifiedVulnerabilities.length || 1);

    return stats;
  }

  /**
   * Get available vulnerability categories
   * @returns {Object} Available categories
   */
  getCategories() {
    return { ...this.taxonomy };
  }

  /**
   * Get configuration
   * @returns {Object} Current configuration
   */
  getConfig() {
    return { ...this.config };
  }

  /**
   * Update configuration
   * @param {Object} newConfig - New configuration options
   */
  updateConfig(newConfig) {
    this.config = { ...this.config, ...newConfig };
  }

  /**
   * Add custom vulnerability category
   * @param {string} categoryName - Name of the category
   * @param {Object} categoryData - Category metadata
   */
  addCategory(categoryName, categoryData) {
    this.taxonomy[categoryName] = categoryData;
  }

  /**
   * Remove vulnerability category
   * @param {string} categoryName - Name of the category to remove
   */
  removeCategory(categoryName) {
    delete this.taxonomy[categoryName];
  }

  /**
   * Save current taxonomy to file
   * @param {string} filePath - Path to save taxonomy
   */
  saveTaxonomy(filePath = null) {
    const savePath = filePath || this.config.taxonomyPath;
    try {
      fs.ensureDirSync(path.dirname(savePath));
      fs.writeFileSync(savePath, JSON.stringify(this.taxonomy, null, 2), 'utf8');
      console.log(`Taxonomy saved to ${savePath}`);
    } catch (error) {
      console.error(`Failed to save taxonomy: ${error.message}`);
    }
  }
}

module.exports = VulnerabilityClassifier;
