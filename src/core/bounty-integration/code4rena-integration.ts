/**
 * Code4rena Contest Integration
 *
 * This module provides integration with Code4rena contests, allowing the Audityzer
 * toolkit to generate issue reports in Code4rena's format and structure test findings
 * according to their submission guidelines.
 */

import fs from 'fs';
import path from 'path';
import { execSync } from 'child_process';

interface VulnerabilityIssue {
  id: string;
  title: string;
  description: string;
  severity: 'critical' | 'high' | 'medium' | 'low' | 'informational';
  category: string;
  impact: string;
  steps?: string[];
  code?: string;
  affected_files?: string[];
  proof_of_concept?: string;
  recommendation?: string;
}

interface TestResult {
  securityIssues: VulnerabilityIssue[];
  metadata: {
    protocol: string;
    timestamp: string;
    version: string;
    tester: string;
  };
}

interface Code4renaSubmission {
  title: string;
  description: string;
  vulnerability_details: string;
  impact: string;
  proof_of_concept: string;
  recommended_mitigation: string;
  severity: string;
  references?: string[];
  markdown: string;
}

/**
 * Code4rena severity ratings
 */
enum C4Severity {
  HIGH = '3 (High)',
  MEDIUM = '2 (Medium)',
  LOW = '1 (Low)',
  NONCRITIC = '0 (Non-critical)',
}

/**
 * Code4rena Contest Integration class
 */
export class Code4renaIntegration {
  private outputDir: string;
  private testResults: TestResult | null = null;
  private contestId: string;

  constructor(
    contestId: string = 'code4rena',
    outputDir: string = './test-results/c4-submissions'
  ) {
    this.contestId = contestId;
    this.outputDir = outputDir;

    // Ensure output directory exists
    if (!fs.existsSync(this.outputDir)) {
      fs.mkdirSync(this.outputDir, { recursive: true });
    }
  }

  /**
   * Load test results from a JSON file
   */
  loadTestResults(filePath: string): boolean {
    try {
      const data = fs.readFileSync(filePath, 'utf8');
      this.testResults = JSON.parse(data);
      return true;
    } catch (error) {
      console.error(`Error loading test results from ${filePath}:`, error);
      return false;
    }
  }

  /**
   * Set test results directly from an object
   */
  setTestResults(results: TestResult): void {
    this.testResults = results;
  }

  /**
   * Map Audityzer severity to Code4rena severity
   */
  private mapSeverity(severity: string): string {
    const severityMap: Record<string, string> = {
      critical: C4Severity.HIGH,
      high: C4Severity.HIGH,
      medium: C4Severity.MEDIUM,
      low: C4Severity.LOW,
      informational: C4Severity.NONCRITIC,
    };

    return severityMap[severity.toLowerCase()] || C4Severity.MEDIUM;
  }

  /**
   * Generate Code4rena submission for a vulnerability
   */
  generateSubmission(issue: VulnerabilityIssue): Code4renaSubmission {
    if (!this.testResults?.metadata) {
      throw new Error('Test results metadata is missing');
    }

    // Format vulnerability details
    let vulnerabilityDetails = '';
    vulnerabilityDetails += `${issue.description}\n\n`;

    if (issue.affected_files && issue.affected_files.length > 0) {
      vulnerabilityDetails += 'Affected files:\n';
      issue.affected_files.forEach(file => {
        vulnerabilityDetails += `- \`${file}\`\n`;
      });
      vulnerabilityDetails += '\n';
    }

    // Format proof of concept
    let poc = '';
    if (issue.proof_of_concept) {
      poc = issue.proof_of_concept;
    } else if (issue.code) {
      poc = issue.code;
    } else if (issue.steps && issue.steps.length > 0) {
      poc = 'Steps to reproduce:\n\n';
      issue.steps.forEach((step, index) => {
        poc += `${index + 1}. ${step}\n`;
      });
    } else {
      poc =
        'This vulnerability was identified through automated security testing with Audityzer. The system detected a potential security issue based on code analysis and test execution. Further manual verification is recommended.';
    }

    // Generate the markdown content for Code4rena submission
    const markdown = `## [${this.mapSeverity(issue.severity)}] ${issue.title}

### Lines of Code

\`\`\`solidity
${issue.affected_files?.map(file => `${file}`).join('\n') || 'Affected files not specified'}
\`\`\`

### Vulnerability Details

${vulnerabilityDetails}

### Impact

${issue.impact}

### Proof of Concept

\`\`\`solidity
${poc}
\`\`\`

### Recommended Mitigation Steps

${issue.recommendation || 'Consider implementing proper validation and access controls to address this vulnerability.'}

### References

- [Audityzer Security Testing Report](${this.testResults.metadata.protocol})
- [Test Execution: ${this.testResults.metadata.timestamp}]

---
*Generated by Audityzer Security Testing Toolkit*
`;

    return {
      title: issue.title,
      description: issue.description,
      vulnerability_details: vulnerabilityDetails,
      impact: issue.impact,
      proof_of_concept: poc,
      recommended_mitigation: issue.recommendation || '',
      severity: this.mapSeverity(issue.severity),
      markdown,
    };
  }

  /**
   * Generate submissions for all vulnerabilities in test results
   */
  generateSubmissions(): Code4renaSubmission[] {
    if (!this.testResults) {
      throw new Error('No test results loaded');
    }

    const submissions: Code4renaSubmission[] = [];

    // Generate a submission for each security issue
    for (const issue of this.testResults.securityIssues) {
      const submission = this.generateSubmission(issue);
      submissions.push(submission);
    }

    return submissions;
  }

  /**
   * Save submissions to files
   */
  saveSubmissions(submissions: Code4renaSubmission[]): string[] {
    const savedFiles: string[] = [];

    // Create contest directory
    const contestDir = path.join(this.outputDir, this.contestId);
    if (!fs.existsSync(contestDir)) {
      fs.mkdirSync(contestDir, { recursive: true });
    }

    // Save individual submissions
    submissions.forEach((submission, index) => {
      // Create a filename based on the severity and issue title
      const severity = submission.severity.charAt(0);
      const sanitizedTitle = submission.title
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/-+/g, '-')
        .replace(/^-|-$/g, '');

      const fileName = `${severity}-${sanitizedTitle}.md`;
      const filePath = path.join(contestDir, fileName);

      // Save the markdown content to file
      fs.writeFileSync(filePath, submission.markdown);
      savedFiles.push(filePath);

      logger.info(`Saved Code4rena submission to ${filePath}`);
    });

    // Create a combined report with all issues
    const allIssuesPath = path.join(contestDir, 'all-issues.md');
    const combinedContent = submissions.map(s => s.markdown).join('\n\n---\n\n');
    fs.writeFileSync(allIssuesPath, combinedContent);
    savedFiles.push(allIssuesPath);

    return savedFiles;
  }

  /**
   * Create a metrics report based on findings
   */
  generateMetricsReport(): string {
    if (!this.testResults) {
      throw new Error('No test results loaded');
    }

    // Count issues by severity
    const severityCounts = {
      high: 0,
      medium: 0,
      low: 0,
      nonCritical: 0,
    };

    this.testResults.securityIssues.forEach(issue => {
      const severity = issue.severity.toLowerCase();
      if (severity === 'critical' || severity === 'high') {
        severityCounts.high++;
      } else if (severity === 'medium') {
        severityCounts.medium++;
      } else if (severity === 'low') {
        severityCounts.low++;
      } else {
        severityCounts.nonCritical++;
      }
    });

    // Generate metrics report
    const metrics = `# Code4rena Contest Metrics

## Contest: ${this.contestId}
- Protocol: ${this.testResults.metadata.protocol}
- Testing Date: ${this.testResults.metadata.timestamp}
- Tester: ${this.testResults.metadata.tester}

## Findings Summary

| Severity | Count |
|----------|-------|
| High     | ${severityCounts.high} |
| Medium   | ${severityCounts.medium} |
| Low      | ${severityCounts.low} |
| Non-Critical | ${severityCounts.nonCritical} |
| **Total**    | **${this.testResults.securityIssues.length}** |

## Categories

${this.generateCategoryBreakdown()}

## Estimated Gas Savings
*Automatically calculated based on test execution*

---
*Generated by Audityzer Security Testing Toolkit*
`;

    // Save metrics to file
    const contestDir = path.join(this.outputDir, this.contestId);
    if (!fs.existsSync(contestDir)) {
      fs.mkdirSync(contestDir, { recursive: true });
    }

    const metricsPath = path.join(contestDir, 'metrics.md');
    fs.writeFileSync(metricsPath, metrics);

    return metricsPath;
  }

  /**
   * Generate category breakdown for metrics report
   */
  private generateCategoryBreakdown(): string {
    if (!this.testResults) {
      return '';
    }

    // Count issues by category
    const categories: Record<string, number> = {};

    this.testResults.securityIssues.forEach(issue => {
      if (!categories[issue.category]) {
        categories[issue.category] = 0;
      }
      categories[issue.category]++;
    });

    // Generate category breakdown table
    let categoryText = '| Category | Count |\n';
    categoryText += '|----------|-------|\n';

    Object.entries(categories)
      .sort((a, b) => b[1] - a[1]) // Sort by count (descending)
      .forEach(([category, count]) => {
        categoryText += `| ${category} | ${count} |\n`;
      });

    return categoryText;
  }

  /**
   * Run the full contest submission generation process
   */
  run(resultsFilePath: string, contestId?: string): string[] {
    if (contestId) {
      this.contestId = contestId;
    }

    logger.info(`Generating Code4rena submissions for contest ${this.contestId}...`);

    // Load test results
    const success = this.loadTestResults(resultsFilePath);
    if (!success) {
      console.error('Failed to generate Code4rena submissions.');
      return [];
    }

    // Generate and save submissions
    const submissions = this.generateSubmissions();
    const savedFiles = this.saveSubmissions(submissions);

    // Generate metrics report
    const metricsPath = this.generateMetricsReport();
    savedFiles.push(metricsPath);

    logger.info(`Generated ${submissions.length} Code4rena submissions.`);
    logger.info(`Metrics report saved to ${metricsPath}`);

    return savedFiles;
  }
}
