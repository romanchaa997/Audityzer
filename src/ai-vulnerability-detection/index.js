/* global describe, it, expect, beforeEach, afterEach, jest */
/**
 * AI Vulnerability Detection Module
 * 
 * Uses AI to generate tests and analyze smart contracts for vulnerabilities.
 */

import fs from 'fs-extra';
import path from 'path';
import chalk from 'chalk';
import OpenAI from 'openai';

// Initialize OpenAI API
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

/**
 * Generate a test using AI based on a natural language prompt
 * @param {string} prompt - Natural language description of the test to generate
 * @param {Object} options - Generation options
 * @param {string} options.templateType - Template type to use (security, wallet, aa)
 * @param {string} options.model - AI model to use
 * @param {string} options.outputPath - Output file path for the generated test
 * @returns {Promise<Object>} Generation result
 */
export async function generateTest(prompt, options) {
  try {
    const { templateType = 'security', model = 'gpt-4', outputPath } = options;

    // Load the appropriate template
    const templatePath = path.join(__dirname, 'templates', `${templateType}-template.js`);
    let template = '';

    try {
      template = await fs.readFile(templatePath, 'utf8');
    } catch (error) {
      console.warn(chalk.yellow(`Template not found: ${templatePath}, using default template`));
      template = `// @ts-check
const { test, expect } = require('@playwright/test');

test.describe('Generated Security Test', () => {
  test('should detect the vulnerability', async ({ page }) => {
    // Navigate to the target dApp
    await page.goto(process.env.TARGET_URL || 'http://localhost:3000');
    
    // Test implementation will be generated here
    
  });
});
`;
    }

    // Prepare the prompt for the AI
    const aiPrompt = `You are a Web3 security expert. Generate a Playwright test that can detect the following vulnerability or test scenario:

${prompt}

The test should be practical and executable. Use the following template structure but fill in the implementation details:

${template}

Make sure to include detailed comments explaining what the test is checking for and why. Focus on creating a realistic test that could actually detect the described vulnerability in a dApp.`;

    // Call the OpenAI API
    const completion = await openai.chat.completions.create({
      model: model,
      messages: [
        { role: "system", content: "You are a Web3 security expert who specializes in writing tests to detect vulnerabilities in dApps." },
        { role: "user", content: aiPrompt }
      ],
      temperature: 0.7,
      max_tokens: 2500,
    });

    // Extract the generated test code
    const generatedTest = completion.choices[0].message.content;

    // Save the generated test to the output file
    await fs.ensureDir(path.dirname(outputPath));
    await fs.writeFile(outputPath, generatedTest);

    return {
      success: true,
      outputPath,
      generatedTest
    };
  } catch (error) {
    console.error(chalk.red(`Error generating test: ${error.message}`));
    throw error;
  }
}

/**
 * Analyze a smart contract for vulnerabilities using AI
 * @param {string} contractCode - Smart contract code to analyze
 * @param {Object} options - Analysis options
 * @param {string} options.model - AI model to use
 * @param {string} options.outputPath - Output file path for the analysis report
 * @returns {Promise<Object>} Analysis result
 */
export async function analyzeContract(contractCode, options) {
  try {
    const { model = 'gpt-4', outputPath } = options;

    // Prepare the prompt for the AI
    const aiPrompt = `Analyze the following smart contract code for security vulnerabilities:

\`\`\`
${contractCode}
\`\`\`

Provide a detailed security analysis including:
1. A summary of the contract's purpose and functionality
2. Identified vulnerabilities with severity ratings (Critical, High, Medium, Low)
3. Detailed explanations of each vulnerability
4. Recommendations for fixing each issue
5. Overall security assessment

Format your response as markdown.`;

    // Call the OpenAI API
    const completion = await openai.chat.completions.create({
      model: model,
      messages: [
        { role: "system", content: "You are a smart contract security auditor with expertise in finding vulnerabilities in blockchain applications." },
        { role: "user", content: aiPrompt }
      ],
      temperature: 0.7,
      max_tokens: 4000,
    });

    // Extract the analysis
    const analysis = completion.choices[0].message.content;

    // Parse the analysis to extract vulnerabilities
    const vulnerabilities = extractVulnerabilitiesFromAnalysis(analysis);

    // Save the analysis to the output file
    await fs.ensureDir(path.dirname(outputPath));
    await fs.writeFile(outputPath, analysis);

    return {
      success: true,
      outputPath,
      analysis,
      vulnerabilities
    };
  } catch (error) {
    console.error(chalk.red(`Error analyzing contract: ${error.message}`));
    throw error;
  }
}

/**
 * Extract vulnerabilities from the analysis text
 * @param {string} analysis - Analysis text in markdown format
 * @returns {Array<Object>} Extracted vulnerabilities
 */
function extractVulnerabilitiesFromAnalysis(analysis) {
  const vulnerabilities = [];

  // Look for vulnerability sections in the markdown
  // This is a simple regex-based extraction and might need refinement
  const vulnerabilityRegex = /#+\s*(?:Vulnerability|Issue|Bug)\s*\d*\s*:\s*([^\n]+)\s*(?:\n+[^#]+?(?:Severity|Impact)\s*:\s*([^\n]+))?/gi;

  let match;
  while ((match = vulnerabilityRegex.exec(analysis)) !== null) {
    const title = match[1].trim();
    let severity = match[2] ? match[2].trim() : 'Unknown';

    // Try to determine severity if not explicitly stated
    if (severity === 'Unknown') {
      if (title.toLowerCase().includes('critical')) severity = 'Critical';
      else if (title.toLowerCase().includes('high')) severity = 'High';
      else if (title.toLowerCase().includes('medium')) severity = 'Medium';
      else if (title.toLowerCase().includes('low')) severity = 'Low';
    }

    // Extract description - text between this vulnerability and the next heading
    const descriptionMatch = analysis.substring(match.index + match[0].length).match(/([^#]+)(?=\n#+|$)/s);
    const description = descriptionMatch ? descriptionMatch[1].trim() : '';

    vulnerabilities.push({
      title,
      severity,
      description,
      type: determineVulnerabilityType(title, description),
      location: 'contract.sol' // Default location
    });
  }

  return vulnerabilities;
}

/**
 * Determine the type of vulnerability based on title and description
 * @param {string} title - Vulnerability title
 * @param {string} description - Vulnerability description
 * @returns {string} Vulnerability type
 */
function determineVulnerabilityType(title, description) {
  const text = (title + ' ' + description).toLowerCase();

  if (text.includes('reentrancy')) return 'reentrancy';
  if (text.includes('overflow') || text.includes('underflow')) return 'arithmetic';
  if (text.includes('front run') || text.includes('frontrun')) return 'frontrunning';
  if (text.includes('access control') || text.includes('permission')) return 'accessControl';
  if (text.includes('oracle') || text.includes('price manipulation')) return 'oracleManipulation';
  if (text.includes('flash loan')) return 'flashloanAttack';
  if (text.includes('unchecked return') || text.includes('return value')) return 'uncheckedReturn';
  if (text.includes('dos') || text.includes('denial of service')) return 'dos';
  if (text.includes('gas') || text.includes('out of gas')) return 'gasOptimization';
  if (text.includes('timestamp') || text.includes('block.timestamp')) return 'timestampDependence';
  if (text.includes('randomness') || text.includes('random')) return 'weakRandomness';
  if (text.includes('signature') || text.includes('replay')) return 'signatureReplay';

  return 'other';
}

export default {
  generateTest,
  analyzeContract
};