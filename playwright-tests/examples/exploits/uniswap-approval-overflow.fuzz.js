/* global describe, it, expect, beforeEach, afterEach, jest */
/**
 * Test case description: Uniswap-style token approval overflow vulnerability detection
 * Vulnerability: ERC20 token approvals with excessive values that could cause overflow
 * Manual reproduction steps:
 *   1. Connect to a Uniswap-like DEX
 *   2. Test token approval with extremely large values
 *   3. Check for proper handling of uint256 values
 *   4. Detect unsafe approval practices
 * Security impact: Could result in unauthorized token access or transaction failures
 */

const { test, expect } = require('@playwright/test');
const { connectWallet, setupWalletState } = require('../../utils');
const { ethers } = require('ethers');

// Standard ERC20 ABI for token interactions
const ERC20_ABI = [
  'function approve(address spender, uint256 amount) public returns (bool)',
  'function allowance(address owner, address spender) public view returns (uint256)',
  'function balanceOf(address account) public view returns (uint256)',
  'function transfer(address recipient, uint256 amount) public returns (bool)',
];

test.describe('Uniswap Token Approval Overflow Tests', () => {
  test.beforeEach(async ({ page }) => {
    // Setup wallet state for testing
    await setupWalletState(page, {
      chainId: '0x1',
      networkName: 'Ethereum Mainnet',
      accounts: ['0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266'],
      balance: '100000000000000000000', // 100 ETH
    });

    // Navigate to the DApp
    await page.goto(process.env.DAPP_URL || 'https://app.uniswap.org');
    await connectWallet(page);

    // Setup token contract monitoring
    await page.addInitScript(() => {
      // Storage for approval transactions
      window._approvalTransactions = [];
      window._vulnerableApprovals = [];

      // Define max uint256 value
      window._MAX_UINT256 = '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff';

      // Store original provider methods
      const originalRequest = window.ethereum.request;

      // Hook into the Ethereum provider to monitor transactions
      window.ethereum.request = async function (args) {
        // Capture approval transactions
        if (args.method === 'eth_sendTransaction') {
          const tx = args.params[0];

          // Check if this is an approval transaction by looking at the method signature (0x095ea7b3 = approve(address,uint256))
          if (tx.data && tx.data.startsWith('0x095ea7b3')) {
            const approvalData = {
              timestamp: Date.now(),
              from: tx.from,
              to: tx.to, // Token contract
              spender: '0x' + tx.data.slice(34, 74), // Extract spender address
              amount: '0x' + tx.data.slice(74), // Extract amount
            };

            // Store the approval transaction
            window._approvalTransactions.push(approvalData);

            // Check for potentially vulnerable approvals
            checkApprovalVulnerability(approvalData);
          }
        }

        // Call original method
        return originalRequest.call(window.ethereum, args);
      };

      // Function to check for approval vulnerabilities
      function checkApprovalVulnerability(approvalData) {
        // Check for unlimited approvals (MAX_UINT256)
        const isUnlimitedApproval = approvalData.amount === window._MAX_UINT256;

        // Calculate approval amount in decimal
        const approvalAmountBN = BigInt(approvalData.amount);
        const thousandETH = BigInt('1000000000000000000000'); // 1000 ETH

        // Check for large but not unlimited approvals
        const isLargeApproval =
          approvalAmountBN > thousandETH && approvalAmountBN < BigInt(window._MAX_UINT256);

        // Known token router addresses (simplified for demo)
        const knownRouters = {
          '0x7a250d5630b4cf539739df2c5dacb4c659f2488d': 'Uniswap V2 Router',
          '0xe592427a0aece92de3edee1f18e0157c05861564': 'Uniswap V3 Router',
          '0x68b3465833fb72a70ecdf485e0e4c7bd8665fc45': 'Uniswap V3 Router 2',
          '0x1111111254fb6c44bac0bed2854e76f90643097d': '1inch Router',
        };

        // Determine if spender is a known router
        const routerName = knownRouters[approvalData.spender.toLowerCase()] || 'Unknown Router';

        // Determine vulnerability type and severity
        let vulnerabilityType = null;
        let severityScore = 0;

        if (isUnlimitedApproval) {
          vulnerabilityType = 'Unlimited Token Approval';
          severityScore = 8;
        } else if (isLargeApproval) {
          vulnerabilityType = 'Excessive Token Approval';
          severityScore = 6;
        }

        // If vulnerable, store the vulnerability
        if (vulnerabilityType) {
          window._vulnerableApprovals.push({
            ...approvalData,
            vulnerabilityType,
            severityScore,
            routerName,
            details: {
              isUnlimitedApproval,
              isLargeApproval,
              approvalAmountHex: approvalData.amount,
              recommendedAction: isUnlimitedApproval
                ? 'Use exact token amounts for approvals instead of unlimited values'
                : 'Consider approving only the amount needed for the current transaction',
            },
          });
        }
      }

      // Function to get vulnerability report
      window.getApprovalVulnerabilityReport = function () {
        return {
          approvalTransactions: window._approvalTransactions,
          vulnerableApprovals: window._vulnerableApprovals,
          summary: {
            totalApprovals: window._approvalTransactions.length,
            vulnerableCount: window._vulnerableApprovals.length,
            unlimitedApprovals: window._vulnerableApprovals.filter(
              v => v.details.isUnlimitedApproval
            ).length,
            excessiveApprovals: window._vulnerableApprovals.filter(v => v.details.isLargeApproval)
              .length,
          },
        };
      };

      // Function to simulate a safer approval
      window.setApprovalSafely = function (tokenAddress, spenderAddress, amount) {
        // In a real implementation, this would use a more complex strategy:
        // 1. First set approval to 0 (to prevent certain attacks)
        // 2. Then approve the exact amount needed
        console.log(
          `Setting safe approval for token ${tokenAddress} to spender ${spenderAddress} with amount ${amount}`
        );
        return `Setting safe approval executed with amount: ${amount}`;
      };
    });
  });

  test('should detect unlimited token approvals', async ({ page }) => {
    // Simulate interaction with a token before swap
    await page
      .evaluate(() => {
        // Mock an unlimited approval transaction (MAX_UINT256)
        const mockUnlimitedApproval = {
          from: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',
          to: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48', // USDC token
          data: '0x095ea7b30000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488dffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff',
        };

        // Trigger the approval detection
        window.ethereum.request({
          method: 'eth_sendTransaction',
          params: [mockUnlimitedApproval],
        });

        return window.getApprovalVulnerabilityReport();
      })
      .then(report => {
        // Log the report
        console.log('Unlimited Approval Vulnerability Report:', JSON.stringify(report, null, 2));

        // Verify that the vulnerability was detected
        expect(report.vulnerableApprovals.length).toBeGreaterThan(0);
        expect(report.vulnerableApprovals[0].vulnerabilityType).toBe('Unlimited Token Approval');
      });
  });

  test('should detect overflow vulnerabilities in approvals', async ({ page }) => {
    // Test with a very large but not unlimited approval value (close to overflow)
    const overflowValue = '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00'; // Very large value

    await page
      .evaluate(overflowValue => {
        // Mock an excessive approval transaction
        const mockLargeApproval = {
          from: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',
          to: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48', // USDC token
          data:
            '0x095ea7b30000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d' +
            overflowValue.slice(2),
        };

        // Trigger the approval detection
        window.ethereum.request({
          method: 'eth_sendTransaction',
          params: [mockLargeApproval],
        });

        return window.getApprovalVulnerabilityReport();
      }, overflowValue)
      .then(report => {
        // Verify that the vulnerability was detected
        expect(report.vulnerableApprovals.length).toBeGreaterThan(0);
      });
  });

  test('should verify if DEX requires resetting approvals before changing them', async ({
    page,
  }) => {
    // In some tokens (like USDT), you need to set approval to 0 before setting to a new non-zero value
    // This test checks if the DEX handles that pattern correctly

    await page
      .evaluate(() => {
        // Simulate sequence of approvals for the same token and router
        const tokenAddress = '0xdAC17F958D2ee523a2206206994597C13D831ec7'; // USDT
        const routerAddress = '0x7a250d5630b4cf539739df2c5dacb4c659f2488d'; // Uniswap V2

        // First approval
        const firstApprovalTx = {
          from: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',
          to: tokenAddress,
          data:
            '0x095ea7b3000000000000000000000000' +
            routerAddress.slice(2) +
            '0000000000000000000000000000000000000000000000000000000000000064', // 100 tokens
        };

        // Second approval (without resetting)
        const secondApprovalTx = {
          from: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',
          to: tokenAddress,
          data:
            '0x095ea7b3000000000000000000000000' +
            routerAddress.slice(2) +
            '00000000000000000000000000000000000000000000000000000000000000c8', // 200 tokens
        };

        // Trigger both approvals
        window.ethereum.request({
          method: 'eth_sendTransaction',
          params: [firstApprovalTx],
        });

        window.ethereum.request({
          method: 'eth_sendTransaction',
          params: [secondApprovalTx],
        });

        return {
          vulnReport: window.getApprovalVulnerabilityReport(),
          approvalSequence: [firstApprovalTx, secondApprovalTx],
        };
      })
      .then(result => {
        // Log approval sequence (would actually test for failure in real implementation)
        console.log('Approval Sequence Test:', JSON.stringify(result.approvalSequence, null, 2));
      });
  });

  test('should test testnet/mainnet chain mismatch in approvals', async ({ page }) => {
    // Setup wallet state with wrong network for the DApp
    await setupWalletState(page, {
      chainId: '0x5', // Goerli testnet
      networkName: 'Goerli Testnet',
      accounts: ['0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266'],
      balance: '100000000000000000000', // 100 ETH
    });

    // Attempt to interact with mainnet token on testnet
    await page
      .evaluate(() => {
        // Mock an approval transaction with mainnet token address on testnet
        const mockMismatchedApproval = {
          from: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',
          to: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48', // USDC token on mainnet
          data: '0x095ea7b30000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d000000000000000000000000000000000000000000000000000000000000000a',
        };

        // Record the network mismatch
        window._networkMismatch = {
          expectedChain: '0x1', // Mainnet
          actualChain: '0x5', // Goerli
          tokenAddress: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',
          routerAddress: '0x7a250d5630b4cf539739df2c5dacb4c659f2488d',
        };

        // Trigger the approval
        return window.ethereum
          .request({
            method: 'eth_sendTransaction',
            params: [mockMismatchedApproval],
          })
          .catch(error => {
            // We expect this to fail due to network mismatch
            return {
              error: error.message,
              networkMismatch: window._networkMismatch,
            };
          });
      })
      .then(result => {
        console.log('Network Mismatch Test Result:', JSON.stringify(result, null, 2));

        // Here we would verify that the DApp properly detected the network mismatch
        // In a real implementation, this would check for proper error handling
      });
  });
});
