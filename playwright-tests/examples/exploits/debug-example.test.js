/* global describe, it, expect, beforeEach, afterEach, jest */
/**
 * Debug Logger Example Test
 *
 * This test demonstrates how to use the debug logger
 * for detailed test logging, failure tracking, and visualization.
 */

const { test, expect } = require('@playwright/test');
const { DebugLogger, DEBUG_LEVELS } = require('../../utils');
const { connectWallet, setupWalletState } = require('../../utils');

// Initialize the debug logger
const logger = new DebugLogger({
  enabled: true,
  level: DEBUG_LEVELS.VERBOSE,
  outputToConsole: true,
  outputToFile: true,
  outputPath: './test-output/debug-logs',
  fileName: 'debug-example.log',
  sessionId: `debug-example-${Date.now()}`,
});

test.describe('Debug Logger Example Tests', () => {
  const WALLET_ADDRESS = '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266';

  test.beforeEach(async ({ page }) => {
    // Log test setup step
    logger.logStep('Test Setup', { test: 'Debug Example' }, 'start');

    // Setup wallet state for testing
    await setupWalletState(page, {
      chainId: '0x1',
      networkName: 'Ethereum Mainnet',
      accounts: [WALLET_ADDRESS],
      balance: '100000000000000000000', // 100 ETH
    });

    // Navigate to blank page
    await page.goto('about:blank');
    await connectWallet(page);

    // Log completion of test setup
    logger.logStep('Test Setup', { test: 'Debug Example' }, 'complete');
  });

  test.afterEach(async () => {
    // Generate a report after each test
    const report = logger.generateReport();
    logger.log(
      'Test completed with report',
      {
        level: DEBUG_LEVELS.BASIC,
        reportSummary: report.summary,
      },
      'system'
    );
  });

  test('should log basic test steps', async ({ page }) => {
    // Log start of a test step
    logger.logStep('Basic Step Logging', { method: 'logStep' }, 'start');

    // Perform some action
    await page.evaluate(() => {
      console.log('Performing basic action');
      return true;
    });

    // Log completion of the step
    logger.logStep('Basic Step Logging', { result: 'success' }, 'complete');

    // Verify the step was logged
    expect(logger.testSteps.length).toBeGreaterThan(0);
    expect(logger.testSteps.some(step => step.stepName === 'Basic Step Logging')).toBeTruthy();
  });

  test('should log transaction details', async ({ page }) => {
    // Log a transaction with details
    const txHash =
      '0x' +
      Array(64)
        .fill(0)
        .map(() => Math.floor(Math.random() * 16).toString(16))
        .join('');

    logger.logTransaction(
      {
        hash: txHash,
        from: WALLET_ADDRESS,
        to: '0x1234567890123456789012345678901234567890',
        value: '1000000000000000000', // 1 ETH
        gasPrice: '5000000000',
        gas: '21000',
      },
      {
        type: 'ETH Transfer',
        description: 'Test transaction for debug logging',
      }
    );

    // Verify the transaction was logged
    expect(logger.transactions.length).toBe(1);
    expect(logger.transactions[0].hash).toBe(txHash);
  });

  test('should log cross-chain messages for visualization', async ({ page }) => {
    // Log multiple cross-chain messages
    logger.logCrossChainMessage({
      id: '1',
      timestamp: Date.now(),
      sourceChain: { id: 'ethereum', name: 'Ethereum' },
      destinationChain: { id: 'optimism', name: 'Optimism' },
      data: { amount: '1000000000000000000' },
      type: 'TOKEN_BRIDGE',
    });

    // Add a small delay between messages
    await page.waitForTimeout(100);

    logger.logCrossChainMessage({
      id: '2',
      timestamp: Date.now(),
      sourceChain: { id: 'optimism', name: 'Optimism' },
      destinationChain: { id: 'arbitrum', name: 'Arbitrum' },
      data: { amount: '1000000000000000000' },
      type: 'TOKEN_BRIDGE',
    });

    await page.waitForTimeout(100);

    logger.logCrossChainMessage({
      id: '3',
      timestamp: Date.now(),
      sourceChain: { id: 'arbitrum', name: 'Arbitrum' },
      destinationChain: { id: 'ethereum', name: 'Ethereum' },
      data: { amount: '900000000000000000' }, // Less than original due to fees
      type: 'TOKEN_BRIDGE',
    });

    // Generate the visualization
    const visualization = logger.visualizeCrossChainFlow();
    logger.log(
      'Cross-chain flow visualization',
      {
        level: DEBUG_LEVELS.BASIC,
        visualization,
      },
      'visualization'
    );

    // Verify cross-chain messages were logged
    expect(logger.crossChainMessages.length).toBe(3);

    // Console output of visualization for demo purposes
    console.log('\n' + visualization);
  });

  test('should capture and log test failures', async ({ page }) => {
    // Log start of a step that will fail
    logger.logStep('Failing Step', { expectedToFail: true }, 'start');

    try {
      // Attempt an operation that will fail
      await page.evaluate(() => {
        throw new Error('Simulated test failure');
      });

      // This should not be reached
      logger.logStep('Failing Step', { unexpectedSuccess: true }, 'complete');
    } catch (error) {
      // Log the failure
      logger.logFailure('Simulated Failure', error, {
        step: 'Failing Step',
        context: 'This failure is intentional for demonstration',
      });

      logger.logStep('Failing Step', { error: error.message }, 'failed');
    }

    // Verify the failure was logged
    expect(logger.failures.length).toBe(1);
    expect(logger.failures[0].name).toBe('Simulated Failure');

    // The test itself should still pass as we caught the error
    expect(true).toBeTruthy();
  });

  test('should demonstrate different debug levels', async () => {
    // Log at different debug levels
    logger.log('This is a basic level message', { level: DEBUG_LEVELS.BASIC }, 'info');
    logger.log(
      'This is a verbose level message',
      { level: DEBUG_LEVELS.VERBOSE, extraData: 'Only shown in verbose mode' },
      'info'
    );
    logger.log(
      'This is a trace level message',
      {
        level: DEBUG_LEVELS.TRACE,
        detailedObject: {
          deeply: {
            nested: {
              data: 'Only shown in trace mode',
            },
          },
        },
      },
      'debug'
    );

    // This test doesn't need assertions as it's demonstrating logging
    expect(true).toBeTruthy();
  });
});
