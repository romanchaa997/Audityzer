/* global describe, it, expect, beforeEach, afterEach, jest */
/**
 * Wallet Matrix Fuzz Test Suite
 *
 * This test suite performs fuzz testing across multiple wallet providers:
 * - MetaMask
 * - WalletConnect
 * - Coinbase Wallet
 *
 * It tests wallet connections, transaction signing, network switching, and error handling
 * with randomized parameters to discover edge cases and vulnerabilities.
 *
 * Generated by Audityzer - yarn forge:gen tx --wallet metamask,coinbase,walletconnect --fuzz
 */

const { test, expect } = require('@playwright/test');
const { createWalletAdapter } = require('../src/core/wallet-adapter');
const crypto = require('crypto');
const fs = require('fs');
const path = require('path');

// Get command line args
const args = process.argv.slice(2);
const isSnapshotMode = args.includes('--snapshot');

// Create snapshot directory if it doesn't exist
if (isSnapshotMode) {
  const snapshotDir = path.join(process.cwd(), 'test-output', 'wallet-snapshots');
  if (!fs.existsSync(snapshotDir)) {
    fs.mkdirSync(snapshotDir, { recursive: true });
  }
  console.log('Running in snapshot mode. Wallet state will be captured before and after tests.');
}

// Define wallet providers to test
const WALLET_PROVIDERS = ['metamask', 'walletconnect', 'coinbase'];

// Test networks to use (chainId as hex)
const TEST_NETWORKS = [
  { id: '0x1', name: 'Ethereum Mainnet' },
  { id: '0x5', name: 'Goerli Testnet' },
  { id: '0xaa36a7', name: 'Sepolia Testnet' },
  { id: '0x89', name: 'Polygon Mainnet' },
  { id: '0x13881', name: 'Mumbai Testnet' },
  { id: '0xa4b1', name: 'Arbitrum One' },
  { id: '0xa', name: 'Optimism' },
];

// Fuzz parameters
const NUM_FUZZ_ITERATIONS = 5;
const MAX_GAS_LIMIT = 1000000;
const MIN_GAS_LIMIT = 21000;
const MAX_GAS_PRICE = 500; // in Gwei
const MIN_GAS_PRICE = 1; // in Gwei
const MAX_TRANSACTION_VALUE = 1; // in ETH (keep low for testing)

/**
 * Takes a snapshot of the wallet state
 * @param {Object} page - Playwright page object
 * @param {Object} wallet - Wallet adapter
 * @param {string} label - Label for the snapshot
 * @param {Object} additionalData - Additional data to include in the snapshot
 * @returns {Promise<Object>} The captured wallet state
 */
async function takeWalletSnapshot(page, wallet, label, additionalData = {}) {
  if (!isSnapshotMode) return null;

  try {
    // Get basic wallet state
    const walletState = await wallet.getState(page);

    // Get balances for the current chain
    const balances = await page.evaluate(async address => {
      // Get ETH balance
      const ethBalanceHex = await window.ethereum.request({
        method: 'eth_getBalance',
        params: [address, 'latest'],
      });
      const ethBalance = parseInt(ethBalanceHex, 16) / 1e18;

      // On mainnet, we could also get token balances, but we'll skip for this demo
      return {
        native: ethBalance,
        tokens: {}, // In a real implementation, would include ERC20 token balances
      };
    }, walletState.address);

    // Build the full snapshot
    const timestamp = new Date().toISOString();
    const snapshot = {
      timestamp,
      label,
      walletType: wallet.type,
      state: walletState,
      balances,
      networkInfo: TEST_NETWORKS.find(n => n.id === walletState.chainId) || { name: 'Unknown' },
      ...additionalData,
    };

    // Save snapshot to file
    const walletType = wallet.type || 'unknown';
    const safeLabel = label.replace(/[^a-z0-9]/gi, '-').toLowerCase();
    const filename = `${walletType}-${safeLabel}-${timestamp.replace(/:/g, '-')}.json`;
    const snapshotPath = path.join(process.cwd(), 'test-output', 'wallet-snapshots', filename);

    fs.writeFileSync(snapshotPath, JSON.stringify(snapshot, null, 2));
    console.log(`Wallet snapshot saved: ${filename}`);

    return snapshot;
  } catch (error) {
    console.error(`Error taking wallet snapshot: ${error.message}`);
    return null;
  }
}

/**
 * Compare two wallet snapshots to detect state drift
 * @param {Object} before - Snapshot taken before the test
 * @param {Object} after - Snapshot taken after the test
 * @returns {Object} Comparison results with detected changes
 */
function compareSnapshots(before, after) {
  if (!before || !after) return { compared: false };

  const changes = {
    compared: true,
    timestamp: new Date().toISOString(),
    walletType: after.walletType,
    duration: new Date(after.timestamp) - new Date(before.timestamp),
    changes: [],
  };

  // Compare address (shouldn't change)
  if (before.state.address !== after.state.address) {
    changes.changes.push({
      type: 'address_changed',
      severity: 'critical',
      before: before.state.address,
      after: after.state.address,
    });
  }

  // Compare chain ID
  if (before.state.chainId !== after.state.chainId) {
    changes.changes.push({
      type: 'network_changed',
      severity: 'info',
      before: `${before.networkInfo.name} (${before.state.chainId})`,
      after: `${after.networkInfo.name} (${after.state.chainId})`,
    });
  }

  // Compare balances
  if (before.balances.native !== after.balances.native) {
    const diff = after.balances.native - before.balances.native;
    changes.changes.push({
      type: 'balance_changed',
      severity: diff < 0 ? 'warning' : 'info',
      before: before.balances.native,
      after: after.balances.native,
      diff: diff.toFixed(6),
    });
  }

  // Compare connection state
  if (before.state.isConnected !== after.state.isConnected) {
    changes.changes.push({
      type: 'connection_changed',
      severity: 'high',
      before: before.state.isConnected,
      after: after.state.isConnected,
    });
  }

  // Save comparison results
  if (isSnapshotMode) {
    const filename = `comparison-${after.walletType}-${after.label.replace(/[^a-z0-9]/gi, '-').toLowerCase()}-${after.timestamp.replace(/:/g, '-')}.json`;
    const comparisonPath = path.join(process.cwd(), 'test-output', 'wallet-snapshots', filename);
    fs.writeFileSync(comparisonPath, JSON.stringify(changes, null, 2));

    if (changes.changes.length > 0) {
      console.log(`Detected ${changes.changes.length} state changes for ${after.walletType}`);
      changes.changes.forEach(change => {
        console.log(`- ${change.type} (${change.severity}): ${change.before} â†’ ${change.after}`);
      });
    } else {
      console.log(`No state changes detected for ${after.walletType}`);
    }
  }

  return changes;
}

// Generate a random transaction
function generateRandomTransaction(walletAddress) {
  const toAddress =
    walletAddress === '0x1234567890123456789012345678901234567890'
      ? '0x0987654321098765432109876543210987654321'
      : '0x1234567890123456789012345678901234567890';

  // Generate random value (in wei, from 0 to MAX_TRANSACTION_VALUE ETH)
  const value = '0x' + Math.floor(Math.random() * (MAX_TRANSACTION_VALUE * 1e18)).toString(16);

  // Generate random gas price (in wei)
  const gasPriceGwei =
    Math.floor(Math.random() * (MAX_GAS_PRICE - MIN_GAS_PRICE + 1)) + MIN_GAS_PRICE;
  const gasPrice = '0x' + (gasPriceGwei * 1e9).toString(16);

  // Generate random gas limit
  const gasLimit =
    '0x' +
    (Math.floor(Math.random() * (MAX_GAS_LIMIT - MIN_GAS_LIMIT + 1)) + MIN_GAS_LIMIT).toString(16);

  // Sometimes include data, sometimes don't
  const includeData = Math.random() > 0.5;
  let data = '0x';

  if (includeData) {
    // Generate random data
    const dataSize = Math.floor(Math.random() * 100); // Up to 100 bytes
    data = '0x' + crypto.randomBytes(dataSize).toString('hex');
  }

  return {
    from: walletAddress,
    to: toAddress,
    value,
    gasPrice,
    gas: gasLimit,
    data,
  };
}

// Set up a wallet for testing
async function setupWallet(page, walletType) {
  const wallet = createWalletAdapter(walletType);
  await wallet.initialize(page);
  await wallet.connect(page);
  return wallet;
}

// Randomly select a network to switch to
function getRandomNetwork(currentNetwork) {
  let network;
  do {
    network = TEST_NETWORKS[Math.floor(Math.random() * TEST_NETWORKS.length)];
  } while (network.id === currentNetwork);
  return network;
}

test.describe('Wallet Matrix Fuzz Tests', () => {
  test.beforeEach(async ({ page }) => {
    // Add mock ethereum provider
    await page.addInitScript(() => {
      window.ethereum = {
        isMetaMask: true,
        isCoinbaseWallet: true, // Also mark as Coinbase for those tests
        selectedAddress: null,
        chainId: '0x1', // Default to Ethereum Mainnet
        networkVersion: '1',
        request: async ({ method, params = [] }) => {
          console.log(`Mock wallet: ${method} called with params:`, params);

          switch (method) {
            case 'eth_requestAccounts':
              window.ethereum.selectedAddress = '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266';
              return [window.ethereum.selectedAddress];

            case 'eth_accounts':
              return [
                window.ethereum.selectedAddress || '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',
              ];

            case 'eth_chainId':
              return window.ethereum.chainId;

            case 'net_version':
              return window.ethereum.networkVersion;

            case 'wallet_switchEthereumChain':
              window.ethereum.chainId = params[0]?.chainId;
              switch (window.ethereum.chainId) {
                case '0x1':
                  window.ethereum.networkVersion = '1';
                  break;
                case '0x5':
                  window.ethereum.networkVersion = '5';
                  break;
                case '0xaa36a7':
                  window.ethereum.networkVersion = '11155111';
                  break;
                case '0x89':
                  window.ethereum.networkVersion = '137';
                  break;
                case '0x13881':
                  window.ethereum.networkVersion = '80001';
                  break;
                case '0xa4b1':
                  window.ethereum.networkVersion = '42161';
                  break;
                case '0xa':
                  window.ethereum.networkVersion = '10';
                  break;
                default:
                  window.ethereum.networkVersion = '1';
              }
              return null;

            case 'eth_sendTransaction':
              // Check if simulation should fail (10% of the time)
              if (Math.random() < 0.1) {
                throw new Error('Transaction failed: Insufficient funds');
              }
              // Return a mock transaction hash
              return (
                '0x' +
                Array(64)
                  .fill(0)
                  .map(() => Math.floor(Math.random() * 16).toString(16))
                  .join('')
              );

            case 'eth_signTypedData_v4':
            case 'eth_signTypedData':
            case 'personal_sign':
              // Simulate successful signature
              return (
                '0x' +
                Array(130)
                  .fill(0)
                  .map(() => Math.floor(Math.random() * 16).toString(16))
                  .join('')
              );

            default:
              console.warn(`Unhandled method: ${method}`);
              return null;
          }
        },
        on: (eventName, callback) => {
          console.log(`Wallet mock: registered event listener for ${eventName}`);
        },
        // For WalletConnect compatibility
        enable: async () => {
          window.ethereum.selectedAddress = '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266';
          return [window.ethereum.selectedAddress];
        },
        // Simulate WalletConnect provider structure
        connector: {
          connected: true,
          accounts: ['0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266'],
          chainId: 1,
          bridge: 'https://bridge.walletconnect.org',
          key: '12345',
          clientId: '67890',
          clientMeta: {
            description: 'WalletConnect Mock',
            url: 'https://walletconnect.org',
            icons: ['https://walletconnect.org/walletconnect-logo.png'],
            name: 'WalletConnect',
          },
        },
      };
    });

    // Navigate to a test page
    await page.goto('about:blank');
  });

  for (const walletType of WALLET_PROVIDERS) {
    test(`should fuzz connection flows with ${walletType}`, async ({ page }) => {
      const wallet = await setupWallet(page, walletType);

      // Take initial snapshot if in snapshot mode
      let initialSnapshot = null;
      if (isSnapshotMode) {
        initialSnapshot = await takeWalletSnapshot(page, wallet, 'connection-flow-initial', {
          testCase: 'connection-fuzz',
        });
      }

      // Get initial wallet state after connection
      const initialState = await wallet.getState(page);
      expect(initialState.isConnected).toBe(true);

      // Run a series of connection/disconnection tests
      for (let i = 0; i < NUM_FUZZ_ITERATIONS; i++) {
        // Randomly decide whether to disconnect
        if (Math.random() > 0.5) {
          await wallet.disconnect(page);
          const state = await wallet.getState(page);
          expect(state.isConnected).toBe(false);

          // Reconnect
          await wallet.connect(page);
          const reconnectedState = await wallet.getState(page);
          expect(reconnectedState.isConnected).toBe(true);
        }

        // Randomly decide whether to switch networks
        if (Math.random() > 0.3) {
          const currentChainId = (await wallet.getState(page)).chainId;
          const newNetwork = getRandomNetwork(currentChainId);

          await wallet.switchNetwork(page, newNetwork.id);
          const newState = await wallet.getState(page);
          expect(newState.chainId).toBe(newNetwork.id);
        }
      }

      // Take final snapshot and compare with initial
      if (isSnapshotMode) {
        const finalSnapshot = await takeWalletSnapshot(page, wallet, 'connection-flow-final', {
          testCase: 'connection-fuzz',
          iterations: NUM_FUZZ_ITERATIONS,
        });

        const comparison = compareSnapshots(initialSnapshot, finalSnapshot);
        if (comparison.changes && comparison.changes.length > 0) {
          console.log(`Detected state drift in connection flow test for ${walletType}!`);
        }
      }
    });

    test(`should fuzz transaction signing with ${walletType}`, async ({ page }) => {
      const wallet = await setupWallet(page, walletType);
      const state = await wallet.getState(page);

      // Take initial snapshot if in snapshot mode
      let initialSnapshot = null;
      if (isSnapshotMode) {
        initialSnapshot = await takeWalletSnapshot(page, wallet, 'transaction-signing-initial', {
          testCase: 'transaction-fuzz',
        });
      }

      // Run multiple transaction signing tests
      for (let i = 0; i < NUM_FUZZ_ITERATIONS; i++) {
        // Generate a random transaction
        const tx = generateRandomTransaction(state.address);

        try {
          // Attempt to sign and send the transaction
          const txResult = await wallet.sendTransaction(page, tx);
          console.log(`Transaction ${i + 1} (${walletType}):`, txResult);

          // Validate transaction hash format
          if (txResult) {
            expect(txResult).toMatch(/^0x[a-fA-F0-9]{64}$/);
          }
        } catch (error) {
          // Some transactions may fail - that's expected in fuzzing
          console.log(`Transaction ${i + 1} failed with error:`, error.message);

          // Make sure the wallet is still in a usable state
          const currentState = await wallet.getState(page);
          expect(currentState.isConnected).toBe(true);
        }
      }

      // Take final snapshot and compare with initial
      if (isSnapshotMode) {
        const finalSnapshot = await takeWalletSnapshot(page, wallet, 'transaction-signing-final', {
          testCase: 'transaction-fuzz',
          iterations: NUM_FUZZ_ITERATIONS,
        });

        const comparison = compareSnapshots(initialSnapshot, finalSnapshot);
        if (comparison.changes && comparison.changes.length > 0) {
          console.log(`Detected state drift in transaction signing test for ${walletType}!`);
        }
      }
    });

    test(`should fuzz message signing with ${walletType}`, async ({ page }) => {
      const wallet = await setupWallet(page, walletType);

      for (let i = 0; i < NUM_FUZZ_ITERATIONS; i++) {
        // Generate random message size and content
        const messageSize = Math.floor(Math.random() * 200) + 1; // 1 to 200 bytes
        const message = crypto.randomBytes(messageSize).toString('hex');

        // Randomly choose between personal_sign and typed data signing
        const signMethod = Math.random() > 0.5 ? 'personalSign' : 'signTypedData';

        try {
          let signature;
          if (signMethod === 'personalSign') {
            signature = await wallet.signMessage(page, message);
          } else {
            // Create a simple EIP-712 typed data object
            const typedData = {
              types: {
                EIP712Domain: [
                  { name: 'name', type: 'string' },
                  { name: 'version', type: 'string' },
                  { name: 'chainId', type: 'uint256' },
                ],
                Message: [
                  { name: 'content', type: 'string' },
                  { name: 'nonce', type: 'uint256' },
                ],
              },
              primaryType: 'Message',
              domain: {
                name: 'Fuzz Testing',
                version: '1',
                chainId: parseInt((await wallet.getState(page)).chainId),
              },
              message: {
                content: message,
                nonce: Math.floor(Math.random() * 1000000),
              },
            };
            signature = await wallet.signTypedData(page, typedData);
          }

          console.log(`${signMethod} signature for ${walletType} (message ${i + 1}):`, signature);
          expect(signature).toMatch(/^0x[a-fA-F0-9]{130}$/);
        } catch (error) {
          console.log(`Message signing ${i + 1} failed with error:`, error.message);

          // Make sure the wallet is still in a usable state
          const currentState = await wallet.getState(page);
          expect(currentState.isConnected).toBe(true);
        }
      }
    });

    test(`should fuzz error handling with ${walletType}`, async ({ page }) => {
      const wallet = await setupWallet(page, walletType);

      // Override eth_sendTransaction to simulate different error scenarios
      await page.evaluate(() => {
        const originalRequest = window.ethereum.request;
        window.ethereum.request = async ({ method, params = [] }) => {
          if (method === 'eth_sendTransaction') {
            // Simulate different error scenarios
            const errorScenarios = [
              { code: 4001, message: 'User rejected the transaction' },
              { code: -32000, message: 'Insufficient funds for gas * price + value' },
              { code: -32003, message: 'Transaction rejected' },
              { code: -32602, message: 'Invalid parameters' },
              { code: -32603, message: 'Internal error' },
            ];

            // 80% chance of an error
            if (Math.random() < 0.8) {
              const scenario = errorScenarios[Math.floor(Math.random() * errorScenarios.length)];
              const error = new Error(scenario.message);
              error.code = scenario.code;
              throw error;
            }
          }
          return originalRequest({ method, params });
        };
      });

      // Test how wallet handles errors
      for (let i = 0; i < NUM_FUZZ_ITERATIONS; i++) {
        const state = await wallet.getState(page);
        const tx = generateRandomTransaction(state.address);

        try {
          const txResult = await wallet.sendTransaction(page, tx);
          console.log('Transaction succeeded unexpectedly:', txResult);
        } catch (error) {
          console.log(`Expected error ${i + 1}:`, error.message);

          // Make sure the wallet is still in a usable state after error
          const currentState = await wallet.getState(page);
          expect(currentState.isConnected).toBe(true);
        }
      }
    });

    test(`should test rapid switching between networks with ${walletType}`, async ({ page }) => {
      const wallet = await setupWallet(page, walletType);

      // Rapid network switching
      for (let i = 0; i < NUM_FUZZ_ITERATIONS; i++) {
        const currentChainId = (await wallet.getState(page)).chainId;
        const newNetwork = getRandomNetwork(currentChainId);

        await wallet.switchNetwork(page, newNetwork.id);

        // Don't wait between switches to stress test
        if (i < NUM_FUZZ_ITERATIONS - 1) {
          const anotherNetwork = getRandomNetwork(newNetwork.id);
          await wallet.switchNetwork(page, anotherNetwork.id);
        }
      }

      // Verify wallet is still in a good state
      const finalState = await wallet.getState(page);
      expect(finalState.isConnected).toBe(true);
    });
  }

  test('should fuzz multi-wallet compatibility', async ({ page }) => {
    // Test compatibility between multiple wallet providers
    let currentWallet;
    let initialSnapshot = null;

    // Take initial snapshot with the first wallet
    if (isSnapshotMode) {
      const firstWallet = await setupWallet(page, WALLET_PROVIDERS[0]);
      initialSnapshot = await takeWalletSnapshot(page, firstWallet, 'multi-wallet-initial', {
        testCase: 'multi-wallet-compatibility',
      });
      await firstWallet.disconnect(page);
    }

    for (let i = 0; i < NUM_FUZZ_ITERATIONS; i++) {
      // Randomly select a wallet provider
      const walletType = WALLET_PROVIDERS[Math.floor(Math.random() * WALLET_PROVIDERS.length)];

      // Disconnect current wallet if exists
      if (currentWallet) {
        await currentWallet.disconnect(page);
      }

      // Connect with the new wallet
      console.log(`Iteration ${i + 1}: Switching to ${walletType}`);
      currentWallet = await setupWallet(page, walletType);

      // Verify connection
      const state = await currentWallet.getState(page);
      expect(state.isConnected).toBe(true);
      expect(state.address).toBeDefined();

      // Perform a transaction or network switch randomly
      if (Math.random() > 0.5) {
        const tx = generateRandomTransaction(state.address);
        try {
          await currentWallet.sendTransaction(page, tx);
        } catch (error) {
          console.log('Transaction failed during multi-wallet test:', error.message);
        }
      } else {
        const newNetwork = getRandomNetwork(state.chainId);
        await currentWallet.switchNetwork(page, newNetwork.id);
      }
    }

    // Take final snapshot and compare with initial
    if (isSnapshotMode && currentWallet) {
      const finalSnapshot = await takeWalletSnapshot(page, currentWallet, 'multi-wallet-final', {
        testCase: 'multi-wallet-compatibility',
        iterations: NUM_FUZZ_ITERATIONS,
      });

      if (initialSnapshot) {
        const comparison = compareSnapshots(initialSnapshot, finalSnapshot);
        console.log(
          `Multi-wallet test completed with ${comparison.changes?.length || 0} state changes detected.`
        );
      }
    }
  });
});
