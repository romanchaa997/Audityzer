const FeatureEngineering = require('../../../src/core/ai-vulnerability-detection/model-development/feature-engineering');

describe('FeatureEngineering', () => {
  let mockConfig;

  beforeEach(async () => {
    mockConfig = {
      enabledExtractors: ['codeMetrics', 'patternMatches'],
      codeMetrics: { enabled: true, complexityThreshold: 10 },
      patternMatches: { enabled: true, patternSets: ['reentrancy', 'access-control'] },
      semanticEmbeddings: { enabled: false }
    };
    await FeatureEngineering.initialize(mockConfig);
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  describe('initialization', () => {
    it('should initialize with default config', async () => {
      const result = await FeatureEngineering.initialize();
      expect(result).toBe(true);
      expect(FeatureEngineering.isInitialized()).toBe(true);
    });

    it('should initialize with custom config', async () => {
      expect(FeatureEngineering.isInitialized()).toBe(true);
      const config = FeatureEngineering.getConfig();
      expect(config.codeMetrics.enabled).toBe(true);
      expect(config.patternMatches.enabled).toBe(true);
    });
  });

  describe('extractFeatures', () => {
    const mockContract = {
      code: `
        pragma solidity ^0.8.0;
        contract Test {
          function transfer(address to, uint256 amount) public {
            // vulnerable function
          }
        }
      `,
    };

    it('should extract features from contract', async () => {
      const features = await FeatureEngineering.extractFeatures({
        contractCode: mockContract.code,
        saveFeatures: false
      });

      expect(features).toEqual(expect.any(Object));
      expect(features.features).toEqual(expect.any(Object));
      expect(features.features.codeMetrics).toEqual(expect.any(Object));
      expect(features.features.patternMatches).toEqual(expect.any(Object));
    });

    it('should handle contracts without code', async () => {
      const features = await FeatureEngineering.extractFeatures({
        contractCode: '',
        saveFeatures: false
      });

      expect(features).toEqual(expect.any(Object));
      expect(features.features.codeMetrics).toEqual(expect.any(Object));
    });

    it('should handle missing contract code', async () => {
      const features = await FeatureEngineering.extractFeatures({
        saveFeatures: false
      });

      expect(features.error).toEqual(expect.any(String));
      expect(features.success).toBe(false);
    });
  });

  describe('prepareFeatureVector', () => {
    it('should prepare feature vector from extracted features', () => {
      const mockFeatures = {
        features: {
          codeMetrics: {
            functionCount: 5,
            complexityScore: 10,
            normalizedComplexity: 0.5
          },
          patternMatches: {
            patternScores: {
              reentrancy: 0.8,
              'access-control': 0.2
            },
            vulnerabilityScores: {
              hasVulnerability: true,
              maxScore: 0.8,
              overallScore: 0.5
            }
          }
        }
      };

      const vector = FeatureEngineering.prepareFeatureVector(mockFeatures, ['codeMetrics', 'patternMatches']);

      expect(vector).toEqual(expect.any(Object));
      expect(vector.raw).toEqual(expect.any(Object));
      expect(vector.flattened).toEqual(expect.any(Object));
      expect(vector.vector).toEqual(expect.any(Array));
    });

    it('should handle empty features', () => {
      const emptyFeatures = { features: {} };
      const vector = FeatureEngineering.prepareFeatureVector(emptyFeatures, []);

      expect(vector).toEqual(expect.any(Object));
      expect(vector.vector).toEqual(expect.any(Array));
    });
  });

  describe('utility methods', () => {
    it('should return config', () => {
      const config = FeatureEngineering.getConfig();
      expect(config).toEqual(expect.any(Object));
      expect(config.enabledExtractors).toEqual(expect.any(Array));
    });

    it('should return initialization status', () => {
      const status = FeatureEngineering.isInitialized();
      expect(status).toBe(true);
    });

    it('should return vulnerability patterns', () => {
      const patterns = FeatureEngineering.getVulnerabilityPatterns();
      expect(patterns).toEqual(expect.any(Object));
      expect(patterns.reentrancy).toEqual(expect.any(Array));
      expect(patterns['access-control']).toEqual(expect.any(Array));
    });
  });
});