const fs = require('fs-extra');
const path = require('path');
const VulnerabilityGenerator = require('../../../src/core/ai-vulnerability-detection/model-development/vulnerability-generator');

describe('VulnerabilityGenerator', () => {
  let generator;
  let mockConfig;
  let tempDir;

  beforeEach(() => {
    tempDir = path.join(__dirname, 'temp-test-output');
    mockConfig = {
      outputDir: tempDir,
      templatesDir: path.join(__dirname, 'temp-templates'),
      confidenceThreshold: 0.75,
    };
    generator = new VulnerabilityGenerator(mockConfig);
  });

  afterEach(() => {
    jest.restoreAllMocks();
    // Clean up temp directories
    if (fs.existsSync(tempDir)) {
      fs.removeSync(tempDir);
    }
    if (fs.existsSync(mockConfig.templatesDir)) {
      fs.removeSync(mockConfig.templatesDir);
    }
  });

  describe('constructor', () => {
    it('should initialize with default config', () => {
      const g = new VulnerabilityGenerator();
      expect(g.isInitialized()).toBe(true);
    });

    it('should initialize with custom config', () => {
      expect(generator.isInitialized()).toBe(true);
      expect(generator.getConfig().confidenceThreshold).toBe(0.75);
    });

    it('should create output directory', () => {
      expect(fs.existsSync(tempDir)).toBe(true);
    });
  });

  describe('loadTemplates', () => {
    beforeEach(() => {
      // Create test templates
      fs.ensureDirSync(mockConfig.templatesDir);
      fs.writeFileSync(
        path.join(mockConfig.templatesDir, 'reentrancy.sol'),
        'contract ReentrancyTemplate { /* template */ }'
      );
      fs.writeFileSync(
        path.join(mockConfig.templatesDir, 'access-control.js'),
        '// Access control template'
      );
    });

    it('should load templates from directory', () => {
      const newGenerator = new VulnerabilityGenerator(mockConfig);
      const templates = newGenerator.getTemplates();

      expect(templates).toEqual(expect.any(Object));
      expect(templates).toHaveProperty('reentrancy');
      expect(templates).toHaveProperty('access-control');
    });

    it('should handle missing templates directory', () => {
      const configWithMissingDir = {
        ...mockConfig,
        templatesDir: path.join(__dirname, 'non-existent'),
      };
      const newGenerator = new VulnerabilityGenerator(configWithMissingDir);
      const templates = newGenerator.getTemplates();

      expect(templates).toEqual(expect.any(Object));
      expect(Object.keys(templates).length).toBe(0);
    });
  });

  describe('generateExploit', () => {
    const mockVulnerability = {
      id: 'vuln-1',
      classification: 'reentrancy',
      description: 'Reentrancy vulnerability in withdraw function',
      contractName: 'VulnerableContract',
      functionName: 'withdraw',
      code: `
        function withdraw() public {
          msg.sender.call{value: balance}("");
          balance = 0;
        }
      `,
    };

    it('should generate exploit from patterns', async () => {
      const exploit = await generator.generateExploit(mockVulnerability);

      expect(exploit).to.be.an('object');
      expect(exploit).to.have.property('id');
      expect(exploit).to.have.property('code');
      expect(exploit).to.have.property('language');
      expect(exploit).to.have.property('confidence');
      expect(exploit.vulnerabilityId).to.equal('vuln-1');
      expect(exploit.vulnerabilityType).to.equal('reentrancy');
    });

    it('should generate exploit from template when available', async () => {
      // Create a template
      fs.ensureDirSync(mockConfig.templatesDir);
      fs.writeFileSync(
        path.join(mockConfig.templatesDir, 'reentrancy.sol'),
        `contract {{CONTRACT_NAME}}Exploit {
          // Template for {{VULNERABILITY_DESCRIPTION}}
        }`
      );

      const newGenerator = new VulnerabilityGenerator(mockConfig);
      const exploit = await newGenerator.generateExploit(mockVulnerability);

      expect(exploit.code).to.include('VulnerableContractExploit');
      expect(exploit.confidence).to.equal(0.9);
    });

    it('should save exploit to file by default', async () => {
      const exploit = await generator.generateExploit(mockVulnerability);

      expect(exploit).to.have.property('filePath');
      expect(fs.existsSync(exploit.filePath)).to.be.true;
    });

    it('should not save exploit when save option is false', async () => {
      const exploit = await generator.generateExploit(mockVulnerability, { save: false });

      expect(exploit).to.not.have.property('filePath');
    });

    it('should handle unknown vulnerability type', async () => {
      const unknownVuln = {
        ...mockVulnerability,
        classification: 'unknown-type',
      };

      const exploit = await generator.generateExploit(unknownVuln);

      expect(exploit).to.be.an('object');
      expect(exploit.code).to.include('GenericExploit');
    });
  });

  describe('generateFromTemplate', () => {
    const mockVulnerability = {
      classification: 'reentrancy',
      contractName: 'TestContract',
      functionName: 'withdraw',
      description: 'Test vulnerability',
    };

    beforeEach(() => {
      generator.addTemplate(
        'reentrancy',
        `contract {{CONTRACT_NAME}}Exploit {
          // Exploit for {{VULNERABILITY_DESCRIPTION}}
          // Function: {{FUNCTION_NAME}}
          // Date: {{EXPLOIT_DATE}}
        }`
      );
    });

    it('should generate exploit from template', async () => {
      const exploit = await generator.generateFromTemplate(mockVulnerability);

      expect(exploit.code).to.include('TestContractExploit');
      expect(exploit.code).to.include('Test vulnerability');
      expect(exploit.code).to.include('withdraw');
      expect(exploit.confidence).to.equal(0.9);
    });

    it('should detect language from template', async () => {
      const exploit = await generator.generateFromTemplate(mockVulnerability);

      expect(exploit.language).to.equal('javascript');
    });

    it('should detect Solidity language', async () => {
      generator.addTemplate(
        'reentrancy',
        `pragma solidity ^0.8.0;
        contract {{CONTRACT_NAME}}Exploit {}`
      );

      const exploit = await generator.generateFromTemplate(mockVulnerability);

      expect(exploit.language).to.equal('solidity');
    });
  });

  describe('generateFromPatterns', () => {
    it('should generate reentrancy exploit', () => {
      const vulnerability = { classification: 'reentrancy' };
      const exploit = generator.generateFromPatterns(vulnerability);

      expect(exploit.code).to.include('ReentrancyExploit');
      expect(exploit.language).to.equal('solidity');
      expect(exploit.confidence).to.equal(0.6);
    });

    it('should generate access control exploit', () => {
      const vulnerability = { classification: 'access-control' };
      const exploit = generator.generateFromPatterns(vulnerability);

      expect(exploit.code).to.include('AccessControlExploit');
    });

    it('should generate arithmetic exploit', () => {
      const vulnerability = { classification: 'arithmetic' };
      const exploit = generator.generateFromPatterns(vulnerability);

      expect(exploit.code).to.include('ArithmeticExploit');
    });

    it('should generate generic exploit for unknown type', () => {
      const vulnerability = { classification: 'unknown' };
      const exploit = generator.generateFromPatterns(vulnerability);

      expect(exploit.code).to.include('GenericExploit');
    });
  });

  describe('generateTestCase', () => {
    const mockVulnerability = {
      classification: 'reentrancy',
      contractName: 'TestContract',
    };

    it('should generate test case', () => {
      const testCase = generator.generateTestCase(mockVulnerability, 'solidity');

      expect(testCase).to.be.a('string');
      expect(testCase).to.include('describe');
      expect(testCase).to.include('TestContract');
      expect(testCase).to.include('reentrancy');
    });

    it('should handle vulnerability without contract name', () => {
      const vuln = { classification: 'test' };
      const testCase = generator.generateTestCase(vuln, 'solidity');

      expect(testCase).to.include('VulnerableContract');
    });
  });

  describe('formatExploitFile', () => {
    const mockExploit = {
      vulnerabilityType: 'reentrancy',
      generatedAt: '2023-01-01T00:00:00.000Z',
      confidence: 0.8,
      description: 'Test exploit',
      executionInstructions: ['Step 1', 'Step 2'],
      code: 'contract TestExploit {}',
      language: 'solidity',
    };

    it('should format Solidity exploit file', () => {
      const formatted = generator.formatExploitFile(mockExploit);

      expect(formatted).to.include('// SPDX-License-Identifier: MIT');
      expect(formatted).to.include('// Generated by Audityzer');
      expect(formatted).to.include('// Vulnerability: reentrancy');
      expect(formatted).to.include('// Confidence: 0.8');
      expect(formatted).to.include('contract TestExploit {}');
    });

    it('should format JavaScript exploit file', () => {
      const jsExploit = { ...mockExploit, language: 'javascript' };
      const formatted = generator.formatExploitFile(jsExploit);

      expect(formatted).to.include('/**');
      expect(formatted).to.include('* Generated by Audityzer');
      expect(formatted).to.include('* Vulnerability: reentrancy');
    });
  });

  describe('generateBatch', () => {
    const mockVulnerabilities = [
      {
        id: '1',
        classification: 'reentrancy',
        description: 'First vulnerability',
      },
      {
        id: '2',
        classification: 'access-control',
        description: 'Second vulnerability',
      },
    ];

    it('should generate exploits for multiple vulnerabilities', async () => {
      const results = await generator.generateBatch(mockVulnerabilities, { save: false });

      expect(results).to.be.an('array');
      expect(results.length).to.equal(2);
      results.forEach(result => {
        expect(result).to.have.property('code');
        expect(result).to.have.property('vulnerabilityId');
      });
    });

    it('should handle errors in batch generation', async () => {
      const invalidVuln = { id: '3' }; // Missing required fields
      const vulnerabilities = [...mockVulnerabilities, invalidVuln];

      const results = await generator.generateBatch(vulnerabilities, { save: false });

      expect(results).to.be.an('array');
      expect(results.length).to.equal(3);
      // Should still generate for valid vulnerabilities
      expect(results[0]).to.have.property('code');
      expect(results[1]).to.have.property('code');
    });
  });

  describe('template management', () => {
    it('should add custom template', () => {
      const templateCode = 'contract CustomExploit {}';
      generator.addTemplate('custom', templateCode);

      const templates = generator.getTemplates();
      expect(templates).to.have.property('custom');
      expect(templates.custom).to.equal(templateCode);
    });

    it('should remove template', () => {
      generator.addTemplate('temp', 'code');
      generator.removeTemplate('temp');

      const templates = generator.getTemplates();
      expect(templates).to.not.have.property('temp');
    });
  });

  describe('utility methods', () => {
    it('should return config', () => {
      const config = generator.getConfig();
      expect(config).to.be.an('object');
      expect(config.confidenceThreshold).to.equal(0.75);
    });

    it('should return initialization status', () => {
      expect(generator.isInitialized()).to.be.true;
    });

    it('should return templates', () => {
      const templates = generator.getTemplates();
      expect(templates).to.be.an('object');
    });
  });
});