const VulnerabilityClassifier = require('../../../src/core/ai-vulnerability-detection/model-development/vulnerability-classifier');

describe('VulnerabilityClassifier', () => {
  let classifier;
  let mockConfig;

  beforeEach(() => {
    mockConfig = {
      confidenceThreshold: 0.25, // Lower threshold for testing
      enableMLClassification: true,
      categories: ['reentrancy', 'access-control', 'arithmetic'],
    };
    classifier = new VulnerabilityClassifier(mockConfig);
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  describe('constructor', () => {
    it('should initialize with default config', () => {
      const c = new VulnerabilityClassifier();
      expect(c).toBeInstanceOf(VulnerabilityClassifier);
      expect(c.getConfig().confidenceThreshold).toBe(0.7);
    });

    it('should initialize with custom config', () => {
      expect(classifier).toBeInstanceOf(VulnerabilityClassifier);
      expect(classifier.getConfig().confidenceThreshold).toBe(0.7);
    });
  });

  describe('classifyVulnerability', () => {
    const mockVulnerability = {
      description: 'Reentrancy vulnerability in withdraw function',
      code: `
        function withdraw() public {
          msg.sender.call{value: balance}("");
          balance = 0;
        }
      `,
      context: {
        functionName: 'withdraw',
        contractName: 'TestContract',
      },
    };

    it('should classify vulnerability correctly', () => {
      const result = classifier.classifyVulnerability(mockVulnerability);

      expect(result).toEqual(expect.any(Object));
      expect(result.classification).toEqual(expect.any(String));
      expect(result.confidence).toEqual(expect.any(Number));
      expect(result.confidence).toBeGreaterThanOrEqual(0);
      expect(result.confidence).toBeLessThanOrEqual(1);
    });

    it('should handle vulnerability without description', () => {
      const vulnWithoutDesc = { ...mockVulnerability, description: '' };
      const result = classifier.classifyVulnerability(vulnWithoutDesc);

      expect(result).toEqual(expect.any(Object));
      expect(result.classification).toEqual(expect.any(String));
    });

    it('should handle vulnerability without code', () => {
      const vulnWithoutCode = { ...mockVulnerability, code: '' };
      const result = classifier.classifyVulnerability(vulnWithoutCode);

      expect(result).toEqual(expect.any(Object));
      expect(result.classification).toEqual(expect.any(String));
    });
  });

  describe('classifyVulnerabilities', () => {
    const mockVulnerabilities = [
      {
        id: '1',
        description: 'Reentrancy vulnerability',
        code: 'msg.sender.call{value: amount}("");',
      },
      {
        id: '2',
        description: 'Access control issue',
        code: 'function adminFunction() public {}',
      },
    ];

    it('should classify multiple vulnerabilities', () => {
      const results = classifier.classifyVulnerabilities(mockVulnerabilities);

      expect(results).toEqual(expect.any(Array));
      expect(results.length).toBe(2);
      results.forEach(result => {
        expect(result).toHaveProperty('classification');
        expect(result).toHaveProperty('confidence');
      });
    });

    it('should handle empty array', () => {
      const results = classifier.classifyVulnerabilities([]);

      expect(results).toEqual(expect.any(Array));
      expect(results.length).toBe(0);
    });
  });

  describe('generateStatistics', () => {
    const mockClassifications = [
      { classification: 'REENTRANCY', confidence: 0.9, severity: 'high' },
      { classification: 'REENTRANCY', confidence: 0.8, severity: 'high' },
      { classification: 'ACCESS_CONTROL', confidence: 0.7, severity: 'high' },
      { classification: 'ARITHMETIC', confidence: 0.6, severity: 'medium' },
    ];

    it('should generate classification statistics', () => {
      const stats = classifier.generateStatistics(mockClassifications);

      expect(stats).toEqual(expect.any(Object));
      expect(stats.total).toBe(4);
      expect(stats.byCategory).toEqual(expect.any(Object));
      expect(stats.averageConfidence).toEqual(expect.any(Number));
      expect(stats.unclassified).toEqual(expect.any(Number));
    });

    it('should handle empty classifications', () => {
      const stats = classifier.generateStatistics([]);

      expect(stats.total).toBe(0);
      expect(stats.averageConfidence).toBe(0);
    });
  });

  describe('pattern-based classification', () => {
    it('should detect reentrancy patterns', () => {
      const vulnerability = {
        name: 'Reentrancy Issue',
        description: 'reentrancy vulnerability with external call after state change',
        code: `
          function withdraw() public {
            msg.sender.call{value: balance}("");
            balance = 0;
          }
        `
      };

      const result = classifier.classifyVulnerability(vulnerability);

      expect(result.classification).toBe('REENTRANCY');
      expect(result.confidence).toBeGreaterThan(0);
    });

    it('should detect access control patterns', () => {
      const vulnerability = {
        name: 'Missing Access Control',
        description: 'unauthorized access to admin function with missing authorization',
        code: `
          function adminFunction() public {
            // No access control
          }
        `
      };

      const result = classifier.classifyVulnerability(vulnerability);

      expect(result.classification).toBe('ACCESS_CONTROL');
      expect(result.confidence).toBeGreaterThan(0);
    });

    it('should detect arithmetic patterns', () => {
      const vulnerability = {
        name: 'Integer Overflow',
        description: 'overflow vulnerability in addition with integer overflow',
        code: `
          function add(uint256 a, uint256 b) public pure returns (uint256) {
            return a + b; // No overflow check
          }
        `
      };

      const result = classifier.classifyVulnerability(vulnerability);

      expect(result.classification).toBe('ARITHMETIC');
      expect(result.confidence).toBeGreaterThan(0);
    });

    it('should return unknown for unrecognized patterns', () => {
      const vulnerability = {
        name: 'Unknown Issue',
        description: 'some random description',
        code: `
          function safeFunction() public pure returns (uint256) {
            return 42;
          }
        `
      };

      const result = classifier.classifyVulnerability(vulnerability);

      expect(result.classification).toBe('UNKNOWN');
      expect(result.confidence).toBeLessThan(1.0);
    });
  });

  describe('utility methods', () => {
    it('should return config', () => {
      const config = classifier.getConfig();
      expect(config).toEqual(expect.any(Object));
      expect(config.confidenceThreshold).toBe(0.7);
    });

    it('should return initialization status', () => {
      expect(classifier.isInitialized()).toBe(true);
    });

    it('should return available categories', () => {
      const categories = classifier.getCategories();
      expect(categories).toEqual(expect.any(Object));
      expect(categories).toHaveProperty('REENTRANCY');
      expect(categories).toHaveProperty('ACCESS_CONTROL');
      expect(categories).toHaveProperty('ARITHMETIC');
    });

    it('should add new category', () => {
      const newCategoryData = {
        patterns: ['test-pattern'],
        severity: 'medium',
        description: 'Test category',
        cwe: 'CWE-TEST',
      };

      classifier.addCategory('NEW_CATEGORY', newCategoryData);
      const categories = classifier.getCategories();
      expect(categories).toHaveProperty('NEW_CATEGORY');
      expect(categories.NEW_CATEGORY).toEqual(newCategoryData);
    });

    it('should remove category', () => {
      classifier.removeCategory('ARITHMETIC');
      const categories = classifier.getCategories();
      expect(categories).not.toHaveProperty('ARITHMETIC');
    });
  });
});