const fs = require('fs-extra');
const fs = require('fs-extra');
const path = require('path');
const os = require('os');
const ModelDevelopment = require('../../../src/core/ai-vulnerability-detection/model-development/index');

describe('ModelDevelopment', () => {
  let modelDev;
  let tempDir;
  let mockConfig;

  beforeEach(async () => {
    // Create temporary directory for testing
    tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'model-dev-test-'));

    mockConfig = {
      dataStoragePath: tempDir,
      modelsDir: path.join(tempDir, 'models'),
      dataDir: path.join(tempDir, 'data'),
      batchSize: 32,
      featureEngineeringConfig: {
        codeMetrics: { enabled: true },
        patternMatches: { enabled: true },
        semanticEmbeddings: { enabled: true },
      },
    };

    // Ensure directories exist
    await fs.ensureDir(mockConfig.modelsDir);
    await fs.ensureDir(mockConfig.dataDir);

    modelDev = new ModelDevelopment(mockConfig);
  });

  afterEach(async () => {
    jest.restoreAllMocks();

    // Clean up temporary directory
    if (tempDir && await fs.pathExists(tempDir)) {
      await fs.remove(tempDir);
    }
  });

  describe('constructor', () => {
    it('should initialize with default config', () => {
      const md = new ModelDevelopment();
      expect(md.isInitialized()).toBe(false); // Not initialized until initialize() is called
    });

    it('should initialize with custom config', () => {
      expect(modelDev.isInitialized()).toBe(false); // Will be true after initialize() is called
      expect(modelDev.getConfig().batchSize).toBe(32);
    });

    it('should create required directories', async () => {
      await modelDev.initialize(mockConfig);
      expect(fs.existsSync(tempDir)).toBe(true);
      expect(fs.existsSync(mockConfig.modelsDir)).toBe(true);
      expect(fs.existsSync(mockConfig.dataDir)).toBe(true);
    });
  });

  describe('trainModel', () => {
    const mockTrainingData = [
      {
        contract: {
          code: 'function withdraw() { msg.sender.call{value: amount}(""); }',
          ast: { type: 'SourceUnit' },
        },
        vulnerabilities: [
          {
            type: 'reentrancy',
            severity: 'high',
            confidence: 0.9,
          },
        ],
      },
      {
        contract: {
          code: 'function safeWithdraw() { require(balance > 0); balance = 0; msg.sender.transfer(balance); }',
          ast: { type: 'SourceUnit' },
        },
        vulnerabilities: [],
      },
    ];

    beforeEach(async () => {
      await modelDev.initialize(mockConfig);
    });

    it('should train model with training data', async () => {
      const result = await modelDev.trainModel('vuln-classifier-base', mockTrainingData, {
        epochs: 5,
      });

      expect(result).toEqual(expect.any(Object));
      expect(result).toHaveProperty('modelId');
      expect(result).toHaveProperty('evaluation');
      expect(result).toHaveProperty('trainingTime');
      expect(result).toHaveProperty('modelPath');
      expect(result.modelId).toBe('vuln-classifier-base');
    });

    it('should handle empty training data', async () => {
      await expect(modelDev.trainModel('vuln-classifier-base', []))
        .rejects.toThrow();
    });

    it('should validate model exists', async () => {
      await expect(modelDev.trainModel('non-existent-model', mockTrainingData))
        .rejects.toThrow('Model non-existent-model not found');
    });
  });

  describe('analyzeContract', () => {
    const mockContract = {
      code: `
        pragma solidity ^0.8.0;
        contract Test {
          function withdraw() public {
            msg.sender.call{value: balance}("");
            balance = 0;
          }
        }
      `,
      ast: {
        type: 'SourceUnit',
        children: [
          {
            type: 'ContractDefinition',
            name: 'Test',
          },
        ],
      },
    };

    beforeEach(async () => {
      await modelDev.initialize(mockConfig);
    });

    it('should analyze contract for vulnerabilities', async () => {
      // First need to set up active models
      modelDev.config.activeModels = { 'vuln-classifier-base': 'vuln-classifier-base' };
      modelDev.config.models[0].status = 'trained';

      const analysis = await modelDev.analyzeContract(mockContract);

      expect(analysis).toEqual(expect.any(Object));
      expect(analysis).toHaveProperty('vulnerabilities');
      expect(analysis).toHaveProperty('confidence');
      expect(analysis).toHaveProperty('analysisTime');
      expect(analysis).toHaveProperty('contractId');
      expect(analysis.vulnerabilities).toEqual(expect.any(Array));
    });

    it('should handle contract without AST', async () => {
      modelDev.config.activeModels = { 'vuln-classifier-base': 'vuln-classifier-base' };
      modelDev.config.models[0].status = 'trained';

      const contractWithoutAST = { code: mockContract.code };
      const analysis = await modelDev.analyzeContract(contractWithoutAST);

      expect(analysis).toEqual(expect.any(Object));
      expect(analysis.vulnerabilities).toEqual(expect.any(Array));
    });

    it('should handle empty contract', async () => {
      const emptyContract = { code: '' };
      const analysis = await modelDev.analyzeContract(emptyContract);

      expect(analysis.vulnerabilities).toEqual(expect.any(Array));
      expect(analysis.vulnerabilities.length).toBe(0);
    });
  });

  describe('createClassifier', () => {
    it('should create vulnerability classifier', () => {
      const classifier = modelDev.createClassifier({
        confidenceThreshold: 0.8,
      });

      expect(classifier).toEqual(expect.any(Object));
      expect(classifier).toHaveProperty('classifyVulnerability');
      expect(classifier).toHaveProperty('classifyBatch');
    });

    it('should use default config when none provided', () => {
      const classifier = modelDev.createClassifier();

      expect(classifier).toEqual(expect.any(Object));
    });
  });

  describe('utility methods', () => {
    it('should return config', () => {
      const config = modelDev.getConfig();
      expect(config).toEqual(expect.any(Object));
      expect(config.batchSize).toBe(32);
    });

    it('should return initialization status', async () => {
      await modelDev.initialize(mockConfig);
      expect(modelDev.isInitialized()).toBe(true);
    });

    it('should return models list', () => {
      const models = modelDev.getModels();
      expect(models).toEqual(expect.any(Array));
      expect(models.length).toBeGreaterThan(0);
    });

    it('should return active models', () => {
      const activeModels = modelDev.getActiveModels();
      expect(activeModels).toEqual(expect.any(Object));
    });
  });
});