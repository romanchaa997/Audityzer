const fs = require('fs-extra');
const fs = require('fs-extra');
const path = require('path');
const RemediationGenerator = require('../../../src/core/ai-vulnerability-detection/model-development/remediation-generator');

describe('RemediationGenerator', () => {
  let mockConfig;
  let tempDir;

  beforeEach(async () => {
    tempDir = path.join(__dirname, 'temp-remediation-output');
    mockConfig = {
      templatePath: path.join(__dirname, 'temp-remediation-templates'),
      customRemediationPath: path.join(__dirname, 'temp-custom-remediations'),
      confidenceThreshold: 0.7,
      useAI: false, // Disable AI for testing
    };
    await RemediationGenerator.initialize(mockConfig);
  });

  afterEach(() => {
    jest.restoreAllMocks();
    // Clean up temp directories
    try {
      if (fs.existsSync(tempDir)) {
        fs.removeSync(tempDir);
      }
      if (fs.existsSync(mockConfig.templatePath)) {
        fs.removeSync(mockConfig.templatePath);
      }
      if (fs.existsSync(mockConfig.customRemediationPath)) {
        fs.removeSync(mockConfig.customRemediationPath);
      }
    } catch (error) {
      // Ignore cleanup errors in tests
      console.warn('Cleanup warning:', error.message);
    }
  });

  describe('initialization', () => {
    it('should initialize with default config', async () => {
      const result = await RemediationGenerator.initialize();
      expect(result.status).toBe('success');
      expect(RemediationGenerator.isInitialized()).toBe(true);
    });

    it('should initialize with custom config', async () => {
      expect(RemediationGenerator.isInitialized()).toBe(true);
      const config = RemediationGenerator.getConfig();
      expect(config.confidenceThreshold).toBe(0.7);
    });

    it('should create required directories', () => {
      expect(fs.existsSync(mockConfig.templatePath)).toBe(true);
      expect(fs.existsSync(mockConfig.customRemediationPath)).toBe(true);
    });
  });

  describe('generateRemediationReport', () => {
    const mockVulnerabilities = [
      {
        id: 'vuln-1',
        name: 'Reentrancy Vulnerability',
        classification: 'REENTRANCY',
        description: 'Reentrancy vulnerability in withdraw function',
        severity: 'high',
        code: `
          function withdraw() public {
            msg.sender.call{value: balance}("");
            balance = 0;
          }
        `,
      },
      {
        id: 'vuln-2',
        name: 'Access Control Issue',
        classification: 'ACCESS_CONTROL',
        description: 'Missing access control on admin function',
        severity: 'medium',
      },
    ];

    it('should generate remediation report for vulnerabilities', async () => {
      const report = await RemediationGenerator.generateRemediationReport(mockVulnerabilities);

      expect(report).toEqual(expect.any(Object));
      expect(report.vulnerabilityCount).toBe(2);
      expect(report.remediations).toEqual(expect.any(Array));
      expect(report.remediations.length).toBe(2);
      expect(report.remediations[0]).toHaveProperty('vulnerabilityId');
      expect(report.remediations[0]).toHaveProperty('title');
      expect(report.remediations[0]).toHaveProperty('description');
      expect(report.remediations[0]).toHaveProperty('solutions');
    });

    it('should handle empty vulnerability list', async () => {
      const report = await RemediationGenerator.generateRemediationReport([]);

      expect(report).toEqual(expect.any(Object));
      expect(report.vulnerabilityCount).toBe(0);
      expect(report.remediations).toEqual(expect.any(Array));
      expect(report.remediations.length).toBe(0);
    });

    it('should generate generic remediation for unknown vulnerability types', async () => {
      const unknownVuln = {
        id: 'vuln-unknown',
        name: 'Unknown Issue',
        classification: 'UNKNOWN_TYPE',
        description: 'Some unknown vulnerability',
        severity: 'medium',
      };

      const report = await RemediationGenerator.generateRemediationReport([unknownVuln]);

      expect(report.remediations).toEqual(expect.any(Array));
      expect(report.remediations.length).toBe(1);
      expect(report.remediations[0].generatedBy).toBe('generic');
    });
  });

  describe('utility methods', () => {
    it('should return config', () => {
      const config = RemediationGenerator.getConfig();
      expect(config).toEqual(expect.any(Object));
      expect(config.confidenceThreshold).toBe(0.7);
    });

    it('should return initialization status', () => {
      const status = RemediationGenerator.isInitialized();
      expect(status).toBe(true);
    });

    it('should return remediation templates', () => {
      const templates = RemediationGenerator.getRemediationTemplates();
      expect(templates).toEqual(expect.any(Object));
      expect(templates.REENTRANCY).toEqual(expect.any(Array));
      expect(templates.ACCESS_CONTROL).toEqual(expect.any(Array));
    });
  });
});